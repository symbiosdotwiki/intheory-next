<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/ef46db3751d8e999.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/1f3e61366d75a951.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-3c607542019d470f.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-8a63aa861feeb827.js" async=""></script><script src="/_next/static/chunks/864-50dded804bdc16dd.js" async=""></script><script src="/_next/static/chunks/main-app-a39031ce3c651f3f.js" async=""></script><title>In Theory</title><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body><div class="container"><div class="container intro hidden shown "><div class="introContainer crtBg introClose "><div class="introScreen crtScreen"><div class="centerI"><span></span><span class="blinking">â€¡</span></div></div></div><canvas></canvas></div></div><script src="/_next/static/chunks/webpack-3c607542019d470f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/ef46db3751d8e999.css\",\"style\"]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/1f3e61366d75a951.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":6054,\"chunks\":[\"272:static/chunks/webpack-3c607542019d470f.js\",\"971:static/chunks/fd9d1056-8a63aa861feeb827.js\",\"864:static/chunks/864-50dded804bdc16dd.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":1729,\"chunks\":[\"272:static/chunks/webpack-3c607542019d470f.js\",\"971:static/chunks/fd9d1056-8a63aa861feeb827.js\",\"864:static/chunks/864-50dded804bdc16dd.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":1443,\"chunks\":[\"272:static/chunks/webpack-3c607542019d470f.js\",\"971:static/chunks/fd9d1056-8a63aa861feeb827.js\",\"864:stat"])</script><script>self.__next_f.push([1,"ic/chunks/864-50dded804bdc16dd.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":8639,\"chunks\":[\"272:static/chunks/webpack-3c607542019d470f.js\",\"971:static/chunks/fd9d1056-8a63aa861feeb827.js\",\"864:static/chunks/864-50dded804bdc16dd.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ef46db3751d8e999.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"e7mrdGT-tlxmS7QqFp3sO\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/\",\"initialTree\":[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L5\"],\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$L9\",\"$La\",null],\"segment\":\"__PAGE__\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/1f3e61366d75a951.css\",\"precedence\":\"next\"}]]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"b:I{\"id\":7188,\"chunks\":[\"750:static/chunks/e6f75348-27aa028ef5fea883.js\",\"188:static/chunks/188-567110ce3c89c38c.js\",\"931:static/chunks/app/page-42002366aa36b382.js\"],\"name\":\"\",\"async\":false}\nc:T5b9,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 resolution;\n// uniform vec2 center;\nuniform float radius;\nuniform sampler2D rand;\nuniform sampler2D pebbles;\nuniform float iTime;\n\nconst vec2 zOffset = vec2(37.0,17.0);\nconst vec2 wOffset = vec2(59.0,83.0);\n\nvec4 texNoise(vec2 uv)   // Emulate a single texture fetch into the precalculated texture\n{\n    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.\n    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.\n    float r = texture2D( rand, mod((uv+0.5)/256.0, 1.)).r;\n    float g = texture2D( rand, mod((uv+0.5 + zOffset)/256.0, 1.)).r;\n    float b = texture2D( rand, mod((uv+0.5 + wOffset)/256.0, 1.)).r;\n    float a = texture2D( rand, mod((uv+0.5 + zOffset + wOffset)/256.0, 1.)).r;\n    \n    return vec4(r, g, b, a);\n}\n\n\nfloat noise4dFast( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;\n    \n    vec4 s = texNoise(uv);\n    return mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);\n}\n\nvoid main() {\n\tvec2 uv = 2.*(gl_FragCoord.xy / resolution - vec2(.5));\n\tvec4 col = vec4(vec3(0.), 1.);\n\n\tvec2 center = vec2(0.);\n\tcenter.x = 1.6 * noise4dFast(vec4(vec3(0.), iTime / 3. + 0.)) - .8;\n\tcenter.y = 1.6 * noise4dFast(vec4(iTime / 3. + 9999., vec3(0.))) - .8;\n\n\tif(length(uv-center)\u003cradius){\n\t\tcol.xyz = texture2D(pebbles, (uv-center) / radius).rgb;\n\t}\n\tgl_FragColor = col;\n}"])</script><script>self.__next_f.push([1,"d:T482,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nuniform int pass;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n\tvec4 valueRAW = texture2D(tex, texcoord);\n\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main() {\n\tfloat sum = 0.;\n\n\tconst int count = 1;\n\tint length = 2 * count + 1;\n\tfloat scale = float(length * length);\n\tscale = float(length);\n\n\tfor(int i = -count; i \u003c= count; i++){\n\t\t// for(int j = -count; j \u003c= count; j++){\n\t\t\tvec2 fragCoord = gl_FragCoord.xy + vec2(i, 0.);\n\t\t\tif(pass \u003e 0){\n\t\t\t\tfragCoord = gl_FragCoord.xy + vec2(0., i);\n\t\t\t}\n\t\t\tvec2 uv = fragCoord / resolution;\n\t\t\tsum += extract(u_texture, uv).x / scale;\n\t\t// }\n\t}\n\tgl_FragColor = pack(vec2(sum, 0.));\n}"])</script><script>self.__next_f.push([1,"e:T983,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform float time;\nuniform float saturation;\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nuniform sampler2D u_add;\n\nuniform float lightHue;\nuniform float secondLight;\nuniform float hueShift;\nuniform float satMult;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\nconst float PI = 3.1415926535;\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n\tvec4 valueRAW = texture2D(tex, texcoord);\n\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tc.r = mod(c.r, 1.);\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 thinfilm(float t, float x, float d){\n\treturn .5*(vec3(\n\t\tcos( 2.*PI * (x) ),\n\t\tcos( 2.*PI * 1.1 * t * (x + .0) ),\n\t\tcos( 2.*PI * 1.2 * t * (x + .0) )\n\t) * exp(-d * t) + 1.);\n}\n\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tvec2 l = extract(u_texture, uv);\n\tfloat lh = 1. + sin(lightHue);\n\n\tvec3 tf = vec3(\n\t\tsin(lightHue * 2. * PI),\n\t\tsin(lightHue * 2.1 * PI + .5), \n\t\tsin(lightHue * 2.3 * PI + 1.)\n\t);\n\tlh = rgb2hsv(tf).x;\n\n\t//vec3 light1 = thinfilm(3.*lh, .5, .3);// 1./saturation);\n\tvec3 light1 = l.x * hsv2rgb(vec3(lh, saturation * satMult, .85));\n\t// vec3 light2 = l.y * thinfilm(1.-l.y, lightHue, 1./saturation);\n\t// light2 = vec3(0.);\n\tvec3 light2 = l.y * hsv2rgb(vec3(lh + .5, saturation * satMult, .85));\n\tvec3 rgb = texture2D(u_add, uv).rgb;\n\t// rgb = rgb2hsv(rgb);\n\t// rgb = hsv2rgb(rgb + vec3(hueShift, 0., 0.));\n\tvec3 val = light1 + secondLight * light2 + rgb;\n\tgl_FragColor = vec4(val, 1.);\n\t// gl_FragColor = vec4(light1, 1.);\n\t// gl_FragColor = vec4(thinfilm(uv.x*4., .8, .2), 1.);\n}"])</script><script>self.__next_f.push([1,"f:T539,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_curFrame;\nuniform sampler2D u_prevFrame;\nuniform float feedback1;\nuniform float feedback2;\nuniform float feedbackScale;\nuniform bool HD;\n\nconst float BASE = 255.0;\nconst float RANGE = BASE * BASE;\nconst float OFFSET = 0.0;\n\nvec2 encode(float value) {\n    value = floor(value * RANGE + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / RANGE;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n\tvec4 valueRAW = texture2D(tex, texcoord);\n\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tvec2 uvScaled = ( uv - vec2(.5) ) * feedbackScale + vec2(.5);\n\t// uv -= .5;\n\t// uv *= scale;\n\t// uv += .5;\n\tfloat prevFrame = extract(u_prevFrame, uvScaled).x;\n\tfloat curFrame = extract(u_curFrame, uv).x;\n\n\t// float alpha = curFrame.y;\n\n\t// prevFrame.a = 0.0;\n\n\tfloat feedback = 0.985 + feedback1 + feedback2;\n\tif(!HD){\n\t\tfeedback *= .998;\n\t}\n      \n\n\tfloat nextFrame = curFrame + feedback * prevFrame;\n\n\tif(nextFrame \u003e 1.0){\n\t\tnextFrame = 1.0;\n\t}\n\n\tgl_FragColor = pack(vec2(nextFrame, 0.));\n\t\n}"])</script><script>self.__next_f.push([1,"10:T8ca,"])</script><script>self.__next_f.push([1,"precision highp float;\n\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nconst int numColors = 4;\nuniform float multiplier;\nuniform float hueShift;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\nconst float PI = 3.1415926535897;\n\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float c1, float c2, float c3) {\n\treturn hsv2rgb(vec3(c1, c2, c3));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n\tvec4 valueRAW = texture2D(tex, texcoord);\n\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main () {\n\tvec3 colors[numColors];\n\t// colors[0] = hsv2rgb(0., 0., 0.);\n\t// colors[1] = hsv2rgb(.2, .6, .75);\n\t// colors[2] = hsv2rgb(.9, .75, .95);\n\t// colors[3] = hsv2rgb(.65, .9, .95);\n\n\t// colors[0] = hsv2rgb(0., 0., 0.);\n\t// colors[1] = hsv2rgb(.02, .6, .75);\n\t// colors[2] = hsv2rgb(.55, .75, .95);\n\t// colors[3] = hsv2rgb(.25, .9, .95);\n\n\tcolors[0] = hsv2rgb(0. + sin(hueShift * 1. * PI) + hueShift, 0., 0.);\n\tcolors[1] = hsv2rgb(.42 - sin(hueShift * 2. * PI), .6, .75);\n\tcolors[2] = hsv2rgb(.95 + 1.5*sin(hueShift * 1. * PI) + hueShift, .75, .95);\n\tcolors[3] = hsv2rgb(.15 + 2.*sin(hueShift * 2. * PI), .9, .95);\n\n\tfloat positions[numColors];\n\tpositions[0] = .001;\n\tpositions[1] = .15;\n\tpositions[2] = .4;\n\tpositions[3] = .999;\n\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tfloat val = extract(u_texture, uv).x;// * multiplier;\n\t// val = pow(val, .6);\n\n\tvec3 color = vec3(0.);\n\n\tbool found = false;\n\n\tif(positions[0] \u003e val){\n\t\tcolor = colors[0];\n\t}\n\telse if(positions[numColors-1] \u003c val){\n\t\tcolor = colors[numColors-1];\n\t}\n\telse{\n\t\tfor(int i = 1; i \u003c numColors; i++){\n\t\t\tif(positions[i] \u003e val \u0026\u0026 !found){\n\t\t\t\tvec3 color1 = colors[i-1];\n\t\t\t\tvec3 color2 = colors[i];\n\t\t\t\tfloat range = positions[i] - positions[i-1];\n\t\t\t\tfloat alpha = (val - positions[i-1]) / range;\n\t\t\t\tcolor = alpha * color2 + (1.-alpha)*color1;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// color = vec3(val);\n\n\t// vec3 color = hsv2rgb(vec3(val, .5, .95));\n\n\tgl_FragColor = vec4(color, 1.);\n}"])</script><script>self.__next_f.push([1,"11:T21ee,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nvarying vec2 v_texcoord;\nuniform vec2 resolution;\nuniform sampler2D u_pheromones;\nuniform sampler2D u_position;\nuniform sampler2D u_velocity;\nuniform int pass;\nuniform float time;\nuniform vec3 lmh;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\nconst float PI = 3.1415926535;\n\nfloat atan2(in float y, in float x)\n{\n    float s = (abs(x) \u003e abs(y)) ? 1. : 0.;\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat noise(vec2 uv, float time){\n\treturn noise(vec3(uv, time));\n}\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nfloat sinh(float x){\n\treturn ( exp(x) - exp(-x) ) / 2.;\n}\n\nfloat cosh(float x){\n\treturn ( exp(x) + exp(-x) ) / 2.;\n}\n\nfloat tanh(float x){\n\treturn sinh(x) / cosh(x);\n}\n\nfloat sStep(float x, int nSteps, int aI){\n\tfloat a = float(aI);\n\tx *= 2.;\n\tx = mod(x, 1.);\n\tfloat h = 1. / (.00001 + float(nSteps));\n\tfloat w = h;\n\t// return 1. - abs(1. - h * (\n\t// \t1./(2.*tanh(a/2.)) * tanh(\n\t// \t\ta * (fract(x/w)-0.5)\n\t// \t) + .5 + floor(x/w)\n\t// ));\n\treturn 1. - abs(\n\t\t1. - h * (\n\t\t\t.5 / tanh(a/2.) * tanh(\n\t\t\t\ta * (\n\t\t\t\t\t(x/w - floor(x/w)) - 0.5)\n\t\t\t\t) + .5 + floor(x/w)\n\t\t\t)\n\t\t);\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n\tvec4 valueRAW = texture2D(tex, mod(texcoord, 1.));\n\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvec2 n2rand(float mult) {\n\treturn vec2(\n\t\tfract(sin(dot(v_texcoord.xy * mult, vec2(12.9898, 78.233))) * 43758.5453),\n\t\tfract(sin(dot(v_texcoord.xy * 1.61803 * mult, vec2(12.9898, 78.233))) * 43758.5453)\n\t);\n}\n\nvec2 n2rand() {\n\treturn n2rand(1.);\n}\n\nvec2 unitCircle(float angle){\n\treturn vec2( cos(angle), sin(angle) );\n}\n\nvec2 unitCircleDeg(float angle){\n\treturn unitCircle(PI*angle/180.0);\n}\n\nvoid main() {\n\tfloat maxVel = 1.8 + .45 * sin(time*3.111) +  + .9 * cos(time*.411);\n\tif(pass == 0){\n\t\tvec2 r, d, a, x, v;\n\n\t\tvec2 velOut, posOut;\n\n\t\tx = extract(u_position, v_texcoord);\n\t\tv = extract(u_velocity, v_texcoord);\n\n\t\tvelOut = (2. * v - 1.);\n\n\t\tvec2 uv = x;\n\n\t\tfloat velMult = 1.;\n\n\t\t// sin(time*1.63)*\n\t\tfloat sensorDist = 33. + 32.*(pow(noise(\n\t\t\tuv * sStep(.0173*time, 12, 1) * 6., \n\t\t\ttime * .43752\n\t\t), 1.) *2. - 1.);\n\n\t\t// sensorDist = 30.;\n\n\t\t// sensorDist = 30.;\n\n\t\t// float sensorDist2 = 15. + 14.*(pow(noise(vec3(\n\t\t// \tuv * 1.*(1. + cos(time * 3.21334)), \n\t\t// \ttime * 15.232)\n\t\t// ), 2.) *2. - 1.);\n\n\t\t// float sensorDist3 = 70. + 69.*(pow(noise(vec3(\n\t\t// \tuv * 15.*(1. + cos(time * 1.21334)), \n\t\t// \ttime * 5.232)\n\t\t// ), 2.) *2. - 1.);\n\t\tfloat multy = sStep(.773*time, 10, 4) * 3. + 1.;\n\t\t// multy = 3.;\n\t\t// multy = pow(noise(uv * 1., time * .122), 2.) * 3. + 1.;\n\t\tfloat sensorDist2 = sensorDist / multy;\n\t\tfloat sensorDist3 = sensorDist * multy;\n\n\t\t// float degTurn = 1.// + 8.2*(sin(time*1.512)+1.)/2.567;\n\t\t// + 5.*(pow(noise(\n\t\t// \tuv*(2. + 3.5*sin(time*1.885)), \n\t\t// \ttime*0.7112\n\t\t// ) * 2. - 1., 33.));\n\n\t\tfloat degTurn = 20.*(2. + sin(time*.1347))*sStep(\n\t\t\tnoise(\n\t\t\t\tuv*(sStep(time*.07742, 10, 4)*3.), \n\t\t\t\t.2144*time\n\t\t\t),\n\t\t10, 6);\n\n\t\tfloat randAngle = 90.*sStep(\n\t\t\tnoise(\n\t\t\t\tuv*(1. + sStep(time*.06342, 10, 2)*4.),\n\t\t\t\t.5131*time\n\t\t\t),\n\t\t16, 6);\n\t\t// randAngle = degTurn;\n\n\t\t// + 8.2*(sin(time*5.12)+1.)/2.56;\n\t\tdegTurn = radians(degTurn);\n\t\trandAngle = radians(randAngle);\n\n\t\tfloat degRange = degTurn * sStep(.0143*time, 4, 4);\n\n\t\t// float degRange = 180.*sStep(300.*time, 8, 100);\n\t\t// degRange = radians(degRange);\n\n\t\tfloat curSensor = extract(u_pheromones, uv).r * 4. * (1.5+sin(time / 3.12));\n\n\t\tfloat degMulty= 1.5 * 2.-curSensor;\n\t\tfloat velMulty = 1.2 * curSensor;\n\t\tdegRange *= curSensor;\n\t\trandAngle *= curSensor * sin(time / 1.12);\n\t\tdegTurn *= 1.1 + sin(curSensor / 3.3);\n\t\tsensorDist *= pow(curSensor, 1.+sin(time*2.114));\n\t\tsensorDist2 *= curSensor;\n\t\tsensorDist3 *= curSensor;\n\n\t\tfloat velAngle = atan2(velOut.y, velOut.x);\n\n\t\tvec2 sensorDistScaled = sensorDist / resolution;\n\t\tvec2 sensorDistScaled2 = sensorDist2 / resolution;\n\t\tvec2 sensorDistScaled3 = sensorDist3 / resolution;\n\n\n\t\tvec2 fSensorOffset = sensorDistScaled * unitCircle(velAngle);\n\t\tvec2 lSensorOffset = sensorDistScaled * unitCircle(velAngle + degRange);\n\t\tvec2 rSensorOffset = sensorDistScaled * unitCircle(velAngle - degRange);\n\n\t\tfloat fSensor = extract(u_pheromones, uv + fSensorOffset).r;\n\t\tfloat lSensor = extract(u_pheromones, uv + lSensorOffset).r;\n\t\tfloat rSensor = extract(u_pheromones, uv + rSensorOffset).r;\n\n\n\t\t// vec2 fSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle);\n\t\t// vec2 lSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle + degRange/degMulty);\n\t\t// vec2 rSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle - degRange/degMulty);\n\n\t\t// float fSensor2 = extract(u_pheromones, uv + fSensorOffset2).r;\n\t\t// float lSensor2 = extract(u_pheromones, uv + lSensorOffset2).r;\n\t\t// float rSensor2 = extract(u_pheromones, uv + rSensorOffset2).r;\n\n\n\t\t// vec2 fSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle);\n\t\t// vec2 lSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle + degRange*degMulty);\n\t\t// vec2 rSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle - degRange*degMulty);\n\n\t\t// float fSensor3 = extract(u_pheromones, uv + fSensorOffset3).r;\n\t\t// float lSensor3 = extract(u_pheromones, uv + lSensorOffset3).r;\n\t\t// float rSensor3 = extract(u_pheromones, uv + rSensorOffset3).r;\n\n\n\t\t// // fSensor3 = 0.;\n\t\t// // lSensor3 = 0.;\n\t\t// // rSensor3 = 0.;\n\n\t\t// fSensor = max(max(fSensor, fSensor2), fSensor3);\n\t\t// lSensor = max(max(lSensor, lSensor2), lSensor3);\n\t\t// rSensor = max(max(rSensor, rSensor2), rSensor3);\n\n\t\tfloat lrDiff = abs(lSensor - rSensor);\n\t\tlrDiff *= 3.;\n\t\tlrDiff = 1. / (lrDiff + 2.1);\n\n\n\t\tif(fSensor \u003e= lSensor \u0026\u0026 fSensor \u003e= rSensor){\n\t\t\tvelOut = unitCircle(velAngle) * lrDiff;\n\t\t}\n\t\tif(lSensor \u003e= fSensor \u0026\u0026 lSensor \u003e= rSensor){\n\t\t\t// if(lSensor == lSensor2){\n\t\t\t// \tdegTurn /= degMulty;\n\t\t\t// \tvelMult *= velMulty;\n\t\t\t// }\n\t\t\t// else if(lSensor == lSensor3){\n\t\t\t// \tdegTurn *= degMulty;\n\t\t\t// \tvelMult /= velMulty;\n\t\t\t// }\n\t\t\tvelOut = unitCircle(velAngle + degTurn) * lrDiff;\n\t\t}\n\t\telse if(rSensor \u003e= lSensor \u0026\u0026 rSensor \u003e= fSensor){\n\t\t\t// if(rSensor == rSensor2){\n\t\t\t// \tdegTurn /= degMulty;\n\t\t\t// \tvelMult *= velMulty;\n\t\t\t// }\n\t\t\t// else if(rSensor == rSensor3){\n\t\t\t// \tdegTurn *= degMulty;\n\t\t\t// \tvelMult /= velMulty;\n\t\t\t// }\n\t\t\tvelOut = unitCircle(velAngle - degTurn) * lrDiff;\n\t\t}\n\t\telse{\n\t\t//   float randVal = n2rand();\n\t\t\tfloat rNum = sin(5000000.*time*n2rand(time*10.).r);\n\t\t\trNum = n2rand(time*10.).r - .5;\n\n\t\t\t\t// float curVal = texture2D(u_pheromones, uv).r;\n\t\t\t //  velOut = unitCircle(velAngle + fSensor * degTurn * sin(time));\n\t\t\t if(rNum \u003e 0.){\n\t\t\t \tvelOut = unitCircle(velAngle - randAngle) * .9;\n\t\t\t }\n\t\t\t else{\n\t\t\t \tvelOut = unitCircle(velAngle + randAngle) * .9;\n\t\t\t }\n\n\t\t\t // velOut = vec2(0.);\n\n\t\t\t // velOut = unitCircle(velAngle + 8. * sin(time*2.997));\n\t\t  // velOut = rNum;\n\t\t}\n\n\t\t// velOut -= vec2(.75, 0.);\n\n\t\t// posOut += velOut;\n\t\tvelOut *= noise(vec3(uv * 3.* (1.1 + sin(time*.11325)), time*1.113)) * .5 + .5;\n\t\tvelOut *= velMult * dot(vec3(1.), lmh) * 4.5;// * 2.;\n\t\tv = (velOut + vec2(1.)) / 2.;\n\n\t\t\n\n\t\tgl_FragColor = pack(v);\n\t}\n\tif(pass == 1){\n\t\tvec2 x = extract(u_position, v_texcoord);\n\t\tvec2 v = extract(u_velocity, v_texcoord);\n\n\t\tfloat lenX = pow(smoothstep(0., .5, length(x-.5)), 4.) * .8;\n\n\t\tv = 2. * v - vec2(1.);\n\t\t// v = -.3 * (1. - lenX) * x ;//+ lenX * v;\n\t\tv = -lenX * (x - .5) * .3 + (1.-lenX)*v;\n\t\tx += v * maxVel / resolution;\n\n\n\t\tif(length(x -.5 + .1*unitCircle(n2rand().r * 22.*PI)) \u003e .45){\n\t\t\tx = vec2(0.5) + .25 * unitCircle(n2rand().x*200.) + .1 * unitCircle((n2rand().y*500.));\n\t\t}\n\n\t\tx = mod(x, 1.);\n\n\t\tgl_FragColor = pack(x);\n\t\t// gl_FragColor = pack(x);\n\t\t// gl_FragColor = texture2D(u_position, v_texcoord);\n\t}\n}"])</script><script>self.__next_f.push([1,"12:T856,"])</script><script>self.__next_f.push([1,"\nprecision highp float;\n\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nuniform float intensity;\n\nuniform vec2 lightXY;\nuniform float specularHardness;\nuniform float specularPower;\nuniform float diffusePower;\nuniform vec3 viewDir;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n\tvec4 valueRAW = texture2D(tex, texcoord);\n\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\n\nfloat luminance(vec3 c)\n{\n\treturn dot(c, vec3(.2126, .7152, .0722));\n}\n\nvec2 pixelOffset(vec2 offset){\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\treturn extract(u_texture, uv + offset);\n}\n\nvec3 calcNormal()\n{\n\tvec2 yOffset = vec2(0., 1. / resolution.s);\n\tvec2 xOffset = vec2(1. / resolution.t, 0.);\n\tfloat R = abs(pixelOffset(xOffset).x );\n\tfloat L = abs(pixelOffset(-xOffset).x );\n\tfloat U = abs(pixelOffset(yOffset).x );\n\tfloat D = abs(pixelOffset(-yOffset).x );\n\t\t\t\t \n\tfloat X = (L-R) * .5;\n\tfloat Y = (U-D) * .5;\n\n\treturn normalize(vec3(X, Y, 1. / intensity));\n}\n\nvoid main()\n{\n\tvec3 n = calcNormal();\n\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\n\tvec3 lp1 = vec3(lightXY, 2.) + vec3(.5, .5, 0.);\n\tvec3 lp2 = vec3(-lightXY, 2.) + vec3(.5, .5, 0.);\n\n\tvec3 sp = vec3(uv, -1.);\n\t\n\tvec3 c1 = diffusePower*vec3(dot(n, normalize(lp1 - sp)));\n\tvec3 c2 = diffusePower*vec3(dot(n, normalize(lp2 - sp)));\n\t\n    vec3 ep = vec3(.5, .5, 0.);\n\tc1 += specularPower*pow(clamp(dot(normalize(reflect(lp1 - sp, n)), \n\t\t\t\t\t   normalize(sp - ep)), 0., 1.), specularHardness);\n\tc2 += specularPower*pow(clamp(dot(normalize(reflect(lp2 - sp, n)), \n\t\t\t\t\t   normalize(sp - ep)), 0., 1.), specularHardness);\n\n\tfloat mult = sqrt(extract(u_texture, uv).r);\n\tgl_FragColor = pack(vec2(c1.r*mult, c2.r*mult));\n\t// gl_FragColor = vec4(c, 1.);\n}\n"])</script><script>self.__next_f.push([1,"13:T4fab,"])</script><script>self.__next_f.push([1,"precision highp float;\n\n// Uses code by IQ and anatole duprat - XT95/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look :\n// http://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n\nstruct Ray{\n  vec3 p;\n  int obj;\n  float d;\n};\n\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D randSampler;\nuniform vec3 iAudio;\nuniform vec2 iResolution;\n\nuniform float tunnelPos;\nuniform float fisheye;\nuniform vec2 creatureXY;\nuniform float tunnelLight;\nuniform float tunnelBase;\nuniform float creatureLight;\nuniform float wingRot;\nuniform float creatureFlip;\nuniform float creatureTwist;\nuniform int HD;\nuniform float fairyLight;\nuniform float tunnelWonky;\nuniform float tunnelWidth;\nuniform float checker;\nuniform float fairyTime;\nuniform vec2 rayUp;\n\nconst float PI = 3.14159265359;\nconst vec3 ax = vec3(1., 0., 0.);\n\nRay raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane );\nvec3 normal( in vec3 p );\nRay map( in vec3 p );\nmat3 lookat( in vec3 fw, in vec3 up );\nvec3 rotate( in vec3 v, in float angle, in vec3 pos);\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat smin( float a, float b, float k );\n\n\nvec3 lpos1,lpos2,lpos3;\nvec3 lpos4,lpos5,lpos6;\nvec3 pCreature, pCreatureOffset;\nvec4 rCreature;\nvec3 posOff;\nvec3 sssColor, diffColor1, diffColor2, diffColor3;\n\n// vec2 tunnelOffset, tunnelWave;\n// vec4 rCreatureI;\nvec3 pTunnel;\n\nvec3 fairy[9];\nconst int numFairy = 9;\n\nfloat aoMaxSteps = 3.0;\n\n\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{ \n  vec4 qr;\n  float half_angle = (angle * 0.5);\n  qr.x = axis.x * sin(half_angle);\n  qr.y = axis.y * sin(half_angle);\n  qr.z = axis.z * sin(half_angle);\n  qr.w = cos(half_angle);\n  return qr;\n}\n\nvec4 quat_conj(vec4 q)\n{ \n  return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotate_vertex_position(vec3 position, vec4 qr)\n{ \n  // vec4 qr = quat_from_axis_angle(axis, angle);\n  vec4 qr_conj = quat_conj(qr);\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n  \n  vec4 q_tmp = quat_mult(qr, q_pos);\n  qr = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(qr.x, qr.y, qr.z);\n}\n\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = texture2D(randSampler, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 600.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0., 0.), pos.z), f - vec2(0., 0.)),\n                dot(GetGradient(i + vec2(1., 0.), pos.z), f - vec2(1., 0.)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0., 1.), pos.z), f - vec2(0., 1.)),\n                dot(GetGradient(i + vec2(1., 1.), pos.z), f - vec2(1., 1.)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\nvec3 threePsuedo3dNoise(vec3 pos){\n    vec3 threeNoise;\n    threeNoise.x = Pseudo3dNoise(pos + vec3(0.1, 0., 0.));\n    threeNoise.y = Pseudo3dNoise(pos + vec3(0.3111, 10., 999.123));\n    threeNoise.z = Pseudo3dNoise(pos + vec3(0.3578, 110., 999999.45));\n    return threeNoise;\n}\n\n\nvec3 objTrans(vec3 pos, vec3 oPos, vec4 qr){\n    return rotate_vertex_position(pos, qr) + oPos;\n}\n\nvec3 objTransI(vec3 pos, vec3 oPos, vec4 qr){\n    return rotate_vertex_position(pos - oPos, quat_conj(qr));\n}\n\nvec3 creature(vec3 pos){\n    return objTransI(pos + pCreatureOffset, pCreature, rCreature) - pCreatureOffset;\n}\n\nvec3 creatureI(vec3 pos){\n    return objTrans(pos - pCreatureOffset, pCreature, rCreature) + pCreatureOffset;\n}\n\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\nvec3 polarCoord(float r, float phi, float theta )\n{\n    // Theta starts at groundPlane\n \treturn vec3(\n        r * sin(PI/2. - theta) * cos(phi),\n        r * cos(PI/2. - theta),\n       \tr * sin(PI/2. - theta) * sin(phi)  \n    );\n}\n\nvec3 polarCoordDeg(float r, float phi, float theta )\n{\n \treturn polarCoord(r, phi * PI / 180., theta  * PI / 180. );\n}\n\nvec3 rectCoord(vec3 pos){\n \tfloat r = length(pos);\n    float theta = atan(pos.y, pos.x);\n    float phi = atan(length(pos.xy), pos.z);\n    return vec3(r, phi, theta);\n}\n\n// Picking colors with HSV is much simpler\nvec3 hsv(float cX, float cY, float cZ)\n{\n    cX -= float(int(cX));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);\n    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);\n}\n\n// Linear white point\nconst float W = 1.2;\nconst float T2 = 7.5;\n\n//Gamma correction\nvec3 gamma(vec3 x, float gamma) {\n    return pow(x, vec3(1./gamma));\n}\n\nfloat fadeIn(float t){\n \treturn min(iTime/t,1.); \n}\n    \n\nRay raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane ){\n    const int maxSteps = 80;\n    float epsilon = 0.001;\n\tRay ray = Ray(\n        ro+rd*nfplane.x, \n        -1,\n        -1.0\n    );\n\tfloat t = 0.;\n\tfor(int i=0; i\u003cmaxSteps; i++)\n\t{\n        ray = map(ray.p);\n        t += ray.d;\n        ray.p += rd * ray.d;\n        if( \n            ray.d \u003c epsilon || \n            t \u003e (nfplane.y - (1. - float(HD)) * 200.) ||\n            (i \u003e maxSteps / 4 \u0026\u0026 HD==0)\n        )\n            break;   \n\t}\n\t\n\treturn ray;\n}\n\nvec3 normal( in vec3 p ){\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy).d-map(p-eps.xyy).d,\n\t\tmap(p+eps.yxy).d-map(p-eps.yxy).d,\n\t\tmap(p+eps.yyx).d-map(p-eps.yyx).d\n\t) );\n}\n\n\nmat3 lookat( in vec3 fw, in vec3 up ){\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\n\nvec3 rotate( in vec3 v, in float angle, in vec3 pos){\n\tvec4 qr = quat_from_axis_angle(v, angle);\n    return rotate_vertex_position(pos, qr);\n}\n\n\nfloat skinLookup(vec2 pos)\n{\n    float phase = .4*texture2D(iChannel0, mod(pos / 4., 1.0)).r;\n    vec2 offset = vec2(sin(phase + iTime/20.), cos(phase + iTime/23.));\n    return texture2D(iChannel0, mod(pos + offset, 1.0)).r ;\n}\n\nfloat smin( float a, float b, float k ) //Thx to iq^rgba\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float d1, float d2, float k )\n{\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k \u003c 0.0 ) return length(q) - r1;\n    if( k \u003e a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, in float h)\n{\n    p.z /= h;\n    p.x = abs(p.x);\n    float k = (sc.y*p.x\u003esc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return (sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb) * min(h, 1.);\n}\n\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    for( int i=0; i\u003cnbIte; i++ )\n    {\n        if(HD == 0 \u0026\u0026 i \u003e nbIte / 8) break;\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n            \t\t\t\t\t\t\t\t\t\t\t\t        // for self occlusion problems\n        ao += (l - map( p + rd ).d) / pow(1.+l, falloff);\n    }\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n    // Num near samples\n\tconst int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);    \n\tfloat ao = 0.0;\n    for( int i=0; i\u003cnbIte; i++ )\n    {\n        if(HD == 0 \u0026\u0026 i \u003e nbIte / 8) break;\n            float l = hash(float(i))*maxDist;\n            // Normal is reversed from ao calculation\n            vec3 rd = normalize(-n)*l;\n            ao += (l + map( p + rd ).d) / pow(1.+l, falloff);\n        \n    }\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec4 calcTunnelOffset(vec3 tunnelP){\n    vec2 tO = 6.*vec2(sin(tunnelP.x/12.), cos(tunnelP.x/12.));\n    vec2 tW = 8.*vec2(sin(tunnelP.x/32.), cos(tunnelP.x/22.));\n    return vec4(tO, tunnelWonky * tW);\n}\n\n//Map\nRay map( in vec3 p )\n{\n    float fairyDist = 999.;\n    float fairySize = .08;\n    // if(HD == 1){\n    for(int i = 0; i \u003c numFairy; i++){\n        if(HD == 1 || mod(float(i), 2.) == 0.){\n        float fd = length(p - fairy[i]) - fairySize;\n        fairyDist = min(fairyDist, fd);\n        }\n    }\n    // }\n\n    vec3 pCreatROT = creature(p);;\n\n    vec3 bBallCenter = creature(lpos1) - posOff;\n    vec3 lBallCenter = creature(lpos1);\n    float wingRotMod = mod(-wingRot, 1.);\n    float suckIn = abs(3. * max(.333, wingRotMod) - 2.);\n    vec3 tBallCenter = bBallCenter + vec3(0., 5., 4.) * suckIn;\n    vec3 cBallCenter = bBallCenter + vec3(4. + sin(iTime), -3., 2.);\n\n    // Render light balls\n    float lightBallRad = .25;\n    //p.xz = mod(p.xz+100., 200.)-100.;\n    float d = 100.;//+textureLod(iChannel0, p.xz*.05, 0.0).r*1.5;\n    d = min(d, length(pCreatROT-creature(lpos1))-lightBallRad);\n    \n    float lightBallRadWing = .2;\n    d = min(d, length(pCreatROT-creature(lpos4))-lightBallRadWing);\n    d = min(d, length(pCreatROT-creature(lpos5))-lightBallRadWing);\n    d = min(d, length(pCreatROT-creature(lpos6))-lightBallRadWing);\n\n    // Render skin ball\n    \n    \n    \n    float bBallRad = 6.;\n    float lBallRad = lightBallRad + .5;\n    float tBallRad = 3.;\n    //p.xz = mod(p.xz, 60.)-30.;\n    //p = rotate(vec3(0.,1.,0.), p.y*.05*cos(iTime+sin(iTime*1.5+id.x*5.)+id.y*42.))*p;\n    float bD = length(pCreatROT-bBallCenter) - bBallRad;\n    float lD = length(pCreatROT-lBallCenter) - lBallRad;\n    float tD = length(pCreatROT-tBallCenter) - tBallRad;\n    float tD2 = length(pCreatROT-cBallCenter) - tBallRad/1.5  * (pow(iAudio[1], .5) + .5);\n    float texDisp = .35 * skinLookup(\n        (pCreatROT-bBallCenter).yz / 15.\n    );\n    d = min(d, smin(smin(smax(tD2, bD, 0.6), lD, 1.), tD, 2.) - texDisp );\n\n    //return d;\n    \n    vec3 pBranch = rotate(ax, 2.*PI/8., pCreatROT - bBallCenter);\n    float branch = sdRoundCone(pBranch, .7, .3, 10.);\n    \n    pBranch = rotate(ax, 3.*PI/8., pCreatROT - bBallCenter);\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\n    \n    pBranch = rotate(ax, 4.*PI/8., pCreatROT - bBallCenter);\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\n    \n    pBranch = rotate(ax, 5.*PI/8., pCreatROT - bBallCenter);\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\n    \n    vec3 pWing = rotate(ax, 1.38 - 2.*PI * wingRot,  \n        pCreatROT - bBallCenter + vec3(0., 0., .5));\n    float wing = sdCappedTorus(\n        pWing.zyx, \n        vec2(sin(.7),cos(.7)), \n        11., 1.5, .33\n    );\n    branch = smin(branch, wing, 1.);\n\n    d = smin(d, branch - texDisp * .5, 2.);\n\n    vec3 tunnelP = p - pTunnel;\n\n    vec4 tunnelOffset = calcTunnelOffset(tunnelP);\n    float tDist = length(tunnelP.yz + tunnelOffset.xy + tunnelOffset.zw);\n    float cylinder = max(\n        tunnelWidth - tDist, \n    0.);\n    cylinder *= min(1., 1./max(0.001, (abs(tunnelWonky)+.5)));\n    // // if(max(abs(tunnelOffset.x + tunnelOffset.z), abs(tunnelOffset.y + tunnelOffset.w)) \u003e 1.){\n    //     cylinder *= .5;\n    // // }\n    int obj = 0;\n\n    // if(HD == 1){\n    if(fairyDist \u003c d \u0026\u0026 fairyDist \u003c cylinder){\n        d = smin(d, fairyDist, .5);\n        obj = 2;\n    }\n    // }\n\n    else if(cylinder \u003c d){\n        obj = 1;\n        d = cylinder;\n    }\n    \n    return  Ray(p, obj, d);\n}\n\nvec3 gradLight(vec3 pos){\n    // pos = creature(pos - pCreatureOffset) + pCreatureOffset - pCreature;\n    pos = rotate_vertex_position(pos - pCreature - pCreatureOffset, quat_conj(rCreature)) + pCreatureOffset;\n    float angle = (atan(pos.y, pos.z) + PI) / (2. * PI);\n    return hsv(angle * 3. + .2*sin(iTime * 1.5), .8, .4);\n}\n\n//Shading\nvec3 shade( in Ray ray, in vec3 n, in vec3 ro, in vec3 rd )\n{\t\t\n    vec3 p = vec3(ray.p);\n\n    // vec3 diffColor4 = ;\n\n    vec3 dC4 = gradLight(lpos4);\n    vec3 dC5 = gradLight(lpos5);\n    vec3 dC6 = gradLight(lpos6);\n    \n    float nLookup = skinLookup(rectCoord(n).yz / 25.);\n    float nLookup2 = nLookup * nLookup - .5;\n    vec3 skinColor = hsv(0.03, 0.3, nLookup-.2) + hsv(0.03 + nLookup2*.8, 0.7 - nLookup2, nLookup);\n    skinColor /= 1.5;\n    skinColor = abs(skinColor * skinColor);\n    float roughness = 0.05;\n    float shininess = .05;\n    \n    \n    // Light positions wrt raymarch point\n    float lL1 = length(lpos1-p);\n    float lL2 = length(lpos2-p);\n    float lL3 = length(lpos3-p);\n    float lL4 = length(lpos4-p);\n    float lL5 = length(lpos5-p);\n    float lL6 = length(lpos6-p);\n\n\tvec3 ldir1 = (lpos1-p) / lL1;\t\n\tvec3 ldir2 =  (lpos2-p) / lL2;\t\n\tvec3 ldir3 =  (lpos3-p) / lL3;\n    \n    vec3 ldir4 = (lpos4-p) / lL4;\t\n\tvec3 ldir5 =  (lpos5-p) / lL5;\t\n\tvec3 ldir6 =  (lpos6-p) / lL6;\n    \n    float latt1 = .3*pow(lL1 *.15, 3. ) / iAudio.x;\n    float latt2 = pow( lL2*.15, 3. ) / iAudio.y;\n    float latt3 = 3.*pow( lL3*.15, 2.5 ) / iAudio.z;\n\n    float latt4 = .3*pow( lL4*.15, 3. ) / iAudio.x;\n    float latt5 = pow(lL5*.15, 3. ) / iAudio.y;\n    float latt6 = pow( lL6*.15, 3. ) / iAudio.z;\n\n    diffColor1 = hsv(-.001/latt1+.5, .8, .3);\n    \n    // SSS multiplier (thickness) and AO\n    float sssThick = .8;\n\tfloat thick = thickness(p, n, aoMaxSteps, 1./sssThick);\n    \n    float aoFalloff = 1.;\n\t// float occ = .1*pow( ambientOcclusion(p, n, aoMaxSteps, aoFalloff), 6.);\n\n    // Diffuse lighting from lights\n\t// vec3 diff1 = diffColor1 * (max(dot(n,ldir1),0.) ) / latt1;\n\tvec3 diff2 = diffColor2 * (max(dot(n,ldir2),0.) ) / latt2;\n\t// vec3 diff3 = diffColor3 * (max(dot(n,ldir3),0.) ) / latt3;\n\n    vec3 col = vec3(0.);//skinColor * diff2;// + diff2;// + diff3;\n    \n\n    vec3 refl = reflect(rd,n);  \n\n    float fairySSS = 0.;\n    if(HD == 1){\n        for(int i = 0; i \u003c numFairy; i++){\n            vec3 fpos = fairy[i];\n            float ftrans = clamp( dot(-rd, -fpos+n), 0., 1.) + 1.;\n            float flatt = pow( length(fpos-p), 4. );\n            fairySSS += ftrans/flatt;\n            }\n    }\n    fairySSS *= fairyLight;\n\n    float trans1 =  clamp( dot(-rd, -ldir1+n), 0., 1.) + 1. ;\n    float trans2 =  clamp( dot(-rd, -ldir2+n), 0., 1.) + 1. ;\n    float trans3 =  clamp( dot(-rd, -ldir3+n), 0., 1.) + 1. ;\n    \n    // SSS from lights inside\n    float trans4 =  clamp( dot(-rd, -ldir4+n), 0., 1.) + 1.;\n    float trans5 =  clamp( dot(-rd, -ldir5+n), 0., 1.) + 1. ;\n    float trans6 =  clamp( dot(-rd, -ldir6+n), 0., 1.) + 1. ;\n\n    vec3 headLights = diffColor3 * creatureLight * trans3/latt3; \n    vec3 bodyLights = creatureLight * gradLight(p) * (\n        dC4*trans4/latt4 + dC5*trans5/latt5 + dC6*trans6/latt6\n    );\n    vec3 topLight = diffColor2 * creatureLight * thick * trans2/latt2;\n    \n\n    if(ray.obj == 0){\n        col = skinColor * diff2;// + diff2;// + diff3;\n        // SSS from lights inside        \n        \n        col += thick * (sssColor * (\n            .01*diffColor1*trans1/latt1 + \n            .2 * topLight) +\n            .1 * headLights + \n            .05 * bodyLights +\n            .001 * fairySSS\n        ) ;\n        col *= (.2 + .8*skinColor);\n        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ),1./roughness);\n        col += shininess*spec + .02*skinColor;\n        // col = gradLight(p);\n    }\n\n    else if(ray.obj == 1){\n        vec3 pTunnelOff = p - pTunnel;\n        vec4 tunnelOffset = calcTunnelOffset(pTunnelOff);\n        pTunnelOff += 1. * vec3(0., tunnelOffset.xy);\n        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ), 1.);\n        spec = 1.;\n        spec =  3. * spec * iAudio[2] * tunnelLight + tunnelBase;\n        int dBool = int(mod(length(pTunnelOff.x/12.) * 2., 2.));\n        float angle = (atan(pTunnelOff.z, pTunnelOff.y)+PI) / (2. * PI);\n        int aFix = 0;\n        int aBool = int(mod(angle * checker - checker / 2. - .5, 2.));\n        float checker = mod(float(dBool + aBool + aFix), 2.0);\n        col = \n            vec3(checker) * (spec) * (\n                pow(min(abs(p.x-50.), 300.)/300., 4.)  + \n                2. * bodyLights + \n                15. * headLights +\n                pow(smoothstep(.0, .5, fairySSS), .6)\n            ) + 10.*pow(smoothstep(.0, 2., fairySSS), 1.) * .3;\n    }\n\n    else if(ray.obj == 2){\n        col = vec3(fairyLight * (iAudio[0] + .5));\n    }\n\n\treturn col;\n}\n\nvec3 render(vec2 q)\n{\n    // Camera coordinates\n\tvec2 v = -1.0 + 2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\n\n    sssColor = hsv(0.2, 0.6, 1.5);\n    diffColor1 = hsv(0.3, 0.9, .5);\n    diffColor2 = hsv(0.7, 0.1, 0.1);\n    diffColor3 = hsv(0.9, 0.1, 0.5);\n    \n    //Camera Settings\n    // float fisheye = ;\n    float lens = 1.9 - fisheye * length(v);\n    vec2 nfplane = vec2(.001, 400.);\n\n    vec3 lightOffset = vec3(cos(iTime*.5)*6., 0., sin(iTime*.5)*15.);\n\n    vec3 axisCreature = vec3(0., sin(iTime/1.4), cos(iTime/1.4));\n    vec3 axisCreatureFlip = vec3(0., 0., 1.);\n    vec3 axisCreatureTwist = vec3(0., 1., 0.);\n    pCreature =  vec3(-15.-5.*exp(-cos(iTime/1.77)),-1.5+exp(-sin(iTime)), -1.);\n    pCreature += vec3(creatureXY, 0.);\n    // pCreature = vec3(0);\n\n    posOff = vec3(6., 1.5, 1.5);\n    \n    pCreatureOffset = 3. * vec3(exp(-sin(iTime/1.53)),exp(-sin(iTime*1.11)), -cos(iTime*2.11));\n    \n    //Flip\n    rCreature = quat_from_axis_angle(axisCreature, 2.*PI*creatureFlip);\n    // rCreatureI = quat_from_axis_angle(axisCreature, -2.*PI*creatureFlip);\n\n    //Twist\n    rCreature = quat_mult(\n        rCreature,\n        quat_from_axis_angle(axisCreatureTwist, 2.*PI*creatureTwist)\n    );\n    // rCreatureI = quat_from_axis_angle(axisCreatureTwist, -2.*PI*creatureTwist);\n\n    rCreature = quat_mult(\n        rCreature,\n        quat_from_axis_angle(axisCreature, PI/6. * sin(iTime))\n    );\n    // rCreatureI = quat_from_axis_angle(axisCreature, -PI/6. * sin(iTime));\n\n    pTunnel = vec3(tunnelPos, 0., 0.);\n    \n\t//define lights pos\n    lpos1 = creatureI(vec3(6., 0., 0.));\n\tlpos2 = creatureI(vec3( 15., 3.5, 0.) + lightOffset);\n\tlpos3 = creatureI(vec3(2., 4., 2.8));\n    \n    lpos4 = creatureI(vec3(.5, 6.5, -9.5));\n    lpos5 = creatureI(\n        rotate(ax, 2.*PI * wingRot, vec3(.5, .65, -12.2) + posOff) - posOff - vec3(0., 0., .5)\n    );\n    lpos6 = creatureI(vec3(.5, -6., -11.));\n\n    // if(HD == 1){\n    for(int i = 0; i \u003c numFairy; i++){\n        if(HD == 1 || mod(float(i), 2.) == 0.){\n            fairy[i] = tunnelWidth * .8 * threePsuedo3dNoise(vec3(float(i+2)*12345.664, fairyTime, 0.)) + vec3(-10., 0., 0.);\n        }\n    }\n    // }\n   \n\t//camera ray\n    float camDist = 25.;\n    float camFreq = 9999999.;\n    vec3 ro = vec3(camDist, 0.0, 0.);\n    vec3 rd = normalize( vec3(v.x, v.y, lens) );\n    vec3 target = vec3(0.0, 0.0, 0.0);\n\trd = lookat( target-ro, vec3(0.,rayUp))*rd;\n    \n\t//classic raymarching by distance field\n\tRay ray = raymarche(ro, rd, nfplane );\n\tvec3 n = normal(ray.p.xyz);\n\tvec3 col = shade(ray, n, ro, rd);\n    return col;\n}\n\nvoid main()\n{\n    vec2 p = gl_FragCoord.xy/iResolution.xy; \n    vec3 col = render(p);\n    \n    col = gamma(col, 2.2); \n\n    // col = texture2D(iChannel0, p).rgb;   \n        \n\tgl_FragColor = vec4(col,1.0)*fadeIn(0.9);\n}\n"])</script><script>self.__next_f.push([1,"14:T628,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_diffuse;\nuniform sampler2D u_normal;\nuniform vec3 light;\nuniform float TIME;\nuniform float toggleStatus;\n\nconst float A_COL = .45;\nconst float I_COL = .17;\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  return hsv2rgb(vec3(h, s, v));\n}\n\nvoid main() {\n\tvec2 fragCoord = gl_FragCoord.xy;\n\tvec2 uv = fragCoord / resolution;\n\n\tvec3 diffuse = texture2D(u_diffuse, uv).rgb;\n\tvec3 normal = texture2D(u_normal, uv).rgb;\n\tvec3 metal = vec3(diffuse.r);\n\tvec3 buttons = toggleStatus \u003e 0. ? \n\t\thsv2rgb(I_COL, .85, diffuse.g) : hsv2rgb(A_COL, .85, diffuse.g);\n\n\tfloat height = 0.;\n\n\t// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;\n\tfloat alpha = ceil(diffuse.b);\n\tif(abs(uv.x-.5) \u003e .49){\n\t\talpha = 0.;\n\t}\n\n\tvec3 c = vec3(0.);\n\tif(alpha \u003e 0.){\n\t\t// Phong\n\t\tnormal = (normal - vec3(.5))*2.;\n\t\tvec3 lp = vec3(\n\t\t\t3. * (light.x / resolution.x - .5), \n\t\t\t// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\n\t\t\t3.*(1.-light.y / resolution.y - .5), \n\t\t\t1.\n\t\t);\n\t\tvec3 sp = vec3(uv - vec2(.5, .5), -1.);\n\t\tvec3 ep = vec3(.5, .5, 0.);\n\t\tc = hsv2rgb(TIME/80. + .5, .85, pow(\n\t\t\tclamp(\n\t\t\t\tdot(\n\t\t\t\t\tnormalize(reflect(lp-sp, normal)), \n\t\t\t\t\tnormalize(sp)\n\t\t\t\t),\n\t\t\t\t0., 1.\n\t\t\t),\n\t\t\t10.\n\t\t));\n\t}\n\n\n\tgl_FragColor = vec4(metal + buttons + c, 1.0) * alpha;\n}"])</script><script>self.__next_f.push([1,"15:Tc31,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 resolution;\nuniform vec2 hdAA;\nuniform sampler2D u_diffuse;\nuniform sampler2D u_buttons;\nuniform sampler2D u_playN;\nuniform sampler2D u_pauseN;\nuniform sampler2D u_height;\nuniform sampler2D u_lights;\nuniform vec3 light;\nuniform float TIME;\nuniform bool playing;\nuniform vec3 buttonStatus;\nuniform float toggleStatus;\n\nconst float A_COL = .45;\nconst float I_COL = .55;\nconst float B_COL = .1;\nconst float B_COL_2 = .75;\nconst float L_COL = .7;\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  return hsv2rgb(vec3(h, s, v));\n}\n\nfloat sigmoid(float x){\n\treturn 1.0 / (1.0 + exp(-1.0 * x));\n}\n\nvoid main() {\n\tvec2 fragCoord = gl_FragCoord.xy;\n\tvec2 uv = fragCoord / resolution;\n\n\tvec3 diffuse = texture2D(u_diffuse, uv).rgb;\n\tvec3 buttonLights = texture2D(u_buttons, uv).rgb;\n\tvec3 heightRGB = texture2D(u_height, uv).rgb;\n\tvec3 buttonLights2 = texture2D(u_lights, uv).rgb;\n\n\tvec3 normal = vec3(0.);\n\tvec3 metal = vec3(0.);\n\tvec3 buttons = vec3(0.);\n\tvec3 speakers = hsv2rgb(TIME/80., .85, diffuse.b);\n\n\tfloat text = heightRGB.g;\n\tfloat height = 0.;\n\n\tif(playing){\n\t\tmetal = vec3(diffuse.g);\n\t\tnormal = texture2D(u_playN, uv).rgb;\n\t\theight = heightRGB.r;\n\t\tbuttons += hsv2rgb(A_COL, .85, buttonLights.b * buttonStatus.b);\n\t}\n\telse{\n\t\tmetal = vec3(diffuse.r);\n\t\tnormal = texture2D(u_pauseN, uv).rgb;\n\t\theight = heightRGB.b;\n\t\tbuttons += hsv2rgb(A_COL, .85, buttonLights.g * buttonStatus.b);\n\t}\n\n\tif(uv.x \u003c .5){\n\t\tbuttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.r);\n\t}\n\telse{\n\t\tbuttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.g);\n\t}\n\n\t//info button\n\tif(uv.y \u003c .5){\n\t\tbuttons += hsv2rgb(I_COL, .85, buttonLights2.g);\n\t}\n\telse{\n\t\tif(uv.x \u003c .5){\n\t\t\tbuttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;\n\t\t}\n\t\telse{\n\t\t\tbuttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;\n\t\t}\n\t}\n\n\t//AA\n\tbuttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.r * hdAA.y) * 1.2, 0., 1.);\n\t//HD\n\tbuttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.b * hdAA.x) * 1.2, 0., 1.);\n\n\t// vec3 buttons = hsv2rgb(A_COL, .85, 1.) * color.g;\n\tfloat sOffset = toggleStatus*2. + .25;\n\tfloat alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);\n\n\tif(abs(uv.x-.5) \u003e .49){\n\t\talpha = 0.;\n\t}\n\n\tvec3 c = vec3(0.);\n\tif(alpha \u003e 0.){\n\t\t// Phong\n\t\tnormal = (normal - vec3(.5))*2.;\n\t\tvec3 lp = vec3(\n\t\t\t3. * (light.x / resolution.x - .5), \n\t\t\t// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\n\t\t\t3.*(1.-light.y / resolution.y - .5) * resolution.y / resolution.x, \n\t\t\t1.\n\t\t);\n\t\tvec3 sp = vec3(uv - vec2(.5, .5), -1.) * vec3(1., resolution.y / resolution.x, 1.);\n\t\tvec3 ep = vec3(.5, .5, 0.);\n\t\tc = hsv2rgb(TIME/80. + .5, .85, pow(\n\t\t\tclamp(\n\t\t\t\tdot(\n\t\t\t\t\tnormalize(reflect(lp-sp, normal)), \n\t\t\t\t\tnormalize(sp)\n\t\t\t\t),\n\t\t\t\t0., 1.\n\t\t\t),\n\t\t\t1000.\n\t\t));\n\t}\n\n\tgl_FragColor = vec4(metal + buttons + c + speakers, 1.0) * alpha;\n}"])</script><script>self.__next_f.push([1,"16:T98b,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_diffuse;\nuniform sampler2D u_buttons;\nuniform sampler2D u_playN;\nuniform sampler2D u_pauseN;\nuniform sampler2D u_height;\nuniform vec3 light;\nuniform float TIME;\nuniform bool playing;\nuniform vec3 buttonStatus;\nuniform float toggleStatus;\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  return hsv2rgb(vec3(h, s, v));\n}\n\nfloat sigmoid(float x){\n\treturn 1.0 / (1.0 + exp(-1.0 * x));;\n}\n\nvoid main() {\n\tvec2 fragCoord = gl_FragCoord.xy;\n\tvec2 uv = fragCoord / resolution;\n\n\tvec3 diffuse = texture2D(u_diffuse, uv).rgb;\n\tvec3 buttonLights = texture2D(u_buttons, uv).rgb;\n\tvec3 heightRGB = texture2D(u_height, uv).rgb;\n\n\tvec3 normal = vec3(0.);\n\tvec3 metal = vec3(0.);\n\tvec3 buttons = vec3(0.);\n\n\tfloat text = heightRGB.g;\n\tfloat height = 0.;\n\n\tif(playing){\n\t\tmetal = vec3(diffuse.g);\n\t\tnormal = texture2D(u_playN, uv).rgb;\n\t\theight = heightRGB.r;\n\t\tbuttons += hsv2rgb(.33, .85, buttonLights.b * buttonStatus.b);\n\t}\n\telse{\n\t\tmetal = vec3(diffuse.r);\n\t\tnormal = texture2D(u_pauseN, uv).rgb;\n\t\theight = heightRGB.b;\n\t\tbuttons += hsv2rgb(.33, .85, buttonLights.g * buttonStatus.b);\n\t}\n\n\tif(uv.x \u003c .5){\n\t\tbuttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.r);\n\t}\n\telse{\n\t\tbuttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.g);\n\t}\n\n\t// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;\n\tfloat sOffset = toggleStatus + .5;\n\tfloat alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);\n\t// alpha *= ceil(height);\n\t// float alpha = clamp(ceil(height + heightRGB.g), 0., 1.) * (1. - toggleStatus);\n\tif(abs(uv.x-.5) \u003e .49){\n\t\talpha = 0.;\n\t}\n\n\tvec3 c = vec3(0.);\n\tif(alpha \u003e 0.){\n\t\t// Phong\n\t\tnormal = (normal - vec3(.5))*2.;\n\t\tvec3 lp = vec3(\n\t\t\t3. * (light.x / resolution.x - .5), \n\t\t\t// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\n\t\t\t3.*(1.-light.y / resolution.y - .5)*.25, \n\t\t\t1.\n\t\t);\n\t\tvec3 sp = vec3(uv - vec2(.5, .5), -1.)*vec3(1., .25, 1.);\n\t\tvec3 ep = vec3(.5, .5, 0.);\n\t\tc = hsv2rgb(.75, .85, pow(\n\t\t\tclamp(\n\t\t\t\tdot(\n\t\t\t\t\tnormalize(reflect(lp-sp, normal)), \n\t\t\t\t\tnormalize(sp)\n\t\t\t\t),\n\t\t\t\t0., 1.\n\t\t\t),\n\t\t\t1000.\n\t\t));\n\t}\n\n\n\tgl_FragColor = vec4(metal + buttons + c, alpha);\n}"])</script><script>self.__next_f.push([1,"17:Tbff,"])</script><script>self.__next_f.push([1,"\nprecision mediump float;\n\nuniform float TIME;\nuniform float swirl;\nuniform float border;\nuniform int depth;\nuniform vec2 resolution;\n\nvec2 rotateLoc(vec2 loc, float angle){\n\tfloat oAngle = atan(loc.y, loc.x);\n\tfloat nAngle = oAngle + angle / 180.0 * 3.1415926535;\n\tvec2 rotated = length(loc) * vec2(cos(nAngle), sin(nAngle));\n\treturn rotated;\t\n}\n\nfloat negOnePow(int power){\n\tif(int(mod(float(power), 2.)) == 0){\n\t\treturn 1.;\n\t}\n\treturn -1.;\n}\n\nint getColVal(vec2 loc, int level, float rotate){\n\tfloat levelVal = .5*pow(.25, float(level));\n\tfloat radVal = pow(.5, float(level));\n\t\n\tvec2 newLoc = rotateLoc(loc, rotate);\n\tvec2 modLocW = newLoc + vec2(0., levelVal);\n    vec2 modLocB = newLoc - vec2(0., levelVal);\n    // top circle\n    if(length(modLocB) \u003c levelVal){\n    \tif(level == depth){\n    \t\tif(length(modLocB) \u003c levelVal/3.){\n    \t\t\treturn 2;\n    \t\t}\n    \t}\n    \treturn 1;\n    }\n    // bottom circle\n    else if(length(modLocW) \u003c levelVal){\n    if(level == depth){\n    \t\tif(length(modLocW) \u003c levelVal/3.){\n    \t\t\treturn 1;\n    \t\t}\n    \t}\n    \treturn 2;\n    }\n    // left half\n    else if(length(loc) \u003c radVal \u0026\u0026 newLoc.x \u003e 0.){\n    \treturn 3;\n    }\n    // right half\n    else if(length(loc) \u003c radVal){\n    \treturn 4;\n    }\n}\n\nvec4 getYinYang(vec2 offset){\n    vec2 uv = (gl_FragCoord.xy + offset) / resolution;\n\n    vec4 color = vec4(0.0);\n    \n    vec2 loc = 2.*(uv - vec2(.5));\n    vec2 ogLoc = vec2(loc);\n    loc *= 1. + border;\n    int colVal = 0;\n    \n    // vec2 ogLoc = vec2(loc);\n   \n    \n    colVal = getColVal(loc, 0, TIME);\n    loc = rotateLoc(loc, TIME);\n   \n    \n    float multFac = .125;\n    float sumVal = 0.;\n    for(int i = 0; i \u003c 16; i++){\n        if (i \u003e= depth){break;}\n        if(colVal \u003e 0 \u0026\u0026 colVal \u003c 3){\n            sumVal /= 2.;\n            if(i \u003e 0){\n                sumVal += multFac*pow(.25, float(i-1));\n            }\n            loc = 0.5*(loc-loc.y/abs(loc.y)*vec2(0.,pow(.5, float(i+1)))  - negOnePow(colVal)*vec2(0.,sumVal));\n            colVal = getColVal(loc, i+1, pow(swirl, float(i+3))*TIME);\n            loc = rotateLoc(loc, pow(swirl, float(i+3))*TIME);\n        }\n    }\n    \n    \n    \n    \n    if(colVal == 1){\n        color = vec4(1.0); //white\n    }\n    else if(colVal == 2){\n        color = vec4(1., 0., 0., 1.); //red\n        color = vec4(0., 0., 0., 1.);\n    }\n    else if(colVal == 3){\n        color = vec4(0., 1., 0., 1.); //green\n        color = vec4(0., 0., 0., 1.);\n    }\n    else if(colVal == 4){\n        color = vec4(0., 0., 1., 1.); //blue\n        color = vec4(1.);\n    }\n    else {\n        color = vec4(0.);\n    }\n\n    if(length(ogLoc) \u003e= 1.){\n        color = vec4(0.);\n    }\n    else if(length(ogLoc) \u003e= 1./(1.+border)){\n        color = vec4(0., 0., 0., 1.);\n        color = vec4(1.);\n    }\n\n    return color;\n}\n\nvoid main()\n{\n    vec4 color = vec4(0.);\n\n    for(int i = 0; i \u003c 2; i++){\n        for(int j = 0; j \u003c 2; j++){\n            vec2 boi = vec2(float(i)-.5, float(j)-.5)/2.;\n            color += getYinYang(boi)/4.;\n        }\n    }\n\n    // color = getYinYang(vec2(0.));\n    \n    gl_FragColor = color;\n}\n"])</script><script>self.__next_f.push([1,"18:T2f42,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nstruct Ray{\n  vec3 p;\n  int obj;\n  float d;\n  vec4 col;\n  vec3 n;\n};\n\nstruct dObj{\n    float d;\n    int obj;\n};\n\nuniform float iTime;\nuniform vec3 lmh;\nuniform vec2 iResolution;\nuniform bool HD;\nuniform sampler2D HDRI;\nuniform sampler2D rand;\n\n// ANIMATION\nuniform float targetDist;\nuniform float warpy;\nuniform float twisty;\nuniform float rayHeight;\nuniform vec2 upDir;\nuniform float fisheye;\nuniform float hueShift;\nuniform float rayPos;\nuniform float playTime;\n\nconst float PI = 3.14159265359;\nconst float epsilon = 0.01;\n\nvec3 rayOrigin;\n\nfloat cellWidth = 10.;\n\nvec2 uCir(float theta){\n    return vec2(cos(theta), sin(theta));\n}\n\nfloat sigmoid(float x){\n    return 1./(1. + exp(-x));\n}\n\nvec2 revSpherical(vec3 xyz){\n    float phi = acos(xyz.z/length(xyz));\n    float theta = atan(xyz.y, xyz.x);\n    return vec2(theta/(2.*PI) + .5, phi/PI);\n}\n\n// float rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb){\n  p.x = abs(p.x);\n  float k = (sc.y*p.x\u003esc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash31( vec3 p ){\n    return fract(sin(dot(p ,vec3(12.9898,78.233,91.495))) * 43758.5453);\n}\n\nmat3 rotate( in vec3 v, in float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n        (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n        (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n    );\n}\n\nvec3 rotateOffset(in vec3 pos, in vec3 v, in float angle, in vec3 offset){\n    return (pos - offset) * rotate(v, angle) + offset;\n}\n\nvec3 hsv(float cX, float cY, float cZ){\n    cX -= float(int(cX));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);\n    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);\n}\n\nfloat hash( float n ){\n    return fract(sin(n)*758.5453);\n}\n\nconst vec2 zOffset = vec2(37.0,17.0);\nconst vec2 wOffset = vec2(59.0,83.0);\n\nvec4 texNoise(vec2 uv)   // Emulate a single texture fetch into the precalculated texture\n{\n    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.\n    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.\n    float r = texture2D( rand, mod((uv+0.5)/256.0, 1.)).r;\n    float g = texture2D( rand, mod((uv+0.5 + zOffset)/256.0, 1.)).r;\n    float b = texture2D( rand, mod((uv+0.5 + wOffset)/256.0, 1.)).r;\n    float a = texture2D( rand, mod((uv+0.5 + zOffset + wOffset)/256.0, 1.)).r;\n    \n    return vec4(r, g, b, a);\n}\n\n\nfloat noise4dFast( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;\n    \n    vec4 s = texNoise(uv);\n    return mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);\n}\n\n// float sdGyroid(vec4 p) {\n//     return (dot(sin(p.xyzw), cos(p.wyzx)) - sin(offset)) * .5;\n// }\n\nfloat sdGyroid(vec4 p) {\n    return clamp(dot(sin(p.xyzw), cos(p.yzxw)) * .5, -1., 1.);\n}\n\nfloat sdGyroid(vec3 p, float offset) {\n    return sdGyroid(vec4(p, offset));\n}\n\nfloat sdGyroid(vec3 p) {\n    return sdGyroid(p, 0.0);\n}\n\nmat3 lookat( in vec3 fw, in vec3 up ){\n    fw = normalize(fw);\n    vec3 rt = normalize( cross(fw, normalize(up)) );\n    return mat3( rt, cross(rt, fw), fw );\n}\n\nvec3 transformPos(vec3 pos){\n    vec3 rotPos = vec3(pos);\n    // if(HD){\n    vec2 xy = vec2(1.,0.);\n    rotPos -= rayOrigin;\n    rotPos *= rotate(xy.xyy, twisty*(rotPos.y*0. + rotPos.x*.2) / cellWidth );\n    rotPos *= rotate(xy.yxx, warpy*2.*.1*(rotPos.y + rotPos.z) / cellWidth) ;\n    rotPos += rayOrigin;\n// }\n    return rotPos;\n}\n\ndObj mapDist(vec3 pos){\n    const vec2 SC = vec2(sin(PI/4.), cos(PI/4.));\n    const mat2 ROT = mat2(cos(PI/4.), sin(PI/4.), -sin(PI/4.), cos(PI/4.));\n    const mat2 ROT2 = mat2(cos(PI/2.), sin(PI/2.), -sin(PI/2.), cos(PI/2.));\n    const mat2 nROT = mat2(cos(PI/4.), -sin(PI/4.), sin(PI/4.), cos(PI/4.));\n\n    vec3 rotPos = transformPos(pos);\n\n    float posNoiseAmt = -.3*pow(sdGyroid(rotPos * 1.5, playTime*.06), 4.) * (sin(playTime/16.) + 1.1) ;\n    // posNoiseAmt -= .2*pow(sdGyroid(rotPos * 10.*exp(sin(rotPos.x/100.)), playTime*.06), 4.);\n    // posNoiseAmt += .015*pow(sdGyroid(.5*rotPos * exp(1.+sdGyroid(rotPos*.6)), playTime*.09), 1.);\n    \n     float n2G = sin(sdGyroid(rotPos/11.)/7.);\n    float n3G = cos(sdGyroid(rotPos/14.)/11.);\n    posNoiseAmt -= .03*pow(sdGyroid(rotPos * 7.*(1. + 1.*n2G), playTime*.086), 1.) ;\n    \n    \n    // if(HD){\n        // posNoiseAmt += -.2*pow(sdGyroid(rotPos * 3., playTime*.16), 6.) * (cos(playTime/17.) + 1.1) ;\n        // posNoiseAmt += -.2*pow( sdGyroid((sdGyroid(rotPos*3.)*.1 + rotPos) * 1., playTime*.1), 6.) ;\n    // }\n    vec3 noisePos = rotPos + posNoiseAmt;\n\n    float noisey =0.;\n        // (pow(sdGyroid(noisePos/8., .2*playTime * 1.), 3.) - .0) / 2.;// + \n        \n    if(HD){\n       \n\n        posNoiseAmt -= .4*pow(sdGyroid(rotPos * .5, playTime*.086), 1.) *sin(playTime/3.);\n       // posNoiseAmt += (sdGyroid(sdGyroid(noisePos*2.*(1.+sin(noisePos.x/43.))) * noisePos/5., 0.*playTime/4.) - .25)/50.;\n        posNoiseAmt += .001*pow(sdGyroid(rotPos * 60.*(1.5 + 1.*n3G), playTime*.086), 1.) ;\n    //     // noisey += -.2*pow( sdGyroid((sdGyroid(rotPos)*.2 + rotPos) * 40., playTime*.16), 6.) * (cos(playTime/4.) + 1.1) * .0 ;\n    //     // noisey += .2*pow(clamp(abs(sdGyroid(sdGyroid(noisePos*.1*(1.+sin(noisePos.x/34.)))*noisePos*10.) - .25)/200., 0., 1.), .8);\n    }\n\n    posNoiseAmt += .1;\n\n    // noisey *= .0;\n    // noisey -= 1.;\n\n    vec3 basis = vec3(1., 0., 0.);\n\n    // float cellWidth = 10.;\n    float ra = cellWidth * .5;\n    float rb = .5;\n\n    vec3 p = cellWidth * (mod(rotPos / cellWidth + .5, 1.) - .5);\n    // vec3 p = vec3(pos);\n\n    float randRot =  floor(3. * \n        hash31(floor(rotPos / cellWidth + .5))\n    );\n    if(randRot \u003c 1.){\n        basis = basis.yxy;\n    }\n    else if(randRot \u003c 2.){\n        basis = basis.yyx;\n    }\n    // mat3 pRot = rotate(basis, PI/2. * (randRot + 4.*clamp(mod(iTime/3., 8.)-4., 0., 1.)));\n    mat3 pRot = rotate(basis, PI/2. * randRot);\n    p *= pRot;\n    // p = pos;\n    vec3 q;\n    q = p;\n    q.xy += vec2(-.5,.5) * cellWidth;\n    q.xy *= ROT;\n    // q = rotateOffset(q, basis, iTime, vec3(-.5,.5, 0.) * cellWidth);\n    float A = sdCappedTorus( q, SC, ra, rb );\n\n    q = p.xzy;\n    q.xy += vec2(.5,.5) * cellWidth;\n    q.xy *= nROT;\n    float B = sdCappedTorus( q, SC, ra, rb );\n    \n    q = vec3(p.y, -p.z, p.x);\n    q.xy += vec2(-.5,.5) * cellWidth;\n    q.xy *= ROT;\n    float C = sdCappedTorus( q, SC, ra, rb );\n\n    // float B = 100.;\n    // float C = 100.;\n\n    float d = abs(min(A, min(B, C)) + noisey + posNoiseAmt);\n    int obj = -1;\n\n    // d /= (1. + 10.*abs(posNoiseAmt));\n    if(HD){\n        d *= .5;\n    }\n    // if(noisey + posNoiseAmt \u003e .1){\n    //     d *= .5;\n    // }\n    else{\n        d *= .75;\n    }\n\n    // float D = sdCappedTorus( p , SC, ra, rb );\n\n    // float d = min(D, 99999.);\n\n    if(d \u003c epsilon){\n        obj = 1;\n    }\n\n    return dObj(d, obj);\n}\n\nvoid normal( inout Ray ray ){\n vec3 eps = vec3(0.01, 0.0, 0.0);\n vec3 p = ray.p;\n ray.n = normalize( vec3(\n     mapDist(p+eps.xyy).d-mapDist(p-eps.xyy).d,\n     mapDist(p+eps.yxy).d-mapDist(p-eps.yxy).d,\n     mapDist(p+eps.yyx).d-mapDist(p-eps.yyx).d\n ) );\n // ray.n = vec3(1., 0., 0.);\n}\n\nvoid map(inout Ray ray, vec3 ro, vec3 rd){\n    dObj disty = mapDist(ray.p);\n    ray.d = disty.d;\n    ray.obj = disty.obj;\n}\n\nRay raymarch( in vec3 ro, in vec3 rd){\n    const int maxSteps = 80;\n    float maxDist = 500.;\n    Ray ray = Ray(\n        ro, \n        -1,\n        100000.,\n        vec4(0.),\n        vec3(0., 1., 0.)\n    );\n    float t = 0.;\n    vec3 roN = vec3(ro);\n    vec3 rdN = vec3(rd);\n    for(int i=0; i\u003cmaxSteps; i++){\n        if(HD || mod(float(i), 2.) == 0.){\n            map(ray, roN, rdN);\n            t += ray.d;\n            ray.p += rdN * ray.d;  \n            if( ray.d \u003c epsilon || t \u003e maxDist){\n                break;\n            }\n        }\n    }\n\n    if(ray.obj \u003e 0){\n        normal(ray);\n    }\n\n    return ray;\n}\n\nvoid shade(inout Ray ray, in vec3 rd, in vec3 ro){\n    vec3 reflected=reflect(rd,ray.n);\n    vec4 hdri = texture2D(HDRI, revSpherical(reflected));\n    // vec3 env=vec3(texture2D(HDRI,reflected*reflected*reflected).x);\n\n    vec2 sph = revSpherical(ray.p - vec3(rayPos, 0, 0));\n\n    // vec3 ldir1 = 3. * vec3(sin(iTime/3.), 1., cos(iTime/3.));\n    float fog = clamp(1.-sigmoid(length(ray.p-ro)/1.4 - 30. - 50. * pow(lmh[1], 4.)), 0., 1.);\n    vec4 fogColor = vec4(hsv(\n        .3 + hueShift + sin(sph.y*.2) + 1., \n        .45 - .35*cos(playTime*2. * PI / 84.), \n        .5 + lmh[2] - .05*(cos(playTime*2. * PI / 128.) + 1.) / 2.\n    ), 1.);\n\n    vec2 uv = gl_FragCoord.xy/iResolution.xy; \n    fogColor.rgb *= clamp(2.5-4.*length(uv-vec2(.5)), 0., 1.);\n\n    float hue = abs(dot(normalize(rd), normalize(ray.n)));\n    vec4 thinFilm = vec4(hsv(hue/2. + hueShift, .9, hdri.r), 1.);\n    \n    if(ray.obj == 1){\n        vec3 rotPos = transformPos(ray.p);\n        float spots = \n        clamp(\n            pow(\n                abs(sdGyroid(\n                    rotPos*9.*\n                    (1. + .3*sin(rotPos.x/cellWidth/8.2))*.5*\n                    // sigmoid(length(rotPos.yz - vec2(cellWidth/2.)))*\n                    (1. + .1*sin(rotPos.x/cellWidth/9.2) ) * .5 *\n                    (1. + .1*sin(playTime*.012)+.5)\n                ) + .7*(.5+.2*cos(rotPos.x/cellWidth/5.2)))* \n                (1.5 + .4*sin(rotPos.x/cellWidth/10.2))\n            , 200. )\n        , 0., 1. );\n\n        // spots *= 0.;\n        spots *= pow(2.-sigmoid(length(rotPos.yz-rayOrigin.yz)/50.)*2., 4.);\n        spots += .2;\n\n        // spots += 1. - \n        // clamp(\n        //     pow(\n        //         abs(sdGyroid(\n        //             ray.p*2.*\n        //             sigmoid(length(ray.p.yz - vec2(cellWidth/2.)))*\n        //             (1. + sin(ray.p.x/200.) ) * .5 *\n        //             (1. + .1*sin(playTime*.003)+.5)\n        //         ) - .2)*10.\n        //     , 120. )\n        // , 0., 1. );\n        ray.col = \n            15. * mix(thinFilm, hdri, hue) * pow(lmh[0], 6.) * fog * (1. - spots) + \n            fogColor * (1. - fog) +\n            vec4(hsv(ray.p.x / 180., clamp(abs(20. - ray.p.x)/20., 0., 1.)*.0*(1.-pow(lmh[0], 2.)),\n                spots * pow(fog, .2) * .9 * (1.-pow(lmh[0], 4.)) \n            ), 1.);\n        // ray.col = vec4(1.);\n    }\n    else{\n        ray.col = fogColor;\n    }\n}\n\nvec4 render(vec2 q){\n    vec2 v = -1.0 + 2.0*q;\n    v.x *= iResolution.x/iResolution.y;\n\n    //Camera Settings\n    // float fisheye = 6. * (sin(iTime / 5. + PI)) / 2.;\n    // fisheye = .3;\n    float lens = 1.9 + fisheye * length(v);\n\n    //camera ray\n    float camDist = 100.;\n    float camFreq = 9999999.;\n    // vec3 rayOrigin = camDist * vec3(1., 0., 0.);// * vec3(sin(iTime/15.), 0., cos(iTime/15.));\n    // rayOrigin = vec3(iTime*3., cellWidth/2., cellWidth/2.);\n    rayOrigin = vec3(\n        rayPos, \n        cellWidth/2. + rayHeight * cellWidth, \n        cellWidth/2.\n    );\n    \n    vec3 rayDir = normalize( vec3(v.x, v.y, lens) );\n    vec3 target = vec3(0., cellWidth/2., cellWidth/2.);\n    target = vec3(rayPos + targetDist, cellWidth/2., cellWidth/2.);\n    // target = vec3(iTime*3. + 3., cellWidth/2. + sin(iTime * PI / 3.), cellWidth/2.);\n    rayDir = lookat( target-rayOrigin, vec3(0.,upDir))*rayDir;\n    \n    //classic raymarching by distance field\n    Ray ray = raymarch(rayOrigin, rayDir);\n    shade(ray, rayDir, rayOrigin);\n    return ray.col;\n}\n\nvoid main(){\n    vec2 p = gl_FragCoord.xy/iResolution.xy; \n    vec4 col = render(p);\n\n    // col = texture2D(HDRI, p);\n\n    // col.rgb *= clamp(2.5-4.*length(p-vec2(.5)), 0., 1.);\n        \n    gl_FragColor = col;\n}"])</script><script>self.__next_f.push([1,"19:T3b9e,"])</script><script>self.__next_f.push([1,"precision highp float;\n\n#define AA 1  //change to 1 to increase performance\n\n#define _Speed .4  //disk rotation speed\n\n#define _Steps  4. //disk texture2D layers\n// #define bhSize 0.3 //size of BH\n\nuniform vec2 resolution;\nuniform sampler2D sphereMap;\nuniform sampler2D pebbles;\nuniform float TIME;\nuniform float bhTIME;\nuniform float MOUSEX;\nuniform float MOUSEY;\nuniform float bhRad;\nuniform float bhDist;\nuniform float bhX;\nuniform float bhSeparation;\nuniform vec3 iAudio;\nuniform float hueShift;\nuniform float camDist;\nuniform float starBright;\nuniform bool HD;\n\n// const vec2 MOUSE = vec2(.5, 60.);\n\nconst int MAX_MARCHING_STEPS = 15;\nconst int diskSteps = 10;\nconst int exitSteps = 6;\n\nconst float discThickness = .001;\n\nconst float MIN_DIST = 100.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897;\n\nconst float starSize = .05;\nconst int numStars = 6;\nvec3 starPos[6];\nfloat starSizes[6];\nvec3 ogPos;\n\nfloat bhSize;\n\nfloat sigmoid(float x){\n    return 1./(1. + exp(-x));\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float r, float g, float b) {\n  return hsv2rgb(vec3(r, g, b));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nvec3 blendNormal(vec3 normal){\n    vec3 blending = abs(normal);\n    blending = normalize(max(blending, 0.00001));\n    blending /= vec3(blending.x + blending.y + blending.z);\n    return blending;\n}\n\nvec3 triplanarMapping (sampler2D texture, vec3 normal, vec3 position) {\n  vec3 normalBlend = blendNormal(normal);\n    vec3 xColor = texture2D(texture, position.yz).rgb;\n    vec3 yColor = texture2D(texture, position.xz).rgb;\n    vec3 zColor = texture2D(texture, position.xy).rgb;\n\n  return (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);\n}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat grid(vec3 p)\n{\n    float s = sin(p.x)*cos(p.y);\n    //float s = sin(p.x)*cos(p.y);\n    return s;\n}\n\nfloat flow(vec4 pppp)\n{\n    vec3 p = pppp.xyz;\n    float z=2.;\n    float rz = 0.;\n    vec3 bp = p;\n    float ttt = pppp.w;\n    \n\n    for (float i= 1.;i \u003c 5.;i++ )\n    {\n        //movement\n        p += ttt*.6;\n        bp -= ttt*.3;\n        \n        //displacement map\n        vec3 gr = vec3(grid(p*3.-ttt*1.),grid(p*3.5+4.-ttt*1.),grid(p*4.+4.-ttt*1.));\n        p += gr*0.15;\n        rz+= (sin(noise(p)*8.)*0.5+0.5) /z;\n        \n        //advection factor (.1 = billowing, .9 high advection)\n        p = mix(bp,p,.7);\n        \n        //scale and rotate\n        z *= 2.;\n        p *= 2.01;\n        p*=m3;\n        bp *= 1.7;\n        bp*=m3;\n    }\n    return rz;  \n}\n\nvec2 unitCircle(float angle){\n    return vec2(cos(angle), sin(angle));\n}\n\nvec4 background(vec3 ray, vec2 ogUV)\n{\n    vec2 uv = ray.xy;\n    \n    // if( abs(ray.x) \u003e 0.5)\n    //     uv.x = ray.z;\n    // else if( abs(ray.y) \u003e 0.5)\n    //     uv.y = ray.z;\n\n    float dist = length(ogUV-vec2(.5));\n    // dist = .004;\n    dist -= .25;\n    dist = .001/(1.+dist*dist);\n\n    float scaling = 1.;\n    vec4 nebulaeR = texture2D(sphereMap, mod(uv, vec2(scaling, scaling) )/scaling);\n    vec4 nebulaeG = texture2D(sphereMap, mod(uv*(1.+dist), vec2(scaling, scaling) )/scaling);\n    vec4 nebulaeB = texture2D(sphereMap, mod(uv*(1.-dist), vec2(scaling, scaling) )/scaling);\n    // nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color\n    vec4 nebulae = vec4(nebulaeR.r, nebulaeG.g, nebulaeB.b, nebulaeR.a);\n    vec3 nebulaeHSV = rgb2hsv(nebulae.xyz) + vec3(.35, -.1, .0);\n// return nebulaeR;\n\treturn vec4(starBright * hsv2rgb(nebulaeHSV), 1.);\n}\n\nvec4 raymarchDisk(vec3 ray, vec3 zeroPos)\n{\n    //return vec4(1.,1.,1.,0.); //no disk\n\n    float stepsHD = _Steps;\n    // if(!HD){\n    //     stepsHD = _Steps/3.;\n    // }\n    \n\tvec3 position = zeroPos;      \n    float lengthPos = length(position.xz);\n    float dist = 0.1 * min(1., .5*lengthPos) * 1. / (stepsHD * abs(ray.y) );\n\n    position += dist * stepsHD * ray * 0.5;     \n\n    vec2 deltaPos;\n    deltaPos.x = -0.01 * zeroPos.z + zeroPos.x;\n    deltaPos.y = 0.01 * zeroPos.x + zeroPos.z;\n    deltaPos = normalize(deltaPos - zeroPos.xz);\n    \n    float parallel = dot(ray.xz, deltaPos);\n    parallel /= 2. * sqrt(lengthPos);\n    float redShift = parallel + 0.3;\n    redShift = clamp(redShift, 0., 1.);\n\n    float hueShift = -.3;\n    \n    float disMix = clamp(0.24 * (lengthPos - bhSize * 2.) / bhSize, 0., 1.);\n    vec3 insideCol =  mix(hsv2rgb(.5+hueShift, .9, 1.), hsv2rgb(.9+hueShift, .9, 1.)*.5, pow(disMix, .5));\n    \n    insideCol *= mix(hsv2rgb(.45+hueShift, .9, 1.), hsv2rgb(.2+hueShift, .9, 1.), redShift);\n\tinsideCol *= 1.25;\n    redShift += 0.18;\n    redShift *= redShift;\n\n    float theta = (atan(position.z, position.x) + PI) / (2. * PI);\n    float phi = mod((atan(position.z, position.x) + 2. * PI) / (2. * PI), 1.);    \n\n    vec4 oCol = vec4(0.);\n\n    \n\n    for(float i = 0. ; i \u003c _Steps; i++)\n    {      \n        if(!HD \u0026\u0026 i \u003e stepsHD){\n            break;\n        }                \n        position -= dist * ray ;  \n\n        float intensity = clamp( 1. - abs( 2. * (i - 0.8) / stepsHD ), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 2.;\n\n        // diameter of disc\n        vec2 discSize = vec2(.75, .1);\n        distMult *=  clamp(2. * (lengthPos -  bhSize * discSize.x) * discSize.x / bhSize, 0., 1.);        \n        distMult *= clamp(( 3. - lengthPos) * 3.0, 0., 1.);\n        distMult *= distMult;\n\n        // float rrr = lengthP\n  \n        const float f = 70.;\n        // float noise = .5 * flow( 50. * vec3( angle * lengthPos, 0.03 * u , 2. * f));\n        // noise += .5 * flow( 50. * vec3( angle * lengthPos, 0.03 * u, 4. * f));     \n        float noise1 = .5 * flow( vec4( lengthPos * 3., theta * 20.  + 100. / (lengthPos + 3.) , 2. * f, bhTIME   + iAudio[2]));\n        float noise2 = .5 * flow( vec4( lengthPos * 3., phi * 20.  + 100. / (lengthPos + 3.) , 4. * f, bhTIME  + iAudio[2]));\n        float noise = noise1 * abs(1. - 2. * phi) + noise2 * abs(1. - 2. * theta);\n        // noise += .5 * flow( 50. * vec3( position.xz / 4., 4. * f)); \n\n        float extraWidth =  noise * (1. -  clamp(2. * i / stepsHD - 1., 0., 1.));\n\n        float alpha = 10. * noise * (intensity + extraWidth) * ( 4. + 0.01 ) *  dist * distMult;\n        // alpha -= (lengthPos * .5) / bhSize;\n        float bhAmix = 1.-pow(bhSize * 2., 1.);\n        alpha = mix(alpha, (1.-lengthPos * 2.) * alpha * bhAmix, bhAmix);\n        alpha = clamp( alpha , 0., 1.);\n\n\n        vec3 col = 2. * mix( hsv2rgb(0.+hueShift, .9, 1.) * insideCol, insideCol, min(1.,intensity*2.));\n        oCol = (1.-alpha) * oCol + alpha * vec4(col, 1.);\n        oCol.rgb += 1. * redShift * (intensity + 0.5) * distMult * bhSize * bhSize /(stepsHD*lengthPos*lengthPos);\n    }  \n \n    oCol.rgb = clamp(oCol.rgb , 0., 1.);\n    return oCol ;\n}\n\nvec3 getStarPos(int id) {\n    for (int i=0; i\u003cnumStars; i++) {\n        if (i == id) return starPos[i];\n    }\n}\n\nfloat getStarSize(int id) {\n    for (int i=0; i\u003cnumStars; i++) {\n        if (i == id) return starSizes[i];\n    }\n}\n\nfloat starDist(vec3 pos, int i){\n    return length(pos - getStarPos(i)) - getStarSize(i);\n}\n\nvec3 starNormal( vec3 pos, int i){\n vec3 eps = vec3(0.001, 0.0, 0.0);\n vec3 p = vec3(pos);\n vec3 n = normalize( vec3(\n     starDist(p+eps.xyy, i)-starDist(p-eps.xyy, i),\n     starDist(p+eps.yxy, i)-starDist(p-eps.yxy, i),\n     starDist(p+eps.yyx, i)-starDist(p-eps.yyx, i)\n ) );\n return n;\n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid applyBendForce(inout vec3 pos, inout vec3 ray, vec3 bhPos, float bhRadd){\n    float dotpos = dot(pos-bhPos, pos-bhPos);\n    float invDist = inversesqrt(dotpos); // 1/distance to BH\n    float centDist = dotpos * invDist;  // distance to BH\n    float stepDist = 0.92 * abs(pos.y /(ray.y));  // conservative distance to disk (y==0)\n\n    float starMin = 9999.;\n    for(int i = 0; i \u003c numStars; i ++){\n        if(!HD \u0026\u0026 i \u003e= numStars / 2){\n            continue;\n        }\n        float starDist = length(pos - starPos[i]) - getStarSize(i);\n        if( starDist \u003c starMin){\n            starMin = starDist;\n        }\n    }\n\n    if(!HD){\n        starMin *= .5;\n    }\n    // else{\n    //     starMin *= .25;\n    // }\n    \n\n    float farLimit = centDist * 0.5; // limit step size far from to BH\n    float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./bhRadd); //limit step size closse to BH\n    stepDist = min(min(stepDist, min(farLimit, closeLimit)), starMin);\n\n    // stepDist = starMin;\n    \n    float invDistSqr = invDist * invDist;\n    float bendForce = stepDist * invDistSqr * bhRadd * 0.625;  //bending force\n    ray = normalize(ray - (bendForce * invDist )*pos);\n    pos += stepDist * normalize(ray); \n}\n\nvoid renderStars(in vec3 pos, inout vec4 col, inout bool hitStar){\n    for(int i = 0; i \u003c numStars; i ++){\n        if(!HD \u0026\u0026 i \u003e= numStars / 2){\n            break;\n        }\n        vec3 pDif = pos - starPos[i];\n        float sDist = length(pDif);\n        float sFrac = float(i) / float(numStars);\n        if(sDist \u003c getStarSize(i) + .01){\n            vec3 sNorm = normalize(starNormal(pos, i) * .5+ .5);\n            float psDist = length(ogPos - starPos[i]);\n            // Rotate(sNorm, vec2(TIME*.8, TIME*1.));\n            Rotate(pDif, vec2(TIME*.8, TIME*1.));\n            sNorm = pow(sNorm, vec3(1.));\n            float distPow = (1. - sigmoid((psDist - length(ogPos)) * 2.));\n            float sunSpot = 1. * pow(triplanarMapping(pebbles, sNorm, 2. * (rand(sFrac*30.) + .5) * pDif + sFrac).r, 1.);\n            // distPow = 1.;\n            vec3 pebCol = hsv2rgb(\n                3.5 * sunSpot * (sFrac + .2) + .08*TIME * (1. + 3.*rand(sFrac)), \n                1. - sunSpot, \n                sunSpot * distPow\n            );\n            // pebCol *= distPow;\n            col = vec4(\n                  col.a * col.rgb + (1. - col.a) * pebCol,// / pow(max(length(ogPos - pos), 1.), 6.), \n                1.\n            );\n            hitStar = true;\n            break;\n        }\n        if(hitStar)\n        break;\n    }\n}\n\nvoid main()\n{\n\n    vec3 viewDir = rayDirection(45.0, resolution, gl_FragCoord.xy);\n    vec3 pos = vec3(camDist*cos((MOUSEY - .5)*PI), camDist * sin((MOUSEY - .5)*PI), 5.);\n    \n    mat3 viewToWorld = viewMatrix(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, cos((MOUSEX - .5)*PI), sin((MOUSEX - .5)*PI)));\n    \n    vec3 ray = viewToWorld * viewDir;\n\n    vec2 angle = vec2( TIME * 0.05 + .9, 0.3 );      \n    Rotate(pos, angle);\n    Rotate(ray, angle);\n\n    ogPos = vec3(pos);\n\n    vec3 bhLoc1 = bhDist*vec3(0., bhSeparation, 0.);\n    vec3 bhLoc2 = -bhLoc1;\n    vec3 bhOffset = vec3(0., bhX, 0.);\n    bhLoc1 +=  bhOffset;\n    bhLoc2 -=  bhOffset;\n\n    bhSize = bhRad + bhRad * iAudio[0] * .1 + .01;\n\n    for(int i = 0; i \u003c numStars; i ++){\n        float sFrac = float(i) / float(numStars);\n        // if(!HD \u0026\u0026 i \u003e= numStars / 2){\n        //     continue;\n        // }\n        float theta = PI * sFrac;\n        float phi = TIME * .2;\n        // phi *= 3.;\n        phi *= rand(float(i + 1)) + 1.;\n        phi += 2.*PI * rand(float(i + 999));\n        float randR = (2. + rand(float(i * 100)) );\n        // randR = 1.;\n        starPos[i] = randR * vec3( \n            sin(phi)*cos(theta), \n            cos(phi),\n            sin(phi)*sin(theta)\n        );\n        starSizes[i] = starSize * (1. + 3.*rand(sFrac));\n    }\n\n\n    vec4 col = vec4(0.); \n    vec4 outCol =vec4(100.);\n\n    for(int disks = 0; disks \u003c diskSteps; disks++) //steps\n    {\n        // if(!HD \u0026\u0026 disks \u003e diskSteps / 2){\n        //     continue;\n        // }     \n        bool hitStar = false;\n        for (int h = 0; h \u003c exitSteps; h++) // reduces tests for exit conditions (to minimise branching)\n        {\n            // if(!HD \u0026\u0026 h \u003e exitSteps / 2){\n            //     continue;\n            // }\n            applyBendForce(pos, ray, bhLoc1, bhSize);\n            renderStars(pos, col, hitStar);\n            if(hitStar)\n                break;\n            applyBendForce(pos, ray, bhLoc2, bhSize);\n            // renderStars(pos, col, hitStar);\n            if(hitStar)\n                break;\n        }\n        if(hitStar)\n                break;\n\n        float dist21 = length(pos - bhLoc1);\n        float dist22 = length(pos - bhLoc2);\n\n        if(dist21 \u003c bhSize * 0.1 || dist22 \u003c bhSize * 0.1 ) //ray sucked in to BH\n        {\n            outCol =  vec4( col.rgb * col.a ,1.) ;\n            // outCol = vec4(vec3(0.), 1.);\n            break;\n        }\n\n        else if(dist21 \u003e bhSize * 10000. \u0026\u0026 dist22 \u003e bhSize * 10000.) //ray escaped BH\n        {                   \n            vec4 bg = background(ray, gl_FragColor.xy/resolution);\n            outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a) , 1.);       \n            break;\n        }\n\n        else if (abs(pos.y) \u003c= bhSize * discThickness ) //ray hit accretion disk\n        {                             \n            vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n            vec3 hDiskCol = hsv2rgb(rgb2hsv(diskCol.rgb) + vec3(hueShift, 0., 0.));\n            diskCol.rgb = hDiskCol;\n            pos.y = 0.;\n            pos += abs(bhSize * discThickness / (2. * ray.y) ) * ray;  \n            col = vec4(diskCol.rgb * (1.-col.a) + col.rgb, col.a + diskCol.a * (1.-col.a));\n            // break;\n        }\n    }\n\n    //if the ray never escaped or got sucked in\n    if(outCol.r == 100.)\n        outCol = vec4(col.rgb, 1.);\n\n    col = outCol;\n    // col.rgb =  pow( col.rgb, vec3(0.6) );\n    \n    gl_FragColor += col;\n}\n"])</script><script>self.__next_f.push([1,"1a:T583,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nuniform float iTime;\n\nconst float PI = 3.1415926535897;\n\nvec3 sphericalToCartesian( float rho, float phi, float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nint state(vec2 uv){\n\tif(uv.x \u003e 1.){\n\t\tuv.x -= 1.;\n\t}\n\tif(uv.x \u003c 0.){\n\t\tuv.x += 1.;\n\t}\n\tif(uv.y \u003e 1.){\n\t\tuv.y -= 1.;\n\t}\n\tif(uv.y \u003c 0.){\n\t\tuv.y += 1.;\n\t}\n\treturn texture2D(u_texture, uv).r \u003e .5 ? 1 : 0;\n}\n\nint sphericalState(vec2 uv){\n\tvec2 offset = uv * vec2(2.*PI, PI);\n\tvec3 sphereMap = sphericalToCartesian(1., offset.x, offset.y);\n\treturn state(sphereMap.xy);\n}\n\nvoid main() {\n\t\tvec2 UV = gl_FragCoord.xy / resolution;\n\n\t\tint curState = state(UV);\n\n\t\tint sum = 0;\n\n\t\tfor(int i = -1; i \u003c= 1; i ++){\n\t\t\tfor(int j = -1; j \u003c= 1; j ++){\n\t\t\t\tif( !(i == 0 \u0026\u0026 j == 0)){\n\t\t\t\t\tvec2 offset = UV + vec2(i, j) /  resolution;\n\t\t\t\t\tsum += state(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfloat newState1 = \n\t\t\t(curState == 0 \u0026\u0026 sum == 3) || \n\t\t\t(curState == 1 \u0026\u0026 (sum == 3 || sum == 2)) ? 1. : 0.;\n\t\tfloat newState2 = \n\t\t\t(curState == 0 \u0026\u0026 sum == 2) || \n\t\t\t(curState == 1 \u0026\u0026 (sum \u003c= 4 || sum \u003e= 2)) ? 1. : 0.;\n\n\t\tfloat newState = iTime \u003e 10. \u0026\u0026 iTime \u003c 10.3 ? newState2 : newState1;\n\t\t\n\t\tgl_FragColor = vec4(vec3(newState1), 1);\n\t\t// gl_FragColor = vec4(curState, curState, curState, 1);\n\t\t// gl_FragColor = vec4(.5, .1, 0, 1);\n\n}"])</script><script>self.__next_f.push([1,"1b:T1ea3,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nstruct Ray{\n  vec3 p;\n  int obj;\n  float d;\n  vec4 col;\n  vec3 n;\n};\n\nstruct dObj{\n\tfloat d;\n\tint obj;\n};\n\nconst float PI = 3.14159265359;\n\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iWavelet;\nuniform vec3 lmh;\nuniform vec2 iResolution;\nuniform bool HD;\n\nuniform float fisheye;\nuniform float camDist;\nuniform vec2 rayOriginC;\nuniform vec2 rayUp;\nuniform vec2 rayOriginOffset;\nuniform float hueShift;\nuniform float skyHeight;\nuniform float uvDisp;\nuniform float camKal;\nuniform float camSin;\nuniform float renderDist;\nuniform float ballX;\nuniform float ballY;\nuniform vec2 moonXY;\nuniform float moonLight;\n\nvec3 cen1;// = vec3(0., -skyHeight/2. * sin(iTime*2.), 0.);\n// vec3 cen1 = -vec3(0., skyHeight/2., 0.);\nfloat rad1;// = skyHeight/2.;\nvec3 cen2;//= cen1 + skyHeight * vec3(sin(iTime*2.), 0., cos(iTime*2.));\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n\nvec3 hsv(float cX, float cY, float cZ){\n    cX -= float(int(cX));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);\n    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);\n}\n\n//iq 3d noise\nfloat noise(vec3 x){\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat fbm(vec3 x){\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i\u003c5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nmat3 lookat( in vec3 fw, in vec3 up ){\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nfloat thetaMap(float theta, float split){\n\tfloat thetaMod = mod(theta, 2. * PI);\n\tfloat splitMod = mod(split, 2. * PI);\n\tif(thetaMod \u003e splitMod){\n\t\tthetaMod -= 2. * PI;\n\t}\n\treturn thetaMod;\n}\n\nvec4 raySphere(vec3 start, vec3 end, vec3 cen, float r){\n\tfloat a = pow(end.x - start.x, 2.) + pow(end.y - start.y, 2.) + pow(end.z - start.z, 2.);\n\tfloat b = -2. * ( (end.x-start.x)*(cen.x-start.x) + (end.y-start.y)*(cen.y-start.y) + (end.z-start.z)*(cen.z-start.z) );\n\tfloat c = pow(cen.x - start.x, 2.) + pow(cen.y - start.y, 2.) + pow(cen.z - start.z, 2.) - pow(r, 2.);\n\tfloat d = pow(b, 2.) - 4. * a * c;\n\tif(d \u003e 0.){\n\t\tfloat t1 = (-b - sqrt(d)) / (2. * a);\n\t\tfloat t2 = (-b + sqrt(d)) / (2. * a);\n\t\tfloat t = t1 \u003e -.01 ? t1 : t2;\n\t\tt = t1;\n\t\tif(t \u003e -.01){\n\t\t\treturn vec4(1., \n\t\t\t\tstart.x + (start.x - end.x) * t,\n\t\t\t\tstart.y + (start.y - end.y) * t,\n\t\t\t\tstart.z + (start.z - end.z) * t\n\t\t\t);\n\t\t}\n\t}\n\treturn vec4(-1.);\n}\n\ndObj mapDistAurora(vec3 pos, vec3 ro, vec3 rd){\n\tfloat ep = .0000001;\n\tfloat d = (skyHeight - pos.y + ep) / (rd.y + ep);//+ .01);\n\tint obj = -1;\n\n\tvec4 intSphere1 = raySphere(pos, rd + pos, cen1, rad1);\n\tvec4 intSphere2 = raySphere(pos, rd + pos, cen2, rad1/2.);\n\tfloat A = length(pos - intSphere1.gba);\n\tfloat B = length(pos - intSphere2.gba);\n\n\n\tif(length(pos - ro) \u003e 0. \u0026\u0026 rd.y \u003e 0.){\n\t\t// d = .001 + hash21(gl_FragCoord.xy)*.005;\n\t\tfloat distMult = HD ? 1. : 2.;\n\t\td = .024 * distMult * (1. + (pos.y - skyHeight + ep) / (rd.y + ep));\n\t\tobj = 1;\n\t}\n\telse if(rd.y \u003c 0.){\n\t\td = (-skyHeight - pos.y + ep) / (rd.y + ep);\n\t\t// d /= 2.;\n\t\t// d = abs(d);\n\t\tobj = 2;\n\t}\n\n\n\tif(intSphere1.x \u003e 0. \u0026\u0026 intSphere2.x \u003e 0. \u0026\u0026 min(A, B) \u003c d){\n\t\tobj = 4;\n\t\tif(A \u003e B){\n\t\t\tobj = 5;\n\t\t}\n\t\treturn dObj(min(A, B), obj);\n\t}\n\telse if(intSphere1.x \u003e 0. \u0026\u0026 A \u003c d){\n\t\tobj = 4;\n\t\treturn dObj(A, obj);\n\t}\n\telse if(intSphere2.x \u003e 0. \u0026\u0026 B \u003c d){\n\t\tobj = 5;\n\t\treturn dObj(B, obj);\n\t}\n\n\treturn dObj(d, obj);\n}\n\nvoid mapAurora(inout Ray ray, vec3 ro, vec3 rd){\n\t// vec3 offset = vec3(sin(iTime/1.22), 0., cos(iTime/1.44));\n\tdObj mapAurora = mapDistAurora(ray.p, ro, rd);\n\tray.d = mapAurora.d;\n\tray.obj = mapAurora.obj;\n\n\tif(ray.obj == 1){\n\t\tfloat grad = .45 + .7 * (ray.p.y - skyHeight);\n\t\tvec3 rgb = hsv(grad * .75 + hueShift, .85, 1.);\n\t\tvec2 uvWav = mod(ray.p.zx / 30. + .5 + vec2(0., uvDisp), 1.);\n\t\tfloat wNoise = texture2D(iWavelet, uvWav).r / 4.;\n\t\tif(length(uvWav - .5) \u003e .5){\n\t\t\twNoise *= 0.;\n\t\t}\n\t\tif(!HD){\n\t\t\twNoise /= .7;\n\t\t}\n\t\tif(max(abs(ray.p.z), abs(ray.p.x)) \u003c renderDist){\n\t\t\tray.col += vec4(rgb, 1.) * pow(wNoise, 2.) * pow(clamp(grad, 0., 1.), .5) * .8;\n\t\t}\n\t}\n}\n\n// void normal( inout Ray ray ){\n// \tvec3 eps = vec3(0.001, 0.0, 0.0);\n// \tvec3 p = ray.p;\n// \tray.n = normalize( vec3(\n// \t\tmapDist(p+eps.xyy).d-mapDist(p-eps.xyy).d,\n// \t\tmapDist(p+eps.yxy).d-mapDist(p-eps.yxy).d,\n// \t\tmapDist(p+eps.yyx).d-mapDist(p-eps.yyx).d\n// \t) );\n// }\n\nvec2 noiseNormal(vec2 p){\n\tvec2 ep = vec2(.01, 0.);\n\tfloat zPos = iTime/100.;\n\tfloat nFreq = 1. * .05 * sin(iTime / 60.);\n\tnFreq = 1.;\n\tfloat dX = fbm(vec3((p + ep.xy)  * nFreq, zPos)) - \n\t\tfbm(vec3((p - ep.xy)  * nFreq, zPos));\n\tfloat dY = fbm(vec3((p + ep.yx)  * nFreq, zPos)) - \n\t\tfbm(vec3((p - ep.yx)  * nFreq, zPos));\n\treturn vec2(dX, dY) * (1.25 + sin(iTime / 40.) * .75) ;\n}\n\nRay raymarch( in vec3 ro, in vec3 rd){\n    const int maxSteps = 24;\n    float maxDist = 100.;\n    float epsilon = 0.001;\n\tRay ray = Ray(\n        ro, \n        -1,\n        100.,\n        vec4(0.),\n        vec3(0., 1., 0.)\n    );\n\tfloat t = 0.;\n\tvec3 roN = vec3(ro);\n\tvec3 rdN = normalize(vec3(rd));\n\tfor(int i=0; i\u003cmaxSteps; i++){\n\t\tif(HD || mod(float(i), 2.) == 0.){\n\t        mapAurora(ray, roN, rdN);\n\t        t += ray.d;\n\t        ray.p += rdN * ray.d;  \n\t\t\tif( ray.d \u003c epsilon){//} || t \u003e maxDist){\n\t            break;\n\t\t\t}\n\t\t\tif(ray.obj == 2){\n\t\t\t\tvec2 noiseNorm = .7 * noiseNormal(ray.p.xz / 8. + vec2(0., uvDisp));\n\t\t\t\troN = vec3(ray.p);\n\t\t\t\trdN = reflect(rdN, normalize(vec3(noiseNorm.x, 1.0, noiseNorm.y)));\n\t\t\t}\n\t\t\telse if(ray.obj == 4){//} \u0026\u0026 length(ray.p - cen1) \u003c rad1 * 2.){\n\t\t\t\troN = vec3(ray.p);\n\t\t\t\trdN = reflect(rdN, normalize(ray.p-cen1));\n\t\t\t}\n\t\t\telse if(ray.obj == 5){\n\t\t\t\troN = vec3(ray.p);\n\t\t\t}\n\t\t}\n\t}\n\n\t// if(ray.d \u003c epsilon){\n\t// \tnormal(ray);\n\t// }\n\t// else{\n\t// \tray.obj = -1;\n\t// }\n\t\n\treturn ray;\n}\n\nvoid shade(inout Ray ray, in vec3 rd){\n\tvec3 ldir1 = 3. * vec3(sin(iTime/3.), 1., cos(iTime/3.));\n\tif(ray.obj == 0){\n\t\t// float roughness = .1;\n\t\t// ray.col += vec4(.9 * (1.-ray.col.a), 0., 0., 1.);\n\t\t// vec3 refl = reflect(rd, ray.n);  \n  //       float spec = pow(clamp( dot( refl, ldir1 ), 0.0, 1.0 ), 1./roughness);\n\t\t// ray.col += .7 * spec * (1.-ray.col.a);\n\t\tray.col = vec4(1., 0., 0., 1.);\n\t}\n\t// else if(ray.obj == 4){\n\t// \tray.col += vec4(vec3(.8), 1.);\n\t// }\n\telse if(ray.obj == 5){\n\t\tray.col += vec4(vec3(moonLight), 1.);\n\t}\n\telse{\n\t\t// ray.col = vec4(1.) - ray.col;\n\t}\n\n\t// if(ray.obj == 1){\n\t// \tray.col = vec4(1.);\n\t// }\n}\n\nvec4 render(vec2 q){\n\tvec2 v = -1.0 + 2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\n\tfloat theta = thetaMap(atan(v.y, v.x), 3. * PI / 2.) ;\n\tfloat rad = length(v);\n\n\t// theta -= PI / 3. * camSin;\n\ttheta *= camKal;\n\ttheta -= 2. * PI * (camKal - 1.) / 4.;\n\n\tv = rad * vec2(cos(theta), sin(theta));\n\n    //Camera Settings\n    // float fisheye = fisheye;\n    float lens = 1.9 - fisheye * length(v);\n\n\t//camera ray\n    // float camDist = ;\n    float camFreq = 9999999.;\n    vec3 rayOrigin = camDist * vec3(rayOriginC.x, 0., rayOriginC.y) + \n    \tvec3(rayOriginOffset.x, 0., rayOriginOffset.y);\n\tvec3 rayDir = normalize( vec3(v.x, v.y, lens) );\n    vec3 target = vec3(0.0, 0., 0.0);\n\trayDir = lookat( target-rayOrigin, vec3(0.,rayUp))*rayDir;\n    \n\t//classic raymarching by distance field\n\tRay ray = raymarch(rayOrigin, rayDir);\n\tshade(ray, rayDir);\n    return ray.col;\n}\n\nvoid main()\n{\n\tcen1 = vec3(ballX, -skyHeight/2. * ballY, 0.);\n\t// vec3 cen1 = -vec3(0., skyHeight/2., 0.);\n\trad1 = skyHeight/2.;\n\tcen2 = cen1 + skyHeight * vec3(moonXY.x, 0., moonXY.y);\n\n    vec2 p = gl_FragCoord.xy/iResolution.xy;\n    vec4 col = render(p);\n        \n\tgl_FragColor = col;\n}"])</script><script>self.__next_f.push([1,"1c:Taf5,"])</script><script>self.__next_f.push([1,"precision highp float;\n\nuniform vec2 iResolution;\nuniform sampler2D iAudioData;\nuniform float iTime;\nuniform bool HD;\n\nuniform float thetaScale;\n\n\n// Try these for more or less fun:\n#define REFLECT \n#define RADIAL \n#define SCALE_ON_MOUSE_X\n\n// Iain Melvin 2014, Isomov 2019\n\nconst float PI = 3.141592653589;\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n\treturn hsv2rgb(vec3(h, s, v));\n}\n\n\nvoid main()\n{\n    // create pixel coordinates\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    #ifdef REFLECT\n    \tuv = abs( uv * 2.0 - vec2(1.) );\n    #endif\n\n    // #ifdef SCALE_ON_MOUSE_X\n    //     uv *= 1.0 - min( 0.9, iMouse.x/iResolution.x );\n    // #endif\n\t\n    #ifdef RADIAL\n        float theta = thetaScale * atan(uv.x, uv.y);\n        float r = length(uv);\n        uv = vec2(theta,r);\t\n    #endif\t\n\t\n    // first texture2D row is frequency data\n    float fft  = texture2D( iAudioData, vec2(.01, uv.x) ).x;\n\n    // second texture2D row is the sound wave\n    //float wave = texture2D( iAudioData, vec2(.99, uv.x) ).x;\n\n    // my wavelet \n    float base = 3.;// + sin(iTime / 1.);\n    float width = 1.0 - pow(uv.y, 1.0 / base );\n    float numPer = 3.;\n    const int numSteps = 150;\n    const float stepSize = 1.0 / float(numSteps);\n\n    float yr = 0.0;\n    float accr = 0.0;\n    float accn = 0.0;\n\n    float i = 0.;\n   \n    for (float x = -1.0; x \u003c 1.0; x += stepSize){\n\t\t\n\t\tif(HD || mod(i, 2.) == 0.){\n\t        // the wave in the wavelet\n\t        float freq = 2.*PI * numPer;\n\t        float yWave = sin( freq * ( 2.*uv.x + x ) ); \n\n\t        // get a sample - center at uv.x, offset by width*x\n\t        float xSound = uv.x + width*x;\n\t        \n\t        float ySound = texture2D( iAudioData, vec2(.99, xSound)).x; \n\n\t        // remap sample to [-1, 1]\n\t        ySound = 2. * (ySound - 0.5);\n\n\t        // multiply with the wave in the wavelet\n\t        float yMult = yWave * ySound;\n\n\t        // apply packet 'window'\n\t        float w =  0.5 * (1.0 - sin( PI * (x + 1.5)));\n\t        //float w = 1.0-abs(x); //faster\n\t        yMult *= w;\n\n\t        // accumulate\n\t        accr += yMult;\n\t        accn += w * abs(yWave);\n\t    }\n        i += 1.;\n\n    }\n\n    float y = 30.0 * abs(accr)/float(accn);\n    \n    vec3 col = vec3(0,0,0);\n    if (uv.y \u003c 0.0){\n        // chrome fft\n        col += vec3(fft);\n    }\n    else{\n        y=clamp(y,0.0,1.0);\n        vec3 outCol = hsv2rgb(y/2.+.3+iTime/20., .65, .85);\n        col += outCol;\n    }\n\t\n    // add wave form on top     \n    //col += 1.0 -  smoothstep( 0.0, 0.01, abs(wave - uv.y) );\n\n    // output final color\n    y = pow(y, 2.);\n    gl_FragColor = vec4(y,y,y,1.0);\n    \n}\n"])</script><script>self.__next_f.push([1,"a:[\"$\",\"$Lb\",null,{\"track\":null,\"data\":{\"shaders\":{\"add.fs\":\"precision highp float;\\n\\nuniform vec2 resolution1;\\nuniform vec2 resolution2;\\nuniform sampler2D tex1;\\nuniform sampler2D tex2;\\n\\nvoid main() {\\n\\tvec2 uv1 = gl_FragCoord.xy / resolution1;\\n\\tvec2 uv2 = gl_FragCoord.xy / resolution1;\\n\\tgl_FragColor = texture2D(tex1, uv1) + texture2D(tex2, uv2);\\n}\",\"black.fs\":\"precision mediump float;\\n\\nvoid main() {\\n\\tgl_FragColor = vec4(0.0,0.0,0.0,1.0);\\n}\",\"circle.fs\":\"$c\",\"default.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tgl_FragColor = texture2D(u_texture, uv);\\n}\",\"default.vs\":\"attribute vec4 position;\\n\\nvoid main() {\\n\\tgl_Position = position;\\n}\",\"random.fs\":\"precision highp float;\\n\\nfloat hash1( float n ){\\n    return fract(sin(n)*138.5453123);\\n}\\n\\nfloat random (vec2 st) {\\n    return step(0.5, hash1(st.x*13.0+hash1(st.y*71.1)));\\n}\\n\\nvoid main() {\\n\\tfloat random = random(gl_FragCoord.xy/1000.);\\n\\tgl_FragColor = vec4(random, random, random, 1.);\\n}\",\"blur.fs\":\"$d\",\"composite.fs\":\"$e\",\"decode.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, texcoord);\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tvec2 val = extract(u_texture, uv);\\n\\tgl_FragColor = vec4(val.x, val.x, val.x, 1.);\\n}\",\"encode.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tvec4 val = texture2D(u_texture, uv);\\n\\tgl_FragColor = pack(vec2(val.r * val.a));\\n}\",\"feedback.fs\":\"$f\",\"lookup.fs\":\"$10\",\"particleDraw.fs\":\"precision highp float;\\nvarying vec3 color;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nuniform float HD;\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nvoid main () {\\n\\tgl_FragColor = pack(vec2(HD \u003e .5 ? .02 : .02,.13));\\n}\",\"particleDraw.vs\":\"precision highp float;\\n\\nattribute vec2 v_texcoord;\\nattribute vec2 position;\\n\\nuniform sampler2D u_texture;\\nvarying vec3 color;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\nconst float OFFSET = 0.0;\\n\\n// vec3 hsv2rgb(vec3 c) {\\n// \\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n// \\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n// \\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n// }\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\\n}\\n\\nvec2 extract(sampler2D tex){\\n\\tvec4 valueRAW = texture2D(tex, position);\\n\\treturn vec2(decode(valueRAW.xy), decode(valueRAW.zw));\\n}\\n\\nvoid main () {\\n\\tvec2 pos = extract(u_texture);\\n\\t// color = hsv2rgb(vec3(0.5 * v_texcoord + 0.4, 0.9)) * .1;\\n\\tgl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);\\n\\tgl_PointSize = .5;\\n}\",\"particleInit.fs\":\"precision highp float;\\nuniform int pass;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nvec2 encode(float value) {\\n    value = value * scale;\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nvec2 n2rand() {\\n\\treturn vec2(\\n\\t\\tfract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453),\\n  \\t\\tfract(sin(dot(gl_FragCoord.xy * 1.61803, vec2(12.9898, 78.233))) * 43758.5453)\\n  \\t);\\n}\\n\\nvoid main() {\\n\\t\\t\\tvec2 pos_rand = n2rand() - .5;\\n\\tif(pass == 0){\\n\\t\\tgl_FragColor = pack(.5 + pos_rand );// + vec4(n2rand(), -1., -1.);\\n\\t}\\n\\telse{\\n\\t\\tgl_FragColor = pack(2.*pos_rand);\\n\\t}\\n}\",\"particleInit.vs\":\"precision mediump float;\\nattribute vec2 position;\\n\\nvoid main() {\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n}\",\"particlePhysics.fs\":\"$11\",\"particlePhysics.vs\":\"precision mediump float;\\n\\nattribute vec2 position;\\nvarying vec2 v_texcoord;\\n\\nvoid main() {\\n\\tv_texcoord = 0.5 * position + 0.5;\\n\\t// v_texcoord = position;\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n}\",\"phong.fs\":\"$12\",\"skin.fs\":\"$13\",\"mediaToggle.fs\":\"$14\",\"mediaplayer.fs\":\"$15\",\"miniplayer.fs\":\"$16\",\"yinyang.fs\":\"$17\",\"memory.fs\":\"$18\",\"blackhole.fs\":\"$19\",\"life.fs\":\"$1a\",\"audio.vs\":\"precision mediump float;\\nattribute vec2 audioData;\\n\\nvoid main() {\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n}\",\"aurora.fs\":\"$1b\",\"wavelet.fs\":\"$1c\"},\"imgs\":{\"hdri.jpg\":\"/media/tex/hdri.jpg\",\"media player buttons.jpg\":\"/media/tex/media player buttons.jpg\",\"media player diffuse.jpg\":\"/media/tex/media player diffuse.jpg\",\"media player height.jpg\":\"/media/tex/media player height.jpg\",\"media player lights.jpg\":\"/media/tex/media player lights.jpg\",\"media player pause N.jpg\":\"/media/tex/media player pause N.jpg\",\"media player play N.jpg\":\"/media/tex/media player play N.jpg\",\"mini player buttons.jpg\":\"/media/tex/mini player buttons.jpg\",\"mini player diffuse.jpg\":\"/media/tex/mini player diffuse.jpg\",\"mini player height.jpg\":\"/media/tex/mini player height.jpg\",\"mini player lights.jpg\":\"/media/tex/mini player lights.jpg\",\"mini player pause N.jpg\":\"/media/tex/mini player pause N.jpg\",\"mini player play N.jpg\":\"/media/tex/mini player play N.jpg\",\"pebbles.png\":\"/media/tex/pebbles.png\",\"rand.png\":\"/media/tex/rand.png\",\"x N.jpg\":\"/media/tex/x N.jpg\",\"x.jpg\":\"/media/tex/x.jpg\"}}}]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"In Theory\"}],[\"$\",\"meta\",\"2\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n9:null\n"])</script></body></html>