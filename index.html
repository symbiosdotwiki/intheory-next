<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="preload" as="font" href="/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d29cddffa7307101.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/a0e1629e678a17ee.css" data-precedence="next"/><title>Portal</title><meta name="description" content="Web Portal for Shaders"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="any"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js" noModule=""></script></head><body class="__className_d9825c"><div class="container"><div class="container intro hidden shown "><canvas></canvas></div></div><script src="/_next/static/chunks/webpack-667aa16321c92dfa.js" async=""></script><script src="/_next/static/chunks/bce60fc1-d0cd5b15b23a1f1c.js" async=""></script><script src="/_next/static/chunks/488-4c6557ca765efbab.js" async=""></script><script src="/_next/static/chunks/main-app-b7bd89dfd097591e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2\",{\"as\":\"font\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/d29cddffa7307101.css\",{\"as\":\"style\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/_next/static/css/a0e1629e678a17ee.css\",{\"as\":\"style\"}]\n"])</script><script>self.__next_f.push([1,"5:I{\"id\":\"8827\",\"chunks\":[\"272:static/chunks/webpack-667aa16321c92dfa.js\",\"253:static/chunks/bce60fc1-d0cd5b15b23a1f1c.js\",\"488:static/chunks/488-4c6557ca765efbab.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":\"9126\",\"chunks\":[\"272:static/chunks/webpack-667aa16321c92dfa.js\",\"253:static/chunks/bce60fc1-d0cd5b15b23a1f1c.js\",\"488:static/chunks/488-4c6557ca765efbab.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":\"4463\",\"chunks\":[\"272:static/chunks/webpack-667aa16321c92dfa.js\",\"253:static/chunks/bce60fc1-d0cd5b15b23a1f1c.js\",\"48"])</script><script>self.__next_f.push([1,"8:static/chunks/488-4c6557ca765efbab.js\"],\"name\":\"\",\"async\":false}\na:I{\"id\":\"1010\",\"chunks\":[\"272:static/chunks/webpack-667aa16321c92dfa.js\",\"253:static/chunks/bce60fc1-d0cd5b15b23a1f1c.js\",\"488:static/chunks/488-4c6557ca765efbab.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d29cddffa7307101.css\",\"precedence\":\"next\"}]],[\"$\",\"$L5\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/\",\"initialTree\":[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[\"$L6\",[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\"}]],\"globalErrorComponent\":\"$7\",\"notFound\":[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_d9825c\",\"children\":[\"$L8\",\"$undefined\",[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]]}]}],\"asNotFound\":false,\"children\":[[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_d9825c\",\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lb\",null],\"segment\":\"__PAGE__\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a0e1629e678a17ee.css\",\"precedence\":\"next\"}]]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"c:I{\"id\":\"1025\",\"chunks\":[\"461:static/chunks/f7e1f445-3de08182542dee2d.js\",\"250:static/chunks/250-8a2303d25e00ebc4.js\",\"531:static/chunks/app/[id]/page-2ea05a1213ce5a6c.js\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"b:[\"$\",\"$Lc\",null,{\"track\":0,\"data\":{\"shaders\":{\"add.fs\":\"precision highp float;\\n\\nuniform vec2 resolution1;\\nuniform vec2 resolution2;\\nuniform sampler2D tex1;\\nuniform sampler2D tex2;\\n\\nvoid main() {\\n\\tvec2 uv1 = gl_FragCoord.xy / resolution1;\\n\\tvec2 uv2 = gl_FragCoord.xy / resolution1;\\n\\tgl_FragColor = texture2D(tex1, uv1) + texture2D(tex2, uv2);\\n}\",\"black.fs\":\"precision mediump float;\\n\\nvoid main() {\\n\\tgl_FragColor = vec4(0.0,0.0,0.0,1.0);\\n}\",\"circle.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\n// uniform vec2 center;\\nuniform float radius;\\nuniform sampler2D rand;\\nuniform sampler2D pebbles;\\nuniform float iTime;\\n\\nconst vec2 zOffset = vec2(37.0,17.0);\\nconst vec2 wOffset = vec2(59.0,83.0);\\n\\nvec4 texNoise(vec2 uv)   // Emulate a single texture fetch into the precalculated texture\\n{\\n    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.\\n    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.\\n    float r = texture2D( rand, mod((uv+0.5)/256.0, 1.)).r;\\n    float g = texture2D( rand, mod((uv+0.5 + zOffset)/256.0, 1.)).r;\\n    float b = texture2D( rand, mod((uv+0.5 + wOffset)/256.0, 1.)).r;\\n    float a = texture2D( rand, mod((uv+0.5 + zOffset + wOffset)/256.0, 1.)).r;\\n    \\n    return vec4(r, g, b, a);\\n}\\n\\n\\nfloat noise4dFast( in vec4 x )\\n{\\n    vec4 p = floor(x);\\n    vec4 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    \\n    vec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;\\n    \\n    vec4 s = texNoise(uv);\\n    return mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);\\n}\\n\\nvoid main() {\\n\\tvec2 uv = 2.*(gl_FragCoord.xy / resolution - vec2(.5));\\n\\tvec4 col = vec4(vec3(0.), 1.);\\n\\n\\tvec2 center = vec2(0.);\\n\\tcenter.x = 1.6 * noise4dFast(vec4(vec3(0.), iTime / 3. + 0.)) - .8;\\n\\tcenter.y = 1.6 * noise4dFast(vec4(iTime / 3. + 9999., vec3(0.))) - .8;\\n\\n\\tif(length(uv-center)\u003cradius){\\n\\t\\tcol.xyz = texture2D(pebbles, (uv-center) / radius).rgb;\\n\\t}\\n\\tgl_FragColor = col;\\n}\",\"decode.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, texcoord);\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tvec2 val = extract(u_texture, uv);\\n\\tgl_FragColor = vec4(val.x, val.x, val.x, 1.);\\n}\",\"default.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tgl_FragColor = texture2D(u_texture, uv);\\n}\",\"default.vs\":\"attribute vec4 position;\\n\\nvoid main() {\\n\\tgl_Position = position;\\n}\",\"encode.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tvec4 val = texture2D(u_texture, uv);\\n\\tgl_FragColor = pack(vec2(val.r * val.a));\\n}\",\"particleDraw.fs\":\"precision highp float;\\nvarying vec3 color;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nuniform float HD;\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nvoid main () {\\n\\tgl_FragColor = pack(vec2(HD \u003e .5 ? .02 : .02,.13));\\n}\",\"particleDraw.vs\":\"precision highp float;\\n\\nattribute vec2 v_texcoord;\\nattribute vec2 position;\\n\\nuniform sampler2D u_texture;\\nvarying vec3 color;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\nconst float OFFSET = 0.0;\\n\\n// vec3 hsv2rgb(vec3 c) {\\n// \\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n// \\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n// \\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n// }\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\\n}\\n\\nvec2 extract(sampler2D tex){\\n\\tvec4 valueRAW = texture2D(tex, position);\\n\\treturn vec2(decode(valueRAW.xy), decode(valueRAW.zw));\\n}\\n\\nvoid main () {\\n\\tvec2 pos = extract(u_texture);\\n\\t// color = hsv2rgb(vec3(0.5 * v_texcoord + 0.4, 0.9)) * .1;\\n\\tgl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);\\n\\tgl_PointSize = .5;\\n}\",\"particleInit.fs\":\"precision highp float;\\nuniform int pass;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\n\\nvec2 encode(float value) {\\n    value = value * scale;\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nvec2 n2rand() {\\n\\treturn vec2(\\n\\t\\tfract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453),\\n  \\t\\tfract(sin(dot(gl_FragCoord.xy * 1.61803, vec2(12.9898, 78.233))) * 43758.5453)\\n  \\t);\\n}\\n\\nvoid main() {\\n\\t\\t\\tvec2 pos_rand = n2rand() - .5;\\n\\tif(pass == 0){\\n\\t\\tgl_FragColor = pack(.5 + pos_rand );// + vec4(n2rand(), -1., -1.);\\n\\t}\\n\\telse{\\n\\t\\tgl_FragColor = pack(2.*pos_rand);\\n\\t}\\n}\",\"particleInit.vs\":\"precision mediump float;\\nattribute vec2 position;\\n\\nvoid main() {\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n}\",\"random.fs\":\"precision highp float;\\n\\nfloat hash1( float n ){\\n    return fract(sin(n)*138.5453123);\\n}\\n\\nfloat random (vec2 st) {\\n    return step(0.5, hash1(st.x*13.0+hash1(st.y*71.1)));\\n}\\n\\nvoid main() {\\n\\tfloat random = random(gl_FragCoord.xy/1000.);\\n\\tgl_FragColor = vec4(random, random, random, 1.);\\n}\",\"life.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\nuniform float iTime;\\n\\nconst float PI = 3.1415926535897;\\n\\nvec3 sphericalToCartesian( float rho, float phi, float theta ) {\\n    float sinTheta = sin(theta);\\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\\n}\\n\\nint state(vec2 uv){\\n\\tif(uv.x \u003e 1.){\\n\\t\\tuv.x -= 1.;\\n\\t}\\n\\tif(uv.x \u003c 0.){\\n\\t\\tuv.x += 1.;\\n\\t}\\n\\tif(uv.y \u003e 1.){\\n\\t\\tuv.y -= 1.;\\n\\t}\\n\\tif(uv.y \u003c 0.){\\n\\t\\tuv.y += 1.;\\n\\t}\\n\\treturn texture2D(u_texture, uv).r \u003e .5 ? 1 : 0;\\n}\\n\\nint sphericalState(vec2 uv){\\n\\tvec2 offset = uv * vec2(2.*PI, PI);\\n\\tvec3 sphereMap = sphericalToCartesian(1., offset.x, offset.y);\\n\\treturn state(sphereMap.xy);\\n}\\n\\nvoid main() {\\n\\t\\tvec2 UV = gl_FragCoord.xy / resolution;\\n\\n\\t\\tint curState = state(UV);\\n\\n\\t\\tint sum = 0;\\n\\n\\t\\tfor(int i = -1; i \u003c= 1; i ++){\\n\\t\\t\\tfor(int j = -1; j \u003c= 1; j ++){\\n\\t\\t\\t\\tif( !(i == 0 \u0026\u0026 j == 0)){\\n\\t\\t\\t\\t\\tvec2 offset = UV + vec2(i, j) /  resolution;\\n\\t\\t\\t\\t\\tsum += state(offset);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfloat newState1 = \\n\\t\\t\\t(curState == 0 \u0026\u0026 sum == 3) || \\n\\t\\t\\t(curState == 1 \u0026\u0026 (sum == 3 || sum == 2)) ? 1. : 0.;\\n\\t\\tfloat newState2 = \\n\\t\\t\\t(curState == 0 \u0026\u0026 sum == 2) || \\n\\t\\t\\t(curState == 1 \u0026\u0026 (sum \u003c= 4 || sum \u003e= 2)) ? 1. : 0.;\\n\\n\\t\\tfloat newState = iTime \u003e 10. \u0026\u0026 iTime \u003c 10.3 ? newState2 : newState1;\\n\\t\\t\\n\\t\\tgl_FragColor = vec4(vec3(newState1), 1);\\n\\t\\t// gl_FragColor = vec4(curState, curState, curState, 1);\\n\\t\\t// gl_FragColor = vec4(.5, .1, 0, 1);\\n\\n}\",\"skin.fs\":\"precision highp float;\\n\\n// Uses code by IQ and anatole duprat - XT95/2015\\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\\n\\n// Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look :\\n// http://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\\n\\nstruct Ray{\\n  vec3 p;\\n  int obj;\\n  float d;\\n};\\n\\nuniform float iTime;\\nuniform sampler2D iChannel0;\\nuniform sampler2D randSampler;\\nuniform vec3 iAudio;\\nuniform vec2 iResolution;\\n\\nuniform float tunnelPos;\\nuniform float fisheye;\\nuniform vec2 creatureXY;\\nuniform float tunnelLight;\\nuniform float tunnelBase;\\nuniform float creatureLight;\\nuniform float wingRot;\\nuniform float creatureFlip;\\nuniform float creatureTwist;\\nuniform int HD;\\nuniform float fairyLight;\\nuniform float tunnelWonky;\\nuniform float tunnelWidth;\\nuniform float checker;\\nuniform float fairyTime;\\nuniform vec2 rayUp;\\n\\nconst float PI = 3.14159265359;\\nconst vec3 ax = vec3(1., 0., 0.);\\n\\nRay raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane );\\nvec3 normal( in vec3 p );\\nRay map( in vec3 p );\\nmat3 lookat( in vec3 fw, in vec3 up );\\nvec3 rotate( in vec3 v, in float angle, in vec3 pos);\\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff );\\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff );\\nfloat smin( float a, float b, float k );\\n\\n\\nvec3 lpos1,lpos2,lpos3;\\nvec3 lpos4,lpos5,lpos6;\\nvec3 pCreature, pCreatureOffset;\\nvec4 rCreature;\\nvec3 posOff;\\nvec3 sssColor, diffColor1, diffColor2, diffColor3;\\n\\n// vec2 tunnelOffset, tunnelWave;\\n// vec4 rCreatureI;\\nvec3 pTunnel;\\n\\nvec3 fairy[9];\\nconst int numFairy = 9;\\n\\nfloat aoMaxSteps = 3.0;\\n\\n\\nvec4 quat_from_axis_angle(vec3 axis, float angle)\\n{ \\n  vec4 qr;\\n  float half_angle = (angle * 0.5);\\n  qr.x = axis.x * sin(half_angle);\\n  qr.y = axis.y * sin(half_angle);\\n  qr.z = axis.z * sin(half_angle);\\n  qr.w = cos(half_angle);\\n  return qr;\\n}\\n\\nvec4 quat_conj(vec4 q)\\n{ \\n  return vec4(-q.x, -q.y, -q.z, q.w); \\n}\\n  \\nvec4 quat_mult(vec4 q1, vec4 q2)\\n{ \\n  vec4 qr;\\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\\n  return qr;\\n}\\n\\nvec3 rotate_vertex_position(vec3 position, vec4 qr)\\n{ \\n  // vec4 qr = quat_from_axis_angle(axis, angle);\\n  vec4 qr_conj = quat_conj(qr);\\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\\n  \\n  vec4 q_tmp = quat_mult(qr, q_pos);\\n  qr = quat_mult(q_tmp, qr_conj);\\n  \\n  return vec3(qr.x, qr.y, qr.z);\\n}\\n\\nvec2 GetGradient(vec2 intPos, float t) {\\n    \\n    // Texture-based rand (a bit faster on my GPU)\\n    float rand = texture2D(randSampler, intPos / 64.0).r;\\n    \\n    // Rotate gradient: random starting rotation, random rotation rate\\n    float angle = 600.283185 * rand + 4.0 * t * rand;\\n    return vec2(cos(angle), sin(angle));\\n}\\n\\n\\nfloat Pseudo3dNoise(vec3 pos) {\\n    vec2 i = floor(pos.xy);\\n    vec2 f = pos.xy - i;\\n    vec2 blend = f * f * (3.0 - 2.0 * f);\\n    float noiseVal = \\n        mix(\\n            mix(\\n                dot(GetGradient(i + vec2(0., 0.), pos.z), f - vec2(0., 0.)),\\n                dot(GetGradient(i + vec2(1., 0.), pos.z), f - vec2(1., 0.)),\\n                blend.x),\\n            mix(\\n                dot(GetGradient(i + vec2(0., 1.), pos.z), f - vec2(0., 1.)),\\n                dot(GetGradient(i + vec2(1., 1.), pos.z), f - vec2(1., 1.)),\\n                blend.x),\\n        blend.y\\n    );\\n    return noiseVal / 0.7; // normalize to about [-1..1]\\n}\\n\\nvec3 threePsuedo3dNoise(vec3 pos){\\n    vec3 threeNoise;\\n    threeNoise.x = Pseudo3dNoise(pos + vec3(0.1, 0., 0.));\\n    threeNoise.y = Pseudo3dNoise(pos + vec3(0.3111, 10., 999.123));\\n    threeNoise.z = Pseudo3dNoise(pos + vec3(0.3578, 110., 999999.45));\\n    return threeNoise;\\n}\\n\\n\\nvec3 objTrans(vec3 pos, vec3 oPos, vec4 qr){\\n    return rotate_vertex_position(pos, qr) + oPos;\\n}\\n\\nvec3 objTransI(vec3 pos, vec3 oPos, vec4 qr){\\n    return rotate_vertex_position(pos - oPos, quat_conj(qr));\\n}\\n\\nvec3 creature(vec3 pos){\\n    return objTransI(pos + pCreatureOffset, pCreature, rCreature) - pCreatureOffset;\\n}\\n\\nvec3 creatureI(vec3 pos){\\n    return objTrans(pos - pCreatureOffset, pCreature, rCreature) + pCreatureOffset;\\n}\\n\\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\\n\\nvec3 polarCoord(float r, float phi, float theta )\\n{\\n    // Theta starts at groundPlane\\n \\treturn vec3(\\n        r * sin(PI/2. - theta) * cos(phi),\\n        r * cos(PI/2. - theta),\\n       \\tr * sin(PI/2. - theta) * sin(phi)  \\n    );\\n}\\n\\nvec3 polarCoordDeg(float r, float phi, float theta )\\n{\\n \\treturn polarCoord(r, phi * PI / 180., theta  * PI / 180. );\\n}\\n\\nvec3 rectCoord(vec3 pos){\\n \\tfloat r = length(pos);\\n    float theta = atan(pos.y, pos.x);\\n    float phi = atan(length(pos.xy), pos.z);\\n    return vec3(r, phi, theta);\\n}\\n\\n// Picking colors with HSV is much simpler\\nvec3 hsv(float cX, float cY, float cZ)\\n{\\n    cX -= float(int(cX));\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);\\n    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);\\n}\\n\\n// Linear white point\\nconst float W = 1.2;\\nconst float T2 = 7.5;\\n\\n//Gamma correction\\nvec3 gamma(vec3 x, float gamma) {\\n    return pow(x, vec3(1./gamma));\\n}\\n\\nfloat fadeIn(float t){\\n \\treturn min(iTime/t,1.); \\n}\\n    \\n\\nRay raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane ){\\n    const int maxSteps = 80;\\n    float epsilon = 0.001;\\n\\tRay ray = Ray(\\n        ro+rd*nfplane.x, \\n        -1,\\n        -1.0\\n    );\\n\\tfloat t = 0.;\\n\\tfor(int i=0; i\u003cmaxSteps; i++)\\n\\t{\\n        ray = map(ray.p);\\n        t += ray.d;\\n        ray.p += rd * ray.d;\\n        if( \\n            ray.d \u003c epsilon || \\n            t \u003e (nfplane.y - (1. - float(HD)) * 200.) ||\\n            (i \u003e maxSteps / 4 \u0026\u0026 HD==0)\\n        )\\n            break;   \\n\\t}\\n\\t\\n\\treturn ray;\\n}\\n\\nvec3 normal( in vec3 p ){\\n\\tvec3 eps = vec3(0.001, 0.0, 0.0);\\n\\treturn normalize( vec3(\\n\\t\\tmap(p+eps.xyy).d-map(p-eps.xyy).d,\\n\\t\\tmap(p+eps.yxy).d-map(p-eps.yxy).d,\\n\\t\\tmap(p+eps.yyx).d-map(p-eps.yyx).d\\n\\t) );\\n}\\n\\n\\nmat3 lookat( in vec3 fw, in vec3 up ){\\n\\tfw = normalize(fw);\\n\\tvec3 rt = normalize( cross(fw, normalize(up)) );\\n\\treturn mat3( rt, cross(rt, fw), fw );\\n}\\n\\n\\nvec3 rotate( in vec3 v, in float angle, in vec3 pos){\\n\\tvec4 qr = quat_from_axis_angle(v, angle);\\n    return rotate_vertex_position(pos, qr);\\n}\\n\\n\\nfloat skinLookup(vec2 pos)\\n{\\n    float phase = .4*texture2D(iChannel0, mod(pos / 4., 1.0)).r;\\n    vec2 offset = vec2(sin(phase + iTime/20.), cos(phase + iTime/23.));\\n    return texture2D(iChannel0, mod(pos + offset, 1.0)).r ;\\n}\\n\\nfloat smin( float a, float b, float k ) //Thx to iq^rgba\\n{\\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\\n    return mix( b, a, h ) - k*h*(1.0-h);\\n}\\n\\nfloat smax( float d1, float d2, float k )\\n{\\n\\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\\n\\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\\n}\\n\\n\\nvec3 randomSphereDir(vec2 rnd)\\n{\\n\\tfloat s = rnd.x*PI*2.;\\n\\tfloat t = rnd.y*2.-1.;\\n\\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\\n}\\n\\nvec3 randomHemisphereDir(vec3 dir, float i)\\n{\\n\\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\\n\\treturn v * sign(dot(v, dir));\\n}\\n\\n\\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\\n{\\n    vec2 q = vec2( length(p.xz), p.y );\\n    \\n    float b = (r1-r2)/h;\\n    float a = sqrt(1.0-b*b);\\n    float k = dot(q,vec2(-b,a));\\n    \\n    if( k \u003c 0.0 ) return length(q) - r1;\\n    if( k \u003e a*h ) return length(q-vec2(0.0,h)) - r2;\\n        \\n    return dot(q, vec2(a,b) ) - r1;\\n}\\n\\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, in float h)\\n{\\n    p.z /= h;\\n    p.x = abs(p.x);\\n    float k = (sc.y*p.x\u003esc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\\n    return (sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb) * min(h, 1.);\\n}\\n\\nfloat sdCappedCylinder( vec3 p, float r, float h )\\n{\\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n\\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\\n{\\n\\tconst int nbIte = 8;\\n    const float nbIteInv = 1./float(nbIte);\\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\\n    \\n\\tfloat ao = 0.0;\\n    for( int i=0; i\u003cnbIte; i++ )\\n    {\\n        if(HD == 0 \u0026\u0026 i \u003e nbIte / 8) break;\\n        float l = hash(float(i))*maxDist;\\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\\n            \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        // for self occlusion problems\\n        ao += (l - map( p + rd ).d) / pow(1.+l, falloff);\\n    }\\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\\n}\\n\\n\\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\\n{\\n    // Num near samples\\n\\tconst int nbIte = 8;\\n    const float nbIteInv = 1./float(nbIte);    \\n\\tfloat ao = 0.0;\\n    for( int i=0; i\u003cnbIte; i++ )\\n    {\\n        if(HD == 0 \u0026\u0026 i \u003e nbIte / 8) break;\\n            float l = hash(float(i))*maxDist;\\n            // Normal is reversed from ao calculation\\n            vec3 rd = normalize(-n)*l;\\n            ao += (l + map( p + rd ).d) / pow(1.+l, falloff);\\n        \\n    }\\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\\n}\\n\\nvec4 calcTunnelOffset(vec3 tunnelP){\\n    vec2 tO = 6.*vec2(sin(tunnelP.x/12.), cos(tunnelP.x/12.));\\n    vec2 tW = 8.*vec2(sin(tunnelP.x/32.), cos(tunnelP.x/22.));\\n    return vec4(tO, tunnelWonky * tW);\\n}\\n\\n//Map\\nRay map( in vec3 p )\\n{\\n    float fairyDist = 999.;\\n    float fairySize = .08;\\n    // if(HD == 1){\\n    for(int i = 0; i \u003c numFairy; i++){\\n        if(HD == 1 || mod(float(i), 2.) == 0.){\\n        float fd = length(p - fairy[i]) - fairySize;\\n        fairyDist = min(fairyDist, fd);\\n        }\\n    }\\n    // }\\n\\n    vec3 pCreatROT = creature(p);;\\n\\n    vec3 bBallCenter = creature(lpos1) - posOff;\\n    vec3 lBallCenter = creature(lpos1);\\n    float wingRotMod = mod(-wingRot, 1.);\\n    float suckIn = abs(3. * max(.333, wingRotMod) - 2.);\\n    vec3 tBallCenter = bBallCenter + vec3(0., 5., 4.) * suckIn;\\n    vec3 cBallCenter = bBallCenter + vec3(4. + sin(iTime), -3., 2.);\\n\\n    // Render light balls\\n    float lightBallRad = .25;\\n    //p.xz = mod(p.xz+100., 200.)-100.;\\n    float d = 100.;//+textureLod(iChannel0, p.xz*.05, 0.0).r*1.5;\\n    d = min(d, length(pCreatROT-creature(lpos1))-lightBallRad);\\n    \\n    float lightBallRadWing = .2;\\n    d = min(d, length(pCreatROT-creature(lpos4))-lightBallRadWing);\\n    d = min(d, length(pCreatROT-creature(lpos5))-lightBallRadWing);\\n    d = min(d, length(pCreatROT-creature(lpos6))-lightBallRadWing);\\n\\n    // Render skin ball\\n    \\n    \\n    \\n    float bBallRad = 6.;\\n    float lBallRad = lightBallRad + .5;\\n    float tBallRad = 3.;\\n    //p.xz = mod(p.xz, 60.)-30.;\\n    //p = rotate(vec3(0.,1.,0.), p.y*.05*cos(iTime+sin(iTime*1.5+id.x*5.)+id.y*42.))*p;\\n    float bD = length(pCreatROT-bBallCenter) - bBallRad;\\n    float lD = length(pCreatROT-lBallCenter) - lBallRad;\\n    float tD = length(pCreatROT-tBallCenter) - tBallRad;\\n    float tD2 = length(pCreatROT-cBallCenter) - tBallRad/1.5  * (pow(iAudio[1], .5) + .5);\\n    float texDisp = .35 * skinLookup(\\n        (pCreatROT-bBallCenter).yz / 15.\\n    );\\n    d = min(d, smin(smin(smax(tD2, bD, 0.6), lD, 1.), tD, 2.) - texDisp );\\n\\n    //return d;\\n    \\n    vec3 pBranch = rotate(ax, 2.*PI/8., pCreatROT - bBallCenter);\\n    float branch = sdRoundCone(pBranch, .7, .3, 10.);\\n    \\n    pBranch = rotate(ax, 3.*PI/8., pCreatROT - bBallCenter);\\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\\n    \\n    pBranch = rotate(ax, 4.*PI/8., pCreatROT - bBallCenter);\\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\\n    \\n    pBranch = rotate(ax, 5.*PI/8., pCreatROT - bBallCenter);\\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\\n    \\n    vec3 pWing = rotate(ax, 1.38 - 2.*PI * wingRot,  \\n        pCreatROT - bBallCenter + vec3(0., 0., .5));\\n    float wing = sdCappedTorus(\\n        pWing.zyx, \\n        vec2(sin(.7),cos(.7)), \\n        11., 1.5, .33\\n    );\\n    branch = smin(branch, wing, 1.);\\n\\n    d = smin(d, branch - texDisp * .5, 2.);\\n\\n    vec3 tunnelP = p - pTunnel;\\n\\n    vec4 tunnelOffset = calcTunnelOffset(tunnelP);\\n    float tDist = length(tunnelP.yz + tunnelOffset.xy + tunnelOffset.zw);\\n    float cylinder = max(\\n        tunnelWidth - tDist, \\n    0.);\\n    cylinder *= min(1., 1./max(0.001, (abs(tunnelWonky)+.5)));\\n    // // if(max(abs(tunnelOffset.x + tunnelOffset.z), abs(tunnelOffset.y + tunnelOffset.w)) \u003e 1.){\\n    //     cylinder *= .5;\\n    // // }\\n    int obj = 0;\\n\\n    // if(HD == 1){\\n    if(fairyDist \u003c d \u0026\u0026 fairyDist \u003c cylinder){\\n        d = smin(d, fairyDist, .5);\\n        obj = 2;\\n    }\\n    // }\\n\\n    else if(cylinder \u003c d){\\n        obj = 1;\\n        d = cylinder;\\n    }\\n    \\n    return  Ray(p, obj, d);\\n}\\n\\nvec3 gradLight(vec3 pos){\\n    // pos = creature(pos - pCreatureOffset) + pCreatureOffset - pCreature;\\n    pos = rotate_vertex_position(pos - pCreature - pCreatureOffset, quat_conj(rCreature)) + pCreatureOffset;\\n    float angle = (atan(pos.y, pos.z) + PI) / (2. * PI);\\n    return hsv(angle * 3. + .2*sin(iTime * 1.5), .8, .4);\\n}\\n\\n//Shading\\nvec3 shade( in Ray ray, in vec3 n, in vec3 ro, in vec3 rd )\\n{\\t\\t\\n    vec3 p = vec3(ray.p);\\n\\n    // vec3 diffColor4 = ;\\n\\n    vec3 dC4 = gradLight(lpos4);\\n    vec3 dC5 = gradLight(lpos5);\\n    vec3 dC6 = gradLight(lpos6);\\n    \\n    float nLookup = skinLookup(rectCoord(n).yz / 25.);\\n    float nLookup2 = nLookup * nLookup - .5;\\n    vec3 skinColor = hsv(0.03, 0.3, nLookup-.2) + hsv(0.03 + nLookup2*.8, 0.7 - nLookup2, nLookup);\\n    skinColor /= 1.5;\\n    skinColor = abs(skinColor * skinColor);\\n    float roughness = 0.05;\\n    float shininess = .05;\\n    \\n    \\n    // Light positions wrt raymarch point\\n    float lL1 = length(lpos1-p);\\n    float lL2 = length(lpos2-p);\\n    float lL3 = length(lpos3-p);\\n    float lL4 = length(lpos4-p);\\n    float lL5 = length(lpos5-p);\\n    float lL6 = length(lpos6-p);\\n\\n\\tvec3 ldir1 = (lpos1-p) / lL1;\\t\\n\\tvec3 ldir2 =  (lpos2-p) / lL2;\\t\\n\\tvec3 ldir3 =  (lpos3-p) / lL3;\\n    \\n    vec3 ldir4 = (lpos4-p) / lL4;\\t\\n\\tvec3 ldir5 =  (lpos5-p) / lL5;\\t\\n\\tvec3 ldir6 =  (lpos6-p) / lL6;\\n    \\n    float latt1 = .3*pow(lL1 *.15, 3. ) / iAudio.x;\\n    float latt2 = pow( lL2*.15, 3. ) / iAudio.y;\\n    float latt3 = 3.*pow( lL3*.15, 2.5 ) / iAudio.z;\\n\\n    float latt4 = .3*pow( lL4*.15, 3. ) / iAudio.x;\\n    float latt5 = pow(lL5*.15, 3. ) / iAudio.y;\\n    float latt6 = pow( lL6*.15, 3. ) / iAudio.z;\\n\\n    diffColor1 = hsv(-.001/latt1+.5, .8, .3);\\n    \\n    // SSS multiplier (thickness) and AO\\n    float sssThick = .8;\\n\\tfloat thick = thickness(p, n, aoMaxSteps, 1./sssThick);\\n    \\n    float aoFalloff = 1.;\\n\\t// float occ = .1*pow( ambientOcclusion(p, n, aoMaxSteps, aoFalloff), 6.);\\n\\n    // Diffuse lighting from lights\\n\\t// vec3 diff1 = diffColor1 * (max(dot(n,ldir1),0.) ) / latt1;\\n\\tvec3 diff2 = diffColor2 * (max(dot(n,ldir2),0.) ) / latt2;\\n\\t// vec3 diff3 = diffColor3 * (max(dot(n,ldir3),0.) ) / latt3;\\n\\n    vec3 col = vec3(0.);//skinColor * diff2;// + diff2;// + diff3;\\n    \\n\\n    vec3 refl = reflect(rd,n);  \\n\\n    float fairySSS = 0.;\\n    if(HD == 1){\\n        for(int i = 0; i \u003c numFairy; i++){\\n            vec3 fpos = fairy[i];\\n            float ftrans = clamp( dot(-rd, -fpos+n), 0., 1.) + 1.;\\n            float flatt = pow( length(fpos-p), 4. );\\n            fairySSS += ftrans/flatt;\\n            }\\n    }\\n    fairySSS *= fairyLight;\\n\\n    float trans1 =  clamp( dot(-rd, -ldir1+n), 0., 1.) + 1. ;\\n    float trans2 =  clamp( dot(-rd, -ldir2+n), 0., 1.) + 1. ;\\n    float trans3 =  clamp( dot(-rd, -ldir3+n), 0., 1.) + 1. ;\\n    \\n    // SSS from lights inside\\n    float trans4 =  clamp( dot(-rd, -ldir4+n), 0., 1.) + 1.;\\n    float trans5 =  clamp( dot(-rd, -ldir5+n), 0., 1.) + 1. ;\\n    float trans6 =  clamp( dot(-rd, -ldir6+n), 0., 1.) + 1. ;\\n\\n    vec3 headLights = diffColor3 * creatureLight * trans3/latt3; \\n    vec3 bodyLights = creatureLight * gradLight(p) * (\\n        dC4*trans4/latt4 + dC5*trans5/latt5 + dC6*trans6/latt6\\n    );\\n    vec3 topLight = diffColor2 * creatureLight * thick * trans2/latt2;\\n    \\n\\n    if(ray.obj == 0){\\n        col = skinColor * diff2;// + diff2;// + diff3;\\n        // SSS from lights inside        \\n        \\n        col += thick * (sssColor * (\\n            .01*diffColor1*trans1/latt1 + \\n            .2 * topLight) +\\n            .1 * headLights + \\n            .05 * bodyLights +\\n            .001 * fairySSS\\n        ) ;\\n        col *= (.2 + .8*skinColor);\\n        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ),1./roughness);\\n        col += shininess*spec + .02*skinColor;\\n        // col = gradLight(p);\\n    }\\n\\n    else if(ray.obj == 1){\\n        vec3 pTunnelOff = p - pTunnel;\\n        vec4 tunnelOffset = calcTunnelOffset(pTunnelOff);\\n        pTunnelOff += 1. * vec3(0., tunnelOffset.xy);\\n        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ), 1.);\\n        spec = 1.;\\n        spec =  3. * spec * iAudio[2] * tunnelLight + tunnelBase;\\n        int dBool = int(mod(length(pTunnelOff.x/12.) * 2., 2.));\\n        float angle = (atan(pTunnelOff.z, pTunnelOff.y)+PI) / (2. * PI);\\n        int aFix = 0;\\n        int aBool = int(mod(angle * checker - checker / 2. - .5, 2.));\\n        float checker = mod(float(dBool + aBool + aFix), 2.0);\\n        col = \\n            vec3(checker) * (spec) * (\\n                pow(min(abs(p.x-50.), 300.)/300., 4.)  + \\n                2. * bodyLights + \\n                15. * headLights +\\n                pow(smoothstep(.0, .5, fairySSS), .6)\\n            ) + 10.*pow(smoothstep(.0, 2., fairySSS), 1.) * .3;\\n    }\\n\\n    else if(ray.obj == 2){\\n        col = vec3(fairyLight * (iAudio[0] + .5));\\n    }\\n\\n\\treturn col;\\n}\\n\\nvec3 render(vec2 q)\\n{\\n    // Camera coordinates\\n\\tvec2 v = -1.0 + 2.0*q;\\n\\tv.x *= iResolution.x/iResolution.y;\\n\\n\\n    sssColor = hsv(0.2, 0.6, 1.5);\\n    diffColor1 = hsv(0.3, 0.9, .5);\\n    diffColor2 = hsv(0.7, 0.1, 0.1);\\n    diffColor3 = hsv(0.9, 0.1, 0.5);\\n    \\n    //Camera Settings\\n    // float fisheye = ;\\n    float lens = 1.9 - fisheye * length(v);\\n    vec2 nfplane = vec2(.001, 400.);\\n\\n    vec3 lightOffset = vec3(cos(iTime*.5)*6., 0., sin(iTime*.5)*15.);\\n\\n    vec3 axisCreature = vec3(0., sin(iTime/1.4), cos(iTime/1.4));\\n    vec3 axisCreatureFlip = vec3(0., 0., 1.);\\n    vec3 axisCreatureTwist = vec3(0., 1., 0.);\\n    pCreature =  vec3(-15.-5.*exp(-cos(iTime/1.77)),-1.5+exp(-sin(iTime)), -1.);\\n    pCreature += vec3(creatureXY, 0.);\\n    // pCreature = vec3(0);\\n\\n    posOff = vec3(6., 1.5, 1.5);\\n    \\n    pCreatureOffset = 3. * vec3(exp(-sin(iTime/1.53)),exp(-sin(iTime*1.11)), -cos(iTime*2.11));\\n    \\n    //Flip\\n    rCreature = quat_from_axis_angle(axisCreature, 2.*PI*creatureFlip);\\n    // rCreatureI = quat_from_axis_angle(axisCreature, -2.*PI*creatureFlip);\\n\\n    //Twist\\n    rCreature = quat_mult(\\n        rCreature,\\n        quat_from_axis_angle(axisCreatureTwist, 2.*PI*creatureTwist)\\n    );\\n    // rCreatureI = quat_from_axis_angle(axisCreatureTwist, -2.*PI*creatureTwist);\\n\\n    rCreature = quat_mult(\\n        rCreature,\\n        quat_from_axis_angle(axisCreature, PI/6. * sin(iTime))\\n    );\\n    // rCreatureI = quat_from_axis_angle(axisCreature, -PI/6. * sin(iTime));\\n\\n    pTunnel = vec3(tunnelPos, 0., 0.);\\n    \\n\\t//define lights pos\\n    lpos1 = creatureI(vec3(6., 0., 0.));\\n\\tlpos2 = creatureI(vec3( 15., 3.5, 0.) + lightOffset);\\n\\tlpos3 = creatureI(vec3(2., 4., 2.8));\\n    \\n    lpos4 = creatureI(vec3(.5, 6.5, -9.5));\\n    lpos5 = creatureI(\\n        rotate(ax, 2.*PI * wingRot, vec3(.5, .65, -12.2) + posOff) - posOff - vec3(0., 0., .5)\\n    );\\n    lpos6 = creatureI(vec3(.5, -6., -11.));\\n\\n    // if(HD == 1){\\n    for(int i = 0; i \u003c numFairy; i++){\\n        if(HD == 0 \u0026\u0026 i \u003e numFairy / 2) break;\\n        fairy[i] = tunnelWidth * .8 * threePsuedo3dNoise(vec3(float(i)*12345., fairyTime, 0.)) + vec3(-10., 0., 0.);\\n    }\\n    // }\\n   \\n\\t//camera ray\\n    float camDist = 25.;\\n    float camFreq = 9999999.;\\n    vec3 ro = vec3(camDist, 0.0, 0.);\\n    vec3 rd = normalize( vec3(v.x, v.y, lens) );\\n    vec3 target = vec3(0.0, 0.0, 0.0);\\n\\trd = lookat( target-ro, vec3(0.,rayUp))*rd;\\n    \\n\\t//classic raymarching by distance field\\n\\tRay ray = raymarche(ro, rd, nfplane );\\n\\tvec3 n = normal(ray.p.xyz);\\n\\tvec3 col = shade(ray, n, ro, rd);\\n    return col;\\n}\\n\\nvoid main()\\n{\\n    vec2 p = gl_FragCoord.xy/iResolution.xy; \\n    vec3 col = render(p);\\n    \\n    col = gamma(col, 2.2); \\n\\n    // col = texture2D(iChannel0, p).rgb;   \\n        \\n\\tgl_FragColor = vec4(col,1.0)*fadeIn(0.9);\\n}\\n\",\"mediaToggle.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_diffuse;\\nuniform sampler2D u_normal;\\nuniform vec3 light;\\nuniform float TIME;\\nuniform float toggleStatus;\\n\\nconst float A_COL = .45;\\nconst float I_COL = .17;\\n\\nvec3 hsv2rgb(vec3 c) {\\n    c.x = mod(c.x, 1.);\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 hsv2rgb(float h, float s, float v) {\\n  return hsv2rgb(vec3(h, s, v));\\n}\\n\\nvoid main() {\\n\\tvec2 fragCoord = gl_FragCoord.xy;\\n\\tvec2 uv = fragCoord / resolution;\\n\\n\\tvec3 diffuse = texture2D(u_diffuse, uv).rgb;\\n\\tvec3 normal = texture2D(u_normal, uv).rgb;\\n\\tvec3 metal = vec3(diffuse.r);\\n\\tvec3 buttons = toggleStatus \u003e 0. ? \\n\\t\\thsv2rgb(I_COL, .85, diffuse.g) : hsv2rgb(A_COL, .85, diffuse.g);\\n\\n\\tfloat height = 0.;\\n\\n\\t// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;\\n\\tfloat alpha = ceil(diffuse.b);\\n\\tif(abs(uv.x-.5) \u003e .49){\\n\\t\\talpha = 0.;\\n\\t}\\n\\n\\tvec3 c = vec3(0.);\\n\\tif(alpha \u003e 0.){\\n\\t\\t// Phong\\n\\t\\tnormal = (normal - vec3(.5))*2.;\\n\\t\\tvec3 lp = vec3(\\n\\t\\t\\t3. * (light.x / resolution.x - .5), \\n\\t\\t\\t// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\\n\\t\\t\\t3.*(1.-light.y / resolution.y - .5), \\n\\t\\t\\t1.\\n\\t\\t);\\n\\t\\tvec3 sp = vec3(uv - vec2(.5, .5), -1.);\\n\\t\\tvec3 ep = vec3(.5, .5, 0.);\\n\\t\\tc = hsv2rgb(TIME/80. + .5, .85, pow(\\n\\t\\t\\tclamp(\\n\\t\\t\\t\\tdot(\\n\\t\\t\\t\\t\\tnormalize(reflect(lp-sp, normal)), \\n\\t\\t\\t\\t\\tnormalize(sp)\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\t0., 1.\\n\\t\\t\\t),\\n\\t\\t\\t10.\\n\\t\\t));\\n\\t}\\n\\n\\n\\tgl_FragColor = vec4(metal + buttons + c, 1.0) * alpha;\\n}\",\"mediaplayer.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform vec2 hdAA;\\nuniform sampler2D u_diffuse;\\nuniform sampler2D u_buttons;\\nuniform sampler2D u_playN;\\nuniform sampler2D u_pauseN;\\nuniform sampler2D u_height;\\nuniform sampler2D u_lights;\\nuniform vec3 light;\\nuniform float TIME;\\nuniform bool playing;\\nuniform vec3 buttonStatus;\\nuniform float toggleStatus;\\n\\nconst float A_COL = .45;\\nconst float I_COL = .55;\\nconst float B_COL = .1;\\nconst float B_COL_2 = .75;\\nconst float L_COL = .7;\\n\\nvec3 hsv2rgb(vec3 c) {\\n    c.x = mod(c.x, 1.);\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 hsv2rgb(float h, float s, float v) {\\n  return hsv2rgb(vec3(h, s, v));\\n}\\n\\nfloat sigmoid(float x){\\n\\treturn 1.0 / (1.0 + exp(-1.0 * x));\\n}\\n\\nvoid main() {\\n\\tvec2 fragCoord = gl_FragCoord.xy;\\n\\tvec2 uv = fragCoord / resolution;\\n\\n\\tvec3 diffuse = texture2D(u_diffuse, uv).rgb;\\n\\tvec3 buttonLights = texture2D(u_buttons, uv).rgb;\\n\\tvec3 heightRGB = texture2D(u_height, uv).rgb;\\n\\tvec3 buttonLights2 = texture2D(u_lights, uv).rgb;\\n\\n\\tvec3 normal = vec3(0.);\\n\\tvec3 metal = vec3(0.);\\n\\tvec3 buttons = vec3(0.);\\n\\tvec3 speakers = hsv2rgb(TIME/80., .85, diffuse.b);\\n\\n\\tfloat text = heightRGB.g;\\n\\tfloat height = 0.;\\n\\n\\tif(playing){\\n\\t\\tmetal = vec3(diffuse.g);\\n\\t\\tnormal = texture2D(u_playN, uv).rgb;\\n\\t\\theight = heightRGB.r;\\n\\t\\tbuttons += hsv2rgb(A_COL, .85, buttonLights.b * buttonStatus.b);\\n\\t}\\n\\telse{\\n\\t\\tmetal = vec3(diffuse.r);\\n\\t\\tnormal = texture2D(u_pauseN, uv).rgb;\\n\\t\\theight = heightRGB.b;\\n\\t\\tbuttons += hsv2rgb(A_COL, .85, buttonLights.g * buttonStatus.b);\\n\\t}\\n\\n\\tif(uv.x \u003c .5){\\n\\t\\tbuttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.r);\\n\\t}\\n\\telse{\\n\\t\\tbuttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.g);\\n\\t}\\n\\n\\t//info button\\n\\tif(uv.y \u003c .5){\\n\\t\\tbuttons += hsv2rgb(I_COL, .85, buttonLights2.g);\\n\\t}\\n\\telse{\\n\\t\\tif(uv.x \u003c .5){\\n\\t\\t\\tbuttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tbuttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;\\n\\t\\t}\\n\\t}\\n\\n\\t//AA\\n\\tbuttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.r * hdAA.y) * 1.2, 0., 1.);\\n\\t//HD\\n\\tbuttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.b * hdAA.x) * 1.2, 0., 1.);\\n\\n\\t// vec3 buttons = hsv2rgb(A_COL, .85, 1.) * color.g;\\n\\tfloat sOffset = toggleStatus*2. + .25;\\n\\tfloat alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);\\n\\n\\tif(abs(uv.x-.5) \u003e .49){\\n\\t\\talpha = 0.;\\n\\t}\\n\\n\\tvec3 c = vec3(0.);\\n\\tif(alpha \u003e 0.){\\n\\t\\t// Phong\\n\\t\\tnormal = (normal - vec3(.5))*2.;\\n\\t\\tvec3 lp = vec3(\\n\\t\\t\\t3. * (light.x / resolution.x - .5), \\n\\t\\t\\t// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\\n\\t\\t\\t3.*(1.-light.y / resolution.y - .5) * resolution.y / resolution.x, \\n\\t\\t\\t1.\\n\\t\\t);\\n\\t\\tvec3 sp = vec3(uv - vec2(.5, .5), -1.) * vec3(1., resolution.y / resolution.x, 1.);\\n\\t\\tvec3 ep = vec3(.5, .5, 0.);\\n\\t\\tc = hsv2rgb(TIME/80. + .5, .85, pow(\\n\\t\\t\\tclamp(\\n\\t\\t\\t\\tdot(\\n\\t\\t\\t\\t\\tnormalize(reflect(lp-sp, normal)), \\n\\t\\t\\t\\t\\tnormalize(sp)\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\t0., 1.\\n\\t\\t\\t),\\n\\t\\t\\t1000.\\n\\t\\t));\\n\\t}\\n\\n\\tgl_FragColor = vec4(metal + buttons + c + speakers, 1.0) * alpha;\\n}\",\"miniplayer.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_diffuse;\\nuniform sampler2D u_buttons;\\nuniform sampler2D u_playN;\\nuniform sampler2D u_pauseN;\\nuniform sampler2D u_height;\\nuniform vec3 light;\\nuniform float TIME;\\nuniform bool playing;\\nuniform vec3 buttonStatus;\\nuniform float toggleStatus;\\n\\nvec3 hsv2rgb(vec3 c) {\\n    c.x = mod(c.x, 1.);\\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 hsv2rgb(float h, float s, float v) {\\n  return hsv2rgb(vec3(h, s, v));\\n}\\n\\nfloat sigmoid(float x){\\n\\treturn 1.0 / (1.0 + exp(-1.0 * x));;\\n}\\n\\nvoid main() {\\n\\tvec2 fragCoord = gl_FragCoord.xy;\\n\\tvec2 uv = fragCoord / resolution;\\n\\n\\tvec3 diffuse = texture2D(u_diffuse, uv).rgb;\\n\\tvec3 buttonLights = texture2D(u_buttons, uv).rgb;\\n\\tvec3 heightRGB = texture2D(u_height, uv).rgb;\\n\\n\\tvec3 normal = vec3(0.);\\n\\tvec3 metal = vec3(0.);\\n\\tvec3 buttons = vec3(0.);\\n\\n\\tfloat text = heightRGB.g;\\n\\tfloat height = 0.;\\n\\n\\tif(playing){\\n\\t\\tmetal = vec3(diffuse.g);\\n\\t\\tnormal = texture2D(u_playN, uv).rgb;\\n\\t\\theight = heightRGB.r;\\n\\t\\tbuttons += hsv2rgb(.33, .85, buttonLights.b * buttonStatus.b);\\n\\t}\\n\\telse{\\n\\t\\tmetal = vec3(diffuse.r);\\n\\t\\tnormal = texture2D(u_pauseN, uv).rgb;\\n\\t\\theight = heightRGB.b;\\n\\t\\tbuttons += hsv2rgb(.33, .85, buttonLights.g * buttonStatus.b);\\n\\t}\\n\\n\\tif(uv.x \u003c .5){\\n\\t\\tbuttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.r);\\n\\t}\\n\\telse{\\n\\t\\tbuttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.g);\\n\\t}\\n\\n\\t// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;\\n\\tfloat sOffset = toggleStatus + .5;\\n\\tfloat alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);\\n\\t// alpha *= ceil(height);\\n\\t// float alpha = clamp(ceil(height + heightRGB.g), 0., 1.) * (1. - toggleStatus);\\n\\tif(abs(uv.x-.5) \u003e .49){\\n\\t\\talpha = 0.;\\n\\t}\\n\\n\\tvec3 c = vec3(0.);\\n\\tif(alpha \u003e 0.){\\n\\t\\t// Phong\\n\\t\\tnormal = (normal - vec3(.5))*2.;\\n\\t\\tvec3 lp = vec3(\\n\\t\\t\\t3. * (light.x / resolution.x - .5), \\n\\t\\t\\t// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\\n\\t\\t\\t3.*(1.-light.y / resolution.y - .5)*.25, \\n\\t\\t\\t1.\\n\\t\\t);\\n\\t\\tvec3 sp = vec3(uv - vec2(.5, .5), -1.)*vec3(1., .25, 1.);\\n\\t\\tvec3 ep = vec3(.5, .5, 0.);\\n\\t\\tc = hsv2rgb(.75, .85, pow(\\n\\t\\t\\tclamp(\\n\\t\\t\\t\\tdot(\\n\\t\\t\\t\\t\\tnormalize(reflect(lp-sp, normal)), \\n\\t\\t\\t\\t\\tnormalize(sp)\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\t0., 1.\\n\\t\\t\\t),\\n\\t\\t\\t1000.\\n\\t\\t));\\n\\t}\\n\\n\\n\\tgl_FragColor = vec4(metal + buttons + c, alpha);\\n}\",\"blur.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\nuniform int pass;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\nconst float OFFSET = 0.0;\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale + OFFSET);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, texcoord);\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\nvoid main() {\\n\\tfloat sum = 0.;\\n\\n\\tconst int count = 1;\\n\\tint length = 2 * count + 1;\\n\\tfloat scale = float(length * length);\\n\\tscale = float(length);\\n\\n\\tfor(int i = -count; i \u003c= count; i++){\\n\\t\\t// for(int j = -count; j \u003c= count; j++){\\n\\t\\t\\tvec2 fragCoord = gl_FragCoord.xy + vec2(i, 0.);\\n\\t\\t\\tif(pass \u003e 0){\\n\\t\\t\\t\\tfragCoord = gl_FragCoord.xy + vec2(0., i);\\n\\t\\t\\t}\\n\\t\\t\\tvec2 uv = fragCoord / resolution;\\n\\t\\t\\tsum += extract(u_texture, uv).x / scale;\\n\\t\\t// }\\n\\t}\\n\\tgl_FragColor = pack(vec2(sum, 0.));\\n}\",\"composite.fs\":\"precision highp float;\\n\\nuniform float time;\\nuniform float saturation;\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\nuniform sampler2D u_add;\\n\\nuniform float lightHue;\\nuniform float secondLight;\\nuniform float hueShift;\\nuniform float satMult;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\nconst float OFFSET = 0.0;\\n\\nconst float PI = 3.1415926535;\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale + OFFSET);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, texcoord);\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\nvec3 hsv2rgb(vec3 c) {\\n\\tc.r = mod(c.r, 1.);\\n\\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n\\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n\\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 rgb2hsv(vec3 c)\\n{\\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n    float d = q.x - min(q.w, q.y);\\n    float e = 1.0e-10;\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\\n\\nvec3 thinfilm(float t, float x, float d){\\n\\treturn .5*(vec3(\\n\\t\\tcos( 2.*PI * (x) ),\\n\\t\\tcos( 2.*PI * 1.1 * t * (x + .0) ),\\n\\t\\tcos( 2.*PI * 1.2 * t * (x + .0) )\\n\\t) * exp(-d * t) + 1.);\\n}\\n\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tvec2 l = extract(u_texture, uv);\\n\\tfloat lh = 1. + sin(lightHue);\\n\\t//vec3 light1 = thinfilm(3.*lh, .5, .3);// 1./saturation);\\n\\tvec3 light1 = l.x * hsv2rgb(vec3(lightHue, saturation * satMult, .85));\\n\\t// vec3 light2 = l.y * thinfilm(1.-l.y, lightHue, 1./saturation);\\n\\t// light2 = vec3(0.);\\n\\tvec3 light2 = l.y * hsv2rgb(vec3(lightHue + .5, saturation * satMult, .85));\\n\\tvec3 rgb = texture2D(u_add, uv).rgb;\\n\\trgb = rgb2hsv(rgb);\\n\\trgb = hsv2rgb(rgb + vec3(hueShift, 0., 0.));\\n\\tvec3 val = light1 + secondLight * light2 + rgb;\\n\\tgl_FragColor = vec4(val, 1.);\\n\\t// gl_FragColor = vec4(light1, 1.);\\n\\t// gl_FragColor = vec4(thinfilm(uv.x*4., .8, .2), 1.);\\n}\",\"copy.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tgl_FragColor = texture2D(u_texture, uv);\\n}\",\"feedback.fs\":\"precision highp float;\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_curFrame;\\nuniform sampler2D u_prevFrame;\\nuniform float feedback1;\\nuniform float feedback2;\\nuniform float feedbackScale;\\nuniform bool HD;\\n\\nconst float BASE = 255.0;\\nconst float RANGE = BASE * BASE;\\nconst float OFFSET = 0.0;\\n\\nvec2 encode(float value) {\\n    value = floor(value * RANGE + OFFSET);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / RANGE;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, texcoord);\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\nvoid main() {\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tvec2 uvScaled = ( uv - vec2(.5) ) * feedbackScale + vec2(.5);\\n\\t// uv -= .5;\\n\\t// uv *= scale;\\n\\t// uv += .5;\\n\\tfloat prevFrame = extract(u_prevFrame, uvScaled).x;\\n\\tfloat curFrame = extract(u_curFrame, uv).x;\\n\\n\\t// float alpha = curFrame.y;\\n\\n\\t// prevFrame.a = 0.0;\\n\\n\\tfloat feedback = 0.985 + feedback1 + feedback2;\\n\\tif(!HD){\\n\\t\\tfeedback *= .998;\\n\\t}\\n      \\n\\n\\tfloat nextFrame = curFrame + feedback * prevFrame;\\n\\n\\tif(nextFrame \u003e 1.0){\\n\\t\\tnextFrame = 1.0;\\n\\t}\\n\\n\\tgl_FragColor = pack(vec2(nextFrame, 0.));\\n\\t\\n}\",\"lookup.fs\":\"precision highp float;\\n\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\nconst int numColors = 4;\\nuniform float multiplier;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\nconst float OFFSET = 0.0;\\n\\n\\nvec3 hsv2rgb(vec3 c) {\\n\\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n\\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n\\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\\n\\nvec3 hsv2rgb(float c1, float c2, float c3) {\\n\\treturn hsv2rgb(vec3(c1, c2, c3));\\n}\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, texcoord);\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\nvoid main () {\\n\\tvec3 colors[numColors];\\n\\t// colors[0] = hsv2rgb(0., 0., 0.);\\n\\t// colors[1] = hsv2rgb(.2, .6, .75);\\n\\t// colors[2] = hsv2rgb(.9, .75, .95);\\n\\t// colors[3] = hsv2rgb(.65, .9, .95);\\n\\n\\t// colors[0] = hsv2rgb(0., 0., 0.);\\n\\t// colors[1] = hsv2rgb(.02, .6, .75);\\n\\t// colors[2] = hsv2rgb(.55, .75, .95);\\n\\t// colors[3] = hsv2rgb(.25, .9, .95);\\n\\n\\tcolors[0] = hsv2rgb(0., 0., 0.);\\n\\tcolors[1] = hsv2rgb(.42, .6, .75);\\n\\tcolors[2] = hsv2rgb(.95, .75, .95);\\n\\tcolors[3] = hsv2rgb(.15, .9, .95);\\n\\n\\tfloat positions[numColors];\\n\\tpositions[0] = .001;\\n\\tpositions[1] = .15;\\n\\tpositions[2] = .4;\\n\\tpositions[3] = .999;\\n\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\tfloat val = extract(u_texture, uv).x;// * multiplier;\\n\\t// val = pow(val, .6);\\n\\n\\tvec3 color = vec3(0.);\\n\\n\\tbool found = false;\\n\\n\\tif(positions[0] \u003e val){\\n\\t\\tcolor = colors[0];\\n\\t}\\n\\telse if(positions[numColors-1] \u003c val){\\n\\t\\tcolor = colors[numColors-1];\\n\\t}\\n\\telse{\\n\\t\\tfor(int i = 1; i \u003c numColors; i++){\\n\\t\\t\\tif(positions[i] \u003e val \u0026\u0026 !found){\\n\\t\\t\\t\\tvec3 color1 = colors[i-1];\\n\\t\\t\\t\\tvec3 color2 = colors[i];\\n\\t\\t\\t\\tfloat range = positions[i] - positions[i-1];\\n\\t\\t\\t\\tfloat alpha = (val - positions[i-1]) / range;\\n\\t\\t\\t\\tcolor = alpha * color2 + (1.-alpha)*color1;\\n\\t\\t\\t\\tfound = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// color = vec3(val);\\n\\n\\t// vec3 color = hsv2rgb(vec3(val, .5, .95));\\n\\n\\tgl_FragColor = vec4(color, 1.);\\n}\",\"particlePhysics.fs\":\"precision highp float;\\n\\nvarying vec2 v_texcoord;\\nuniform vec2 resolution;\\nuniform sampler2D u_pheromones;\\nuniform sampler2D u_position;\\nuniform sampler2D u_velocity;\\nuniform int pass;\\nuniform float time;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\nconst float OFFSET = 0.0;\\nconst float PI = 3.1415926535;\\n\\nfloat atan2(in float y, in float x)\\n{\\n    float s = (abs(x) \u003e abs(y)) ? 1. : 0.;\\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\\n}\\n\\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\\n\\nfloat noise(vec3 p){\\n    vec3 a = floor(p);\\n    vec3 d = p - a;\\n    d = d * d * (3.0 - 2.0 * d);\\n\\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\\n    vec4 k1 = perm(b.xyxy);\\n    vec4 k2 = perm(k1.xyxy + b.zzww);\\n\\n    vec4 c = k2 + a.zzzz;\\n    vec4 k3 = perm(c);\\n    vec4 k4 = perm(c + 1.0);\\n\\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\\n\\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\\n\\n    return o4.y * d.y + o4.x * (1.0 - d.y);\\n}\\n\\nfloat noise(vec2 uv, float time){\\n\\treturn noise(vec3(uv, time));\\n}\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale + OFFSET);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nfloat sinh(float x){\\n\\treturn ( exp(x) - exp(-x) ) / 2.;\\n}\\n\\nfloat cosh(float x){\\n\\treturn ( exp(x) + exp(-x) ) / 2.;\\n}\\n\\nfloat tanh(float x){\\n\\treturn sinh(x) / cosh(x);\\n}\\n\\nfloat sStep(float x, int nSteps, int aI){\\n\\tfloat a = float(aI);\\n\\tx *= 2.;\\n\\tx = mod(x, 1.);\\n\\tfloat h = 1. / (.00001 + float(nSteps));\\n\\tfloat w = h;\\n\\t// return 1. - abs(1. - h * (\\n\\t// \\t1./(2.*tanh(a/2.)) * tanh(\\n\\t// \\t\\ta * (fract(x/w)-0.5)\\n\\t// \\t) + .5 + floor(x/w)\\n\\t// ));\\n\\treturn 1. - abs(\\n\\t\\t1. - h * (\\n\\t\\t\\t.5 / tanh(a/2.) * tanh(\\n\\t\\t\\t\\ta * (\\n\\t\\t\\t\\t\\t(x/w - floor(x/w)) - 0.5)\\n\\t\\t\\t\\t) + .5 + floor(x/w)\\n\\t\\t\\t)\\n\\t\\t);\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, mod(texcoord, 1.));\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\nvec2 n2rand(float mult) {\\n\\treturn vec2(\\n\\t\\tfract(sin(dot(v_texcoord.xy * mult, vec2(12.9898, 78.233))) * 43758.5453),\\n\\t\\tfract(sin(dot(v_texcoord.xy * 1.61803 * mult, vec2(12.9898, 78.233))) * 43758.5453)\\n\\t);\\n}\\n\\nvec2 n2rand() {\\n\\treturn n2rand(1.);\\n}\\n\\nvec2 unitCircle(float angle){\\n\\treturn vec2( cos(angle), sin(angle) );\\n}\\n\\nvec2 unitCircleDeg(float angle){\\n\\treturn unitCircle(PI*angle/180.0);\\n}\\n\\nvoid main() {\\n\\tfloat maxVel = 1.8 + .45 * sin(time*3.111) +  + .9 * cos(time*.411);\\n\\tif(pass == 0){\\n\\t\\tvec2 r, d, a, x, v;\\n\\n\\t\\tvec2 velOut, posOut;\\n\\n\\t\\tx = extract(u_position, v_texcoord);\\n\\t\\tv = extract(u_velocity, v_texcoord);\\n\\n\\t\\tvelOut = (2. * v - 1.);\\n\\n\\t\\tvec2 uv = x;\\n\\n\\t\\tfloat velMult = 1.;\\n\\n\\t\\t// sin(time*1.63)*\\n\\t\\tfloat sensorDist = 33. + 32.*(pow(noise(\\n\\t\\t\\tuv * sStep(.0173*time, 12, 1) * 6., \\n\\t\\t\\ttime * .43752\\n\\t\\t), 1.) *2. - 1.);\\n\\n\\t\\t// sensorDist = 30.;\\n\\n\\t\\t// sensorDist = 30.;\\n\\n\\t\\t// float sensorDist2 = 15. + 14.*(pow(noise(vec3(\\n\\t\\t// \\tuv * 1.*(1. + cos(time * 3.21334)), \\n\\t\\t// \\ttime * 15.232)\\n\\t\\t// ), 2.) *2. - 1.);\\n\\n\\t\\t// float sensorDist3 = 70. + 69.*(pow(noise(vec3(\\n\\t\\t// \\tuv * 15.*(1. + cos(time * 1.21334)), \\n\\t\\t// \\ttime * 5.232)\\n\\t\\t// ), 2.) *2. - 1.);\\n\\t\\tfloat multy = sStep(.773*time, 10, 4) * 3. + 1.;\\n\\t\\t// multy = 3.;\\n\\t\\t// multy = pow(noise(uv * 1., time * .122), 2.) * 3. + 1.;\\n\\t\\tfloat sensorDist2 = sensorDist / multy;\\n\\t\\tfloat sensorDist3 = sensorDist * multy;\\n\\n\\t\\t// float degTurn = 1.// + 8.2*(sin(time*1.512)+1.)/2.567;\\n\\t\\t// + 5.*(pow(noise(\\n\\t\\t// \\tuv*(2. + 3.5*sin(time*1.885)), \\n\\t\\t// \\ttime*0.7112\\n\\t\\t// ) * 2. - 1., 33.));\\n\\n\\t\\tfloat degTurn = 20.*(2. + sin(time*.1347))*sStep(\\n\\t\\t\\tnoise(\\n\\t\\t\\t\\tuv*(sStep(time*.07742, 10, 4)*3.), \\n\\t\\t\\t\\t.2144*time\\n\\t\\t\\t),\\n\\t\\t10, 6);\\n\\n\\t\\tfloat randAngle = 90.*sStep(\\n\\t\\t\\tnoise(\\n\\t\\t\\t\\tuv*(1. + sStep(time*.06342, 10, 2)*4.),\\n\\t\\t\\t\\t.5131*time\\n\\t\\t\\t),\\n\\t\\t16, 6);\\n\\t\\t// randAngle = degTurn;\\n\\n\\t\\t// + 8.2*(sin(time*5.12)+1.)/2.56;\\n\\t\\tdegTurn = radians(degTurn);\\n\\t\\trandAngle = radians(randAngle);\\n\\n\\t\\tfloat degRange = degTurn * sStep(.0143*time, 4, 4);\\n\\n\\t\\t// float degRange = 180.*sStep(300.*time, 8, 100);\\n\\t\\t// degRange = radians(degRange);\\n\\n\\t\\tfloat curSensor = extract(u_pheromones, uv).r * 4. * (1.5+sin(time / 3.12));\\n\\n\\t\\tfloat degMulty= 1.5 * 2.-curSensor;\\n\\t\\tfloat velMulty = 1.2 * curSensor;\\n\\t\\tdegRange *= curSensor;\\n\\t\\trandAngle *= curSensor * sin(time / 1.12);\\n\\t\\tdegTurn *= 1.1 + sin(curSensor / 3.3);\\n\\t\\tsensorDist *= pow(curSensor, 1.+sin(time*2.114));\\n\\t\\tsensorDist2 *= curSensor;\\n\\t\\tsensorDist3 *= curSensor;\\n\\n\\t\\tfloat velAngle = atan2(velOut.y, velOut.x);\\n\\n\\t\\tvec2 sensorDistScaled = sensorDist / resolution;\\n\\t\\tvec2 sensorDistScaled2 = sensorDist2 / resolution;\\n\\t\\tvec2 sensorDistScaled3 = sensorDist3 / resolution;\\n\\n\\n\\t\\tvec2 fSensorOffset = sensorDistScaled * unitCircle(velAngle);\\n\\t\\tvec2 lSensorOffset = sensorDistScaled * unitCircle(velAngle + degRange);\\n\\t\\tvec2 rSensorOffset = sensorDistScaled * unitCircle(velAngle - degRange);\\n\\n\\t\\tfloat fSensor = extract(u_pheromones, uv + fSensorOffset).r;\\n\\t\\tfloat lSensor = extract(u_pheromones, uv + lSensorOffset).r;\\n\\t\\tfloat rSensor = extract(u_pheromones, uv + rSensorOffset).r;\\n\\n\\n\\t\\t// vec2 fSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle);\\n\\t\\t// vec2 lSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle + degRange/degMulty);\\n\\t\\t// vec2 rSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle - degRange/degMulty);\\n\\n\\t\\t// float fSensor2 = extract(u_pheromones, uv + fSensorOffset2).r;\\n\\t\\t// float lSensor2 = extract(u_pheromones, uv + lSensorOffset2).r;\\n\\t\\t// float rSensor2 = extract(u_pheromones, uv + rSensorOffset2).r;\\n\\n\\n\\t\\t// vec2 fSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle);\\n\\t\\t// vec2 lSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle + degRange*degMulty);\\n\\t\\t// vec2 rSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle - degRange*degMulty);\\n\\n\\t\\t// float fSensor3 = extract(u_pheromones, uv + fSensorOffset3).r;\\n\\t\\t// float lSensor3 = extract(u_pheromones, uv + lSensorOffset3).r;\\n\\t\\t// float rSensor3 = extract(u_pheromones, uv + rSensorOffset3).r;\\n\\n\\n\\t\\t// // fSensor3 = 0.;\\n\\t\\t// // lSensor3 = 0.;\\n\\t\\t// // rSensor3 = 0.;\\n\\n\\t\\t// fSensor = max(max(fSensor, fSensor2), fSensor3);\\n\\t\\t// lSensor = max(max(lSensor, lSensor2), lSensor3);\\n\\t\\t// rSensor = max(max(rSensor, rSensor2), rSensor3);\\n\\n\\t\\tfloat lrDiff = abs(lSensor - rSensor);\\n\\t\\tlrDiff *= 3.;\\n\\t\\tlrDiff = 1. / (lrDiff + 2.1);\\n\\n\\n\\t\\tif(fSensor \u003e= lSensor \u0026\u0026 fSensor \u003e= rSensor){\\n\\t\\t\\tvelOut = unitCircle(velAngle) * lrDiff;\\n\\t\\t}\\n\\t\\tif(lSensor \u003e= fSensor \u0026\u0026 lSensor \u003e= rSensor){\\n\\t\\t\\t// if(lSensor == lSensor2){\\n\\t\\t\\t// \\tdegTurn /= degMulty;\\n\\t\\t\\t// \\tvelMult *= velMulty;\\n\\t\\t\\t// }\\n\\t\\t\\t// else if(lSensor == lSensor3){\\n\\t\\t\\t// \\tdegTurn *= degMulty;\\n\\t\\t\\t// \\tvelMult /= velMulty;\\n\\t\\t\\t// }\\n\\t\\t\\tvelOut = unitCircle(velAngle + degTurn) * lrDiff;\\n\\t\\t}\\n\\t\\telse if(rSensor \u003e= lSensor \u0026\u0026 rSensor \u003e= fSensor){\\n\\t\\t\\t// if(rSensor == rSensor2){\\n\\t\\t\\t// \\tdegTurn /= degMulty;\\n\\t\\t\\t// \\tvelMult *= velMulty;\\n\\t\\t\\t// }\\n\\t\\t\\t// else if(rSensor == rSensor3){\\n\\t\\t\\t// \\tdegTurn *= degMulty;\\n\\t\\t\\t// \\tvelMult /= velMulty;\\n\\t\\t\\t// }\\n\\t\\t\\tvelOut = unitCircle(velAngle - degTurn) * lrDiff;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t//   float randVal = n2rand();\\n\\t\\t\\tfloat rNum = sin(5000000.*time*n2rand(time*10.).r);\\n\\t\\t\\trNum = n2rand(time*10.).r - .5;\\n\\n\\t\\t\\t\\t// float curVal = texture2D(u_pheromones, uv).r;\\n\\t\\t\\t //  velOut = unitCircle(velAngle + fSensor * degTurn * sin(time));\\n\\t\\t\\t if(rNum \u003e 0.){\\n\\t\\t\\t \\tvelOut = unitCircle(velAngle - randAngle) * .9;\\n\\t\\t\\t }\\n\\t\\t\\t else{\\n\\t\\t\\t \\tvelOut = unitCircle(velAngle + randAngle) * .9;\\n\\t\\t\\t }\\n\\n\\t\\t\\t // velOut = vec2(0.);\\n\\n\\t\\t\\t // velOut = unitCircle(velAngle + 8. * sin(time*2.997));\\n\\t\\t  // velOut = rNum;\\n\\t\\t}\\n\\n\\t\\t// velOut -= vec2(.75, 0.);\\n\\n\\t\\t// posOut += velOut;\\n\\t\\tvelOut *= noise(vec3(uv * 3.* (1.1 + sin(time*.11325)), time*1.113)) * .5 + .5;\\n\\t\\tvelOut *= velMult;// * 2.;\\n\\t\\tv = (velOut + vec2(1.)) / 2.;\\n\\n\\t\\t\\n\\n\\t\\tgl_FragColor = pack(v);\\n\\t}\\n\\tif(pass == 1){\\n\\t\\tvec2 x = extract(u_position, v_texcoord);\\n\\t\\tvec2 v = extract(u_velocity, v_texcoord);\\n\\n\\t\\tfloat lenX = pow(smoothstep(0., .5, length(x-.5)), 4.) * .8;\\n\\n\\t\\tv = 2. * v - vec2(1.);\\n\\t\\t// v = -.3 * (1. - lenX) * x ;//+ lenX * v;\\n\\t\\t// v = -lenX * (x - .5) * .3 + (1.-lenX)*v;\\n\\t\\tx += v * maxVel / resolution;\\n\\n\\n\\t\\t// if(length(x -.5 + .1*unitCircle(n2rand().r * 22.*PI)) \u003e .42){\\n\\t\\t// \\tx = vec2(0.5) + .25 * unitCircle(n2rand().x*200.) + .1 * unitCircle((n2rand().y*500.));\\n\\t\\t// }\\n\\n\\t\\tx = mod(x, 1.);\\n\\n\\t\\tgl_FragColor = pack(x);\\n\\t\\t// gl_FragColor = pack(x);\\n\\t\\t// gl_FragColor = texture2D(u_position, v_texcoord);\\n\\t}\\n}\",\"particlePhysics.vs\":\"precision mediump float;\\n\\nattribute vec2 position;\\nvarying vec2 v_texcoord;\\n\\nvoid main() {\\n\\tv_texcoord = 0.5 * position + 0.5;\\n\\t// v_texcoord = position;\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n}\",\"phong.fs\":\"\\nprecision highp float;\\n\\n\\nuniform vec2 resolution;\\nuniform sampler2D u_texture;\\n\\nuniform float intensity;\\n\\nuniform vec2 lightXY;\\nuniform float specularHardness;\\nuniform float specularPower;\\nuniform float diffusePower;\\nuniform vec3 viewDir;\\n\\nconst float BASE = 255.0;\\nconst float scale = BASE * BASE;\\nconst float OFFSET = 0.0;\\n\\nvec2 encode(float value) {\\n    value = floor(value * scale + OFFSET);\\n    float x = mod(value, BASE);\\n    float y = floor(value / BASE);\\n    return vec2(x, y) / BASE;\\n}\\n\\nvec4 pack(vec2 value){\\n\\treturn vec4(encode(value.x), encode(value.y));\\n}\\n\\nfloat decode(vec2 channels) {\\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\\n}\\n\\nvec2 extract(sampler2D tex, vec2 texcoord){\\n\\tvec4 valueRAW = texture2D(tex, texcoord);\\n\\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\\n}\\n\\n\\nfloat luminance(vec3 c)\\n{\\n\\treturn dot(c, vec3(.2126, .7152, .0722));\\n}\\n\\nvec2 pixelOffset(vec2 offset){\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\treturn extract(u_texture, uv + offset);\\n}\\n\\nvec3 calcNormal()\\n{\\n\\tvec2 yOffset = vec2(0., 1. / resolution.s);\\n\\tvec2 xOffset = vec2(1. / resolution.t, 0.);\\n\\tfloat R = abs(pixelOffset(xOffset).x );\\n\\tfloat L = abs(pixelOffset(-xOffset).x );\\n\\tfloat U = abs(pixelOffset(yOffset).x );\\n\\tfloat D = abs(pixelOffset(-yOffset).x );\\n\\t\\t\\t\\t \\n\\tfloat X = (L-R) * .5;\\n\\tfloat Y = (U-D) * .5;\\n\\n\\treturn normalize(vec3(X, Y, 1. / intensity));\\n}\\n\\nvoid main()\\n{\\n\\tvec3 n = calcNormal();\\n\\n\\tvec2 uv = gl_FragCoord.xy / resolution;\\n\\n\\tvec3 lp1 = vec3(lightXY, 2.) + vec3(.5, .5, 0.);\\n\\tvec3 lp2 = vec3(-lightXY, 2.) + vec3(.5, .5, 0.);\\n\\n\\tvec3 sp = vec3(uv, -1.);\\n\\t\\n\\tvec3 c1 = diffusePower*vec3(dot(n, normalize(lp1 - sp)));\\n\\tvec3 c2 = diffusePower*vec3(dot(n, normalize(lp2 - sp)));\\n\\t\\n    vec3 ep = vec3(.5, .5, 0.);\\n\\tc1 += specularPower*pow(clamp(dot(normalize(reflect(lp1 - sp, n)), \\n\\t\\t\\t\\t\\t   normalize(sp - ep)), 0., 1.), specularHardness);\\n\\tc2 += specularPower*pow(clamp(dot(normalize(reflect(lp2 - sp, n)), \\n\\t\\t\\t\\t\\t   normalize(sp - ep)), 0., 1.), specularHardness);\\n\\n\\tfloat mult = sqrt(extract(u_texture, uv).r);\\n\\tgl_FragColor = pack(vec2(c1.r*mult, c2.r*mult));\\n\\t// gl_FragColor = vec4(c, 1.);\\n}\\n\",\"yinyang.fs\":\"\\nprecision mediump float;\\n\\nuniform float TIME;\\nuniform float swirl;\\nuniform float border;\\nuniform int depth;\\nuniform vec2 resolution;\\n\\nvec2 rotateLoc(vec2 loc, float angle){\\n\\tfloat oAngle = atan(loc.y, loc.x);\\n\\tfloat nAngle = oAngle + angle / 180.0 * 3.1415926535;\\n\\tvec2 rotated = length(loc) * vec2(cos(nAngle), sin(nAngle));\\n\\treturn rotated;\\t\\n}\\n\\nfloat negOnePow(int power){\\n\\tif(int(mod(float(power), 2.)) == 0){\\n\\t\\treturn 1.;\\n\\t}\\n\\treturn -1.;\\n}\\n\\nint getColVal(vec2 loc, int level, float rotate){\\n\\tfloat levelVal = .5*pow(.25, float(level));\\n\\tfloat radVal = pow(.5, float(level));\\n\\t\\n\\tvec2 newLoc = rotateLoc(loc, rotate);\\n\\tvec2 modLocW = newLoc + vec2(0., levelVal);\\n    vec2 modLocB = newLoc - vec2(0., levelVal);\\n    // top circle\\n    if(length(modLocB) \u003c levelVal){\\n    \\tif(level == depth){\\n    \\t\\tif(length(modLocB) \u003c levelVal/3.){\\n    \\t\\t\\treturn 2;\\n    \\t\\t}\\n    \\t}\\n    \\treturn 1;\\n    }\\n    // bottom circle\\n    else if(length(modLocW) \u003c levelVal){\\n    if(level == depth){\\n    \\t\\tif(length(modLocW) \u003c levelVal/3.){\\n    \\t\\t\\treturn 1;\\n    \\t\\t}\\n    \\t}\\n    \\treturn 2;\\n    }\\n    // left half\\n    else if(length(loc) \u003c radVal \u0026\u0026 newLoc.x \u003e 0.){\\n    \\treturn 3;\\n    }\\n    // right half\\n    else if(length(loc) \u003c radVal){\\n    \\treturn 4;\\n    }\\n}\\n\\nvec4 getYinYang(vec2 offset){\\n    vec2 uv = (gl_FragCoord.xy + offset) / resolution;\\n\\n    vec4 color = vec4(0.0);\\n    \\n    vec2 loc = 2.*(uv - vec2(.5));\\n    vec2 ogLoc = vec2(loc);\\n    loc *= 1. + border;\\n    int colVal = 0;\\n    \\n    // vec2 ogLoc = vec2(loc);\\n   \\n    \\n    colVal = getColVal(loc, 0, TIME);\\n    loc = rotateLoc(loc, TIME);\\n   \\n    \\n    float multFac = .125;\\n    float sumVal = 0.;\\n    for(int i = 0; i \u003c 16; i++){\\n        if (i \u003e= depth){break;}\\n        if(colVal \u003e 0 \u0026\u0026 colVal \u003c 3){\\n            sumVal /= 2.;\\n            if(i \u003e 0){\\n                sumVal += multFac*pow(.25, float(i-1));\\n            }\\n            loc = 0.5*(loc-loc.y/abs(loc.y)*vec2(0.,pow(.5, float(i+1)))  - negOnePow(colVal)*vec2(0.,sumVal));\\n            colVal = getColVal(loc, i+1, pow(swirl, float(i+3))*TIME);\\n            loc = rotateLoc(loc, pow(swirl, float(i+3))*TIME);\\n        }\\n    }\\n    \\n    \\n    \\n    \\n    if(colVal == 1){\\n        color = vec4(1.0); //white\\n    }\\n    else if(colVal == 2){\\n        color = vec4(1., 0., 0., 1.); //red\\n        color = vec4(0., 0., 0., 1.);\\n    }\\n    else if(colVal == 3){\\n        color = vec4(0., 1., 0., 1.); //green\\n        color = vec4(0., 0., 0., 1.);\\n    }\\n    else if(colVal == 4){\\n        color = vec4(0., 0., 1., 1.); //blue\\n        color = vec4(1.);\\n    }\\n    else {\\n        color = vec4(0.);\\n    }\\n\\n    if(length(ogLoc) \u003e= 1.){\\n        color = vec4(0.);\\n    }\\n    else if(length(ogLoc) \u003e= 1./(1.+border)){\\n        color = vec4(0., 0., 0., 1.);\\n        color = vec4(1.);\\n    }\\n\\n    return color;\\n}\\n\\nvoid main()\\n{\\n    vec4 color = vec4(0.);\\n\\n    for(int i = 0; i \u003c 2; i++){\\n        for(int j = 0; j \u003c 2; j++){\\n            vec2 boi = vec2(float(i)-.5, float(j)-.5)/2.;\\n            color += getYinYang(boi)/4.;\\n        }\\n    }\\n\\n    // color = getYinYang(vec2(0.));\\n    \\n    gl_FragColor = color;\\n}\\n\"},\"imgs\":{\"hdri.jpg\":\"/media/tex/hdri.jpg\",\"media player buttons.jpg\":\"/media/tex/media player buttons.jpg\",\"media player diffuse.jpg\":\"/media/tex/media player diffuse.jpg\",\"media player height.jpg\":\"/media/tex/media player height.jpg\",\"media player lights.jpg\":\"/media/tex/media player lights.jpg\",\"media player pause N.jpg\":\"/media/tex/media player pause N.jpg\",\"media player play N.jpg\":\"/media/tex/media player play N.jpg\",\"mini player buttons.jpg\":\"/media/tex/mini player buttons.jpg\",\"mini player diffuse.jpg\":\"/media/tex/mini player diffuse.jpg\",\"mini player height.jpg\":\"/media/tex/mini player height.jpg\",\"mini player lights.jpg\":\"/media/tex/mini player lights.jpg\",\"mini player pause N.jpg\":\"/media/tex/mini player pause N.jpg\",\"mini player play N.jpg\":\"/media/tex/mini player play N.jpg\",\"pebbles.png\":\"/media/tex/pebbles.png\",\"rand.png\":\"/media/tex/rand.png\",\"x N.jpg\":\"/media/tex/x N.jpg\",\"x.jpg\":\"/media/tex/x.jpg\"}}}]\n"])</script><script>self.__next_f.push([1,"8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n6:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Portal\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Web Portal for Shaders\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"any\"}]]\n"])</script></body></html>