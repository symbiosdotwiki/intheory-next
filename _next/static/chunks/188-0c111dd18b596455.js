(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[188],{5284:function(e,n,t){var r={"./Ensemble.js":3678,"./EnsembleSeq.js":9574,"./Hoping.js":4117,"./Memory.js":6338,"./MemorySeq.js":4068,"./Origin.js":1900,"./OriginSeq.js":6970,"./Wavelet.js":519,"./WaveletSeq.js":9946,"src/app/Tracks/Ensemble.js":3678,"src/app/Tracks/EnsembleSeq.js":9574,"src/app/Tracks/Hoping.js":4117,"src/app/Tracks/Memory.js":6338,"src/app/Tracks/MemorySeq.js":4068,"src/app/Tracks/Origin.js":1900,"src/app/Tracks/OriginSeq.js":6970,"src/app/Tracks/Wavelet.js":519,"src/app/Tracks/WaveletSeq.js":9946};function o(e){return t(a(e))}function a(e){if(!t.o(r,e)){var n=Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=a,e.exports=o,o.id=5284},4110:function(e,n,t){var r={"./default/add.fs":9450,"./default/black.fs":3238,"./default/circle.fs":2752,"./default/default.fs":9899,"./default/default.vs":6977,"./default/random.fs":2546,"./ensemble/blur.fs":8662,"./ensemble/composite.fs":6589,"./ensemble/decode.fs":8934,"./ensemble/encode.fs":1858,"./ensemble/feedback.fs":6476,"./ensemble/lookup.fs":8151,"./ensemble/particleDraw.fs":4589,"./ensemble/particleDraw.vs":4197,"./ensemble/particleInit.fs":7266,"./ensemble/particleInit.vs":3368,"./ensemble/particlePhysics.fs":2566,"./ensemble/particlePhysics.vs":2419,"./ensemble/phong.fs":2686,"./hoping/skin.fs":9393,"./media/mediaToggle.fs":7397,"./media/mediaplayer.fs":6940,"./media/miniplayer.fs":5898,"./media/yinyang.fs":4723,"./memory/memory.fs":9567,"./origin/blackhole.fs":5666,"./origin/life.fs":9976,"./wavelet/audio.vs":6355,"./wavelet/aurora.fs":4290,"./wavelet/wavelet.fs":9315};function o(e){return t(a(e))}function a(e){if(!t.o(r,e)){var n=Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return r[e]}o.keys=function(){return Object.keys(r)},o.resolve=a,e.exports=o,o.id=4110},9450:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution1;\nuniform vec2 resolution2;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n	vec2 uv1 = gl_FragCoord.xy / resolution1;\n	vec2 uv2 = gl_FragCoord.xy / resolution1;\n	gl_FragColor = texture2D(tex1, uv1) + texture2D(tex2, uv2);\n}"},3238:function(e){"use strict";e.exports="precision mediump float;\n\nvoid main() {\n	gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}"},2752:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\n// uniform vec2 center;\nuniform float radius;\nuniform sampler2D rand;\nuniform sampler2D pebbles;\nuniform float iTime;\n\nconst vec2 zOffset = vec2(37.0,17.0);\nconst vec2 wOffset = vec2(59.0,83.0);\n\nvec4 texNoise(vec2 uv)   // Emulate a single texture fetch into the precalculated texture\n{\n    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.\n    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.\n    float r = texture2D( rand, mod((uv+0.5)/256.0, 1.)).r;\n    float g = texture2D( rand, mod((uv+0.5 + zOffset)/256.0, 1.)).r;\n    float b = texture2D( rand, mod((uv+0.5 + wOffset)/256.0, 1.)).r;\n    float a = texture2D( rand, mod((uv+0.5 + zOffset + wOffset)/256.0, 1.)).r;\n    \n    return vec4(r, g, b, a);\n}\n\n\nfloat noise4dFast( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;\n    \n    vec4 s = texNoise(uv);\n    return mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);\n}\n\nvoid main() {\n	vec2 uv = 2.*(gl_FragCoord.xy / resolution - vec2(.5));\n	vec4 col = vec4(vec3(0.), 1.);\n\n	vec2 center = vec2(0.);\n	center.x = 1.6 * noise4dFast(vec4(vec3(0.), iTime / 3. + 0.)) - .8;\n	center.y = 1.6 * noise4dFast(vec4(iTime / 3. + 9999., vec3(0.))) - .8;\n\n	if(length(uv-center)<radius){\n		col.xyz = texture2D(pebbles, (uv-center) / radius).rgb;\n	}\n	gl_FragColor = col;\n}"},9899:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nvoid main() {\n	vec2 uv = gl_FragCoord.xy / resolution;\n	gl_FragColor = texture2D(u_texture, uv);\n}"},6977:function(e){"use strict";e.exports="attribute vec4 position;\n\nvoid main() {\n	gl_Position = position;\n}"},2546:function(e){"use strict";e.exports="precision highp float;\n\nfloat hash1( float n ){\n    return fract(sin(n)*138.5453123);\n}\n\nfloat random (vec2 st) {\n    return step(0.5, hash1(st.x*13.0+hash1(st.y*71.1)));\n}\n\nvoid main() {\n	float random = random(gl_FragCoord.xy/1000.);\n	gl_FragColor = vec4(random, random, random, 1.);\n}"},8662:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nuniform int pass;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n	vec4 valueRAW = texture2D(tex, texcoord);\n	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main() {\n	float sum = 0.;\n\n	const int count = 1;\n	int length = 2 * count + 1;\n	float scale = float(length * length);\n	scale = float(length);\n\n	for(int i = -count; i <= count; i++){\n		// for(int j = -count; j <= count; j++){\n			vec2 fragCoord = gl_FragCoord.xy + vec2(i, 0.);\n			if(pass > 0){\n				fragCoord = gl_FragCoord.xy + vec2(0., i);\n			}\n			vec2 uv = fragCoord / resolution;\n			sum += extract(u_texture, uv).x / scale;\n		// }\n	}\n	gl_FragColor = pack(vec2(sum, 0.));\n}"},6589:function(e){"use strict";e.exports="precision highp float;\n\nuniform float time;\nuniform float saturation;\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nuniform sampler2D u_add;\n\nuniform float lightHue;\nuniform float secondLight;\nuniform float hueShift;\nuniform float satMult;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\nconst float PI = 3.1415926535;\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n	vec4 valueRAW = texture2D(tex, texcoord);\n	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvec3 hsv2rgb(vec3 c) {\n	c.r = mod(c.r, 1.);\n	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 thinfilm(float t, float x, float d){\n	return .5*(vec3(\n		cos( 2.*PI * (x) ),\n		cos( 2.*PI * 1.1 * t * (x + .0) ),\n		cos( 2.*PI * 1.2 * t * (x + .0) )\n	) * exp(-d * t) + 1.);\n}\n\n\nvoid main() {\n	vec2 uv = gl_FragCoord.xy / resolution;\n	vec2 l = extract(u_texture, uv);\n	float lh = 1. + sin(lightHue);\n\n	vec3 tf = vec3(\n		sin(lightHue * 2. * PI),\n		sin(lightHue * 2.1 * PI + .5), \n		sin(lightHue * 2.3 * PI + 1.)\n	);\n	lh = rgb2hsv(tf).x;\n\n	//vec3 light1 = thinfilm(3.*lh, .5, .3);// 1./saturation);\n	vec3 light1 = l.x * hsv2rgb(vec3(lh, saturation * satMult, .85));\n	// vec3 light2 = l.y * thinfilm(1.-l.y, lightHue, 1./saturation);\n	// light2 = vec3(0.);\n	vec3 light2 = l.y * hsv2rgb(vec3(lh + .5, saturation * satMult, .85));\n	vec3 rgb = texture2D(u_add, uv).rgb;\n	// rgb = rgb2hsv(rgb);\n	// rgb = hsv2rgb(rgb + vec3(hueShift, 0., 0.));\n	vec3 val = light1 + secondLight * light2 + rgb;\n	gl_FragColor = vec4(val, 1.);\n	// gl_FragColor = vec4(light1, 1.);\n	// gl_FragColor = vec4(thinfilm(uv.x*4., .8, .2), 1.);\n}"},8934:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n	vec4 valueRAW = texture2D(tex, texcoord);\n	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main() {\n	vec2 uv = gl_FragCoord.xy / resolution;\n	vec2 val = extract(u_texture, uv);\n	gl_FragColor = vec4(val.x, val.x, val.x, 1.);\n}"},1858:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nvec2 encode(float value) {\n    value = floor(value * scale);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nvoid main() {\n	vec2 uv = gl_FragCoord.xy / resolution;\n	vec4 val = texture2D(u_texture, uv);\n	gl_FragColor = pack(vec2(val.r * val.a));\n}"},6476:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_curFrame;\nuniform sampler2D u_prevFrame;\nuniform float feedback1;\nuniform float feedback2;\nuniform float feedbackScale;\nuniform bool HD;\n\nconst float BASE = 255.0;\nconst float RANGE = BASE * BASE;\nconst float OFFSET = 0.0;\n\nvec2 encode(float value) {\n    value = floor(value * RANGE + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / RANGE;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n	vec4 valueRAW = texture2D(tex, texcoord);\n	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main() {\n	vec2 uv = gl_FragCoord.xy / resolution;\n	vec2 uvScaled = ( uv - vec2(.5) ) * feedbackScale + vec2(.5);\n	// uv -= .5;\n	// uv *= scale;\n	// uv += .5;\n	float prevFrame = extract(u_prevFrame, uvScaled).x;\n	float curFrame = extract(u_curFrame, uv).x;\n\n	// float alpha = curFrame.y;\n\n	// prevFrame.a = 0.0;\n\n	float feedback = 0.985 + feedback1 + feedback2;\n	if(!HD){\n		feedback *= .998;\n	}\n      \n\n	float nextFrame = curFrame + feedback * prevFrame;\n\n	if(nextFrame > 1.0){\n		nextFrame = 1.0;\n	}\n\n	gl_FragColor = pack(vec2(nextFrame, 0.));\n	\n}"},8151:function(e){"use strict";e.exports="precision highp float;\n\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nconst int numColors = 4;\nuniform float multiplier;\nuniform float hueShift;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\nconst float PI = 3.1415926535897;\n\n\nvec3 hsv2rgb(vec3 c) {\n	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float c1, float c2, float c3) {\n	return hsv2rgb(vec3(c1, c2, c3));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n	vec4 valueRAW = texture2D(tex, texcoord);\n	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main () {\n	vec3 colors[numColors];\n	// colors[0] = hsv2rgb(0., 0., 0.);\n	// colors[1] = hsv2rgb(.2, .6, .75);\n	// colors[2] = hsv2rgb(.9, .75, .95);\n	// colors[3] = hsv2rgb(.65, .9, .95);\n\n	// colors[0] = hsv2rgb(0., 0., 0.);\n	// colors[1] = hsv2rgb(.02, .6, .75);\n	// colors[2] = hsv2rgb(.55, .75, .95);\n	// colors[3] = hsv2rgb(.25, .9, .95);\n\n	colors[0] = hsv2rgb(0. + sin(hueShift * 1. * PI) + hueShift, 0., 0.);\n	colors[1] = hsv2rgb(.42 - sin(hueShift * 2. * PI), .6, .75);\n	colors[2] = hsv2rgb(.95 + 1.5*sin(hueShift * 1. * PI) + hueShift, .75, .95);\n	colors[3] = hsv2rgb(.15 + 2.*sin(hueShift * 2. * PI), .9, .95);\n\n	float positions[numColors];\n	positions[0] = .001;\n	positions[1] = .15;\n	positions[2] = .4;\n	positions[3] = .999;\n\n	vec2 uv = gl_FragCoord.xy / resolution;\n	float val = extract(u_texture, uv).x;// * multiplier;\n	// val = pow(val, .6);\n\n	vec3 color = vec3(0.);\n\n	bool found = false;\n\n	if(positions[0] > val){\n		color = colors[0];\n	}\n	else if(positions[numColors-1] < val){\n		color = colors[numColors-1];\n	}\n	else{\n		for(int i = 1; i < numColors; i++){\n			if(positions[i] > val && !found){\n				vec3 color1 = colors[i-1];\n				vec3 color2 = colors[i];\n				float range = positions[i] - positions[i-1];\n				float alpha = (val - positions[i-1]) / range;\n				color = alpha * color2 + (1.-alpha)*color1;\n				found = true;\n			}\n		}\n	}\n\n	// color = vec3(val);\n\n	// vec3 color = hsv2rgb(vec3(val, .5, .95));\n\n	gl_FragColor = vec4(color, 1.);\n}"},4589:function(e){"use strict";e.exports="precision highp float;\nvarying vec3 color;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nuniform float HD;\n\nvec2 encode(float value) {\n    value = floor(value * scale);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nvoid main () {\n	gl_FragColor = pack(vec2(HD > .5 ? .02 : .02,.13));\n}"},4197:function(e){"use strict";e.exports="precision highp float;\n\nattribute vec2 v_texcoord;\nattribute vec2 position;\n\nuniform sampler2D u_texture;\nvarying vec3 color;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\n// vec3 hsv2rgb(vec3 c) {\n// 	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n// 	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n// 	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n// }\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\n}\n\nvec2 extract(sampler2D tex){\n	vec4 valueRAW = texture2D(tex, position);\n	return vec2(decode(valueRAW.xy), decode(valueRAW.zw));\n}\n\nvoid main () {\n	vec2 pos = extract(u_texture);\n	// color = hsv2rgb(vec3(0.5 * v_texcoord + 0.4, 0.9)) * .1;\n	gl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);\n	gl_PointSize = .5;\n}"},7266:function(e){"use strict";e.exports="precision highp float;\nuniform int pass;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nvec2 encode(float value) {\n    value = value * scale;\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nvec2 n2rand() {\n	return vec2(\n		fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453),\n  		fract(sin(dot(gl_FragCoord.xy * 1.61803, vec2(12.9898, 78.233))) * 43758.5453)\n  	);\n}\n\nvoid main() {\n			vec2 pos_rand = n2rand() - .5;\n	if(pass == 0){\n		gl_FragColor = pack(.5 + pos_rand );// + vec4(n2rand(), -1., -1.);\n	}\n	else{\n		gl_FragColor = pack(2.*pos_rand);\n	}\n}"},3368:function(e){"use strict";e.exports="precision mediump float;\nattribute vec2 position;\n\nvoid main() {\n	gl_Position = vec4(position, 0.0, 1.0);\n}"},2566:function(e){"use strict";e.exports="precision highp float;\n\nvarying vec2 v_texcoord;\nuniform vec2 resolution;\nuniform sampler2D u_pheromones;\nuniform sampler2D u_position;\nuniform sampler2D u_velocity;\nuniform int pass;\nuniform float time;\nuniform vec3 lmh;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\nconst float PI = 3.1415926535;\n\nfloat atan2(in float y, in float x)\n{\n    float s = (abs(x) > abs(y)) ? 1. : 0.;\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat noise(vec2 uv, float time){\n	return noise(vec3(uv, time));\n}\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nfloat sinh(float x){\n	return ( exp(x) - exp(-x) ) / 2.;\n}\n\nfloat cosh(float x){\n	return ( exp(x) + exp(-x) ) / 2.;\n}\n\nfloat tanh(float x){\n	return sinh(x) / cosh(x);\n}\n\nfloat sStep(float x, int nSteps, int aI){\n	float a = float(aI);\n	x *= 2.;\n	x = mod(x, 1.);\n	float h = 1. / (.00001 + float(nSteps));\n	float w = h;\n	// return 1. - abs(1. - h * (\n	// 	1./(2.*tanh(a/2.)) * tanh(\n	// 		a * (fract(x/w)-0.5)\n	// 	) + .5 + floor(x/w)\n	// ));\n	return 1. - abs(\n		1. - h * (\n			.5 / tanh(a/2.) * tanh(\n				a * (\n					(x/w - floor(x/w)) - 0.5)\n				) + .5 + floor(x/w)\n			)\n		);\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n	vec4 valueRAW = texture2D(tex, mod(texcoord, 1.));\n	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvec2 n2rand(float mult) {\n	return vec2(\n		fract(sin(dot(v_texcoord.xy * mult, vec2(12.9898, 78.233))) * 43758.5453),\n		fract(sin(dot(v_texcoord.xy * 1.61803 * mult, vec2(12.9898, 78.233))) * 43758.5453)\n	);\n}\n\nvec2 n2rand() {\n	return n2rand(1.);\n}\n\nvec2 unitCircle(float angle){\n	return vec2( cos(angle), sin(angle) );\n}\n\nvec2 unitCircleDeg(float angle){\n	return unitCircle(PI*angle/180.0);\n}\n\nvoid main() {\n	float maxVel = 1.8 + .45 * sin(time*3.111) +  + .9 * cos(time*.411);\n	if(pass == 0){\n		vec2 r, d, a, x, v;\n\n		vec2 velOut, posOut;\n\n		x = extract(u_position, v_texcoord);\n		v = extract(u_velocity, v_texcoord);\n\n		velOut = (2. * v - 1.);\n\n		vec2 uv = x;\n\n		float velMult = 1.;\n\n		// sin(time*1.63)*\n		float sensorDist = 33. + 32.*(pow(noise(\n			uv * sStep(.0173*time, 12, 1) * 6., \n			time * .43752\n		), 1.) *2. - 1.);\n\n		// sensorDist = 30.;\n\n		// sensorDist = 30.;\n\n		// float sensorDist2 = 15. + 14.*(pow(noise(vec3(\n		// 	uv * 1.*(1. + cos(time * 3.21334)), \n		// 	time * 15.232)\n		// ), 2.) *2. - 1.);\n\n		// float sensorDist3 = 70. + 69.*(pow(noise(vec3(\n		// 	uv * 15.*(1. + cos(time * 1.21334)), \n		// 	time * 5.232)\n		// ), 2.) *2. - 1.);\n		float multy = sStep(.773*time, 10, 4) * 3. + 1.;\n		// multy = 3.;\n		// multy = pow(noise(uv * 1., time * .122), 2.) * 3. + 1.;\n		float sensorDist2 = sensorDist / multy;\n		float sensorDist3 = sensorDist * multy;\n\n		// float degTurn = 1.// + 8.2*(sin(time*1.512)+1.)/2.567;\n		// + 5.*(pow(noise(\n		// 	uv*(2. + 3.5*sin(time*1.885)), \n		// 	time*0.7112\n		// ) * 2. - 1., 33.));\n\n		float degTurn = 20.*(2. + sin(time*.1347))*sStep(\n			noise(\n				uv*(sStep(time*.07742, 10, 4)*3.), \n				.2144*time\n			),\n		10, 6);\n\n		float randAngle = 90.*sStep(\n			noise(\n				uv*(1. + sStep(time*.06342, 10, 2)*4.),\n				.5131*time\n			),\n		16, 6);\n		// randAngle = degTurn;\n\n		// + 8.2*(sin(time*5.12)+1.)/2.56;\n		degTurn = radians(degTurn);\n		randAngle = radians(randAngle);\n\n		float degRange = degTurn * sStep(.0143*time, 4, 4);\n\n		// float degRange = 180.*sStep(300.*time, 8, 100);\n		// degRange = radians(degRange);\n\n		float curSensor = extract(u_pheromones, uv).r * 4. * (1.5+sin(time / 3.12));\n\n		float degMulty= 1.5 * 2.-curSensor;\n		float velMulty = 1.2 * curSensor;\n		degRange *= curSensor;\n		randAngle *= curSensor * sin(time / 1.12);\n		degTurn *= 1.1 + sin(curSensor / 3.3);\n		sensorDist *= pow(curSensor, 1.+sin(time*2.114));\n		sensorDist2 *= curSensor;\n		sensorDist3 *= curSensor;\n\n		float velAngle = atan2(velOut.y, velOut.x);\n\n		vec2 sensorDistScaled = sensorDist / resolution;\n		vec2 sensorDistScaled2 = sensorDist2 / resolution;\n		vec2 sensorDistScaled3 = sensorDist3 / resolution;\n\n\n		vec2 fSensorOffset = sensorDistScaled * unitCircle(velAngle);\n		vec2 lSensorOffset = sensorDistScaled * unitCircle(velAngle + degRange);\n		vec2 rSensorOffset = sensorDistScaled * unitCircle(velAngle - degRange);\n\n		float fSensor = extract(u_pheromones, uv + fSensorOffset).r;\n		float lSensor = extract(u_pheromones, uv + lSensorOffset).r;\n		float rSensor = extract(u_pheromones, uv + rSensorOffset).r;\n\n\n		// vec2 fSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle);\n		// vec2 lSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle + degRange/degMulty);\n		// vec2 rSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle - degRange/degMulty);\n\n		// float fSensor2 = extract(u_pheromones, uv + fSensorOffset2).r;\n		// float lSensor2 = extract(u_pheromones, uv + lSensorOffset2).r;\n		// float rSensor2 = extract(u_pheromones, uv + rSensorOffset2).r;\n\n\n		// vec2 fSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle);\n		// vec2 lSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle + degRange*degMulty);\n		// vec2 rSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle - degRange*degMulty);\n\n		// float fSensor3 = extract(u_pheromones, uv + fSensorOffset3).r;\n		// float lSensor3 = extract(u_pheromones, uv + lSensorOffset3).r;\n		// float rSensor3 = extract(u_pheromones, uv + rSensorOffset3).r;\n\n\n		// // fSensor3 = 0.;\n		// // lSensor3 = 0.;\n		// // rSensor3 = 0.;\n\n		// fSensor = max(max(fSensor, fSensor2), fSensor3);\n		// lSensor = max(max(lSensor, lSensor2), lSensor3);\n		// rSensor = max(max(rSensor, rSensor2), rSensor3);\n\n		float lrDiff = abs(lSensor - rSensor);\n		lrDiff *= 3.;\n		lrDiff = 1. / (lrDiff + 2.1);\n\n\n		if(fSensor >= lSensor && fSensor >= rSensor){\n			velOut = unitCircle(velAngle) * lrDiff;\n		}\n		if(lSensor >= fSensor && lSensor >= rSensor){\n			// if(lSensor == lSensor2){\n			// 	degTurn /= degMulty;\n			// 	velMult *= velMulty;\n			// }\n			// else if(lSensor == lSensor3){\n			// 	degTurn *= degMulty;\n			// 	velMult /= velMulty;\n			// }\n			velOut = unitCircle(velAngle + degTurn) * lrDiff;\n		}\n		else if(rSensor >= lSensor && rSensor >= fSensor){\n			// if(rSensor == rSensor2){\n			// 	degTurn /= degMulty;\n			// 	velMult *= velMulty;\n			// }\n			// else if(rSensor == rSensor3){\n			// 	degTurn *= degMulty;\n			// 	velMult /= velMulty;\n			// }\n			velOut = unitCircle(velAngle - degTurn) * lrDiff;\n		}\n		else{\n		//   float randVal = n2rand();\n			float rNum = sin(5000000.*time*n2rand(time*10.).r);\n			rNum = n2rand(time*10.).r - .5;\n\n				// float curVal = texture2D(u_pheromones, uv).r;\n			 //  velOut = unitCircle(velAngle + fSensor * degTurn * sin(time));\n			 if(rNum > 0.){\n			 	velOut = unitCircle(velAngle - randAngle) * .9;\n			 }\n			 else{\n			 	velOut = unitCircle(velAngle + randAngle) * .9;\n			 }\n\n			 // velOut = vec2(0.);\n\n			 // velOut = unitCircle(velAngle + 8. * sin(time*2.997));\n		  // velOut = rNum;\n		}\n\n		// velOut -= vec2(.75, 0.);\n\n		// posOut += velOut;\n		velOut *= noise(vec3(uv * 3.* (1.1 + sin(time*.11325)), time*1.113)) * .5 + .5;\n		velOut *= velMult * dot(vec3(1.), lmh) * 4.5;// * 2.;\n		v = (velOut + vec2(1.)) / 2.;\n\n		\n\n		gl_FragColor = pack(v);\n	}\n	if(pass == 1){\n		vec2 x = extract(u_position, v_texcoord);\n		vec2 v = extract(u_velocity, v_texcoord);\n\n		float lenX = pow(smoothstep(0., .5, length(x-.5)), 4.) * .8;\n\n		v = 2. * v - vec2(1.);\n		// v = -.3 * (1. - lenX) * x ;//+ lenX * v;\n		v = -lenX * (x - .5) * .3 + (1.-lenX)*v;\n		x += v * maxVel / resolution;\n\n\n		if(length(x -.5 + .1*unitCircle(n2rand().r * 22.*PI)) > .45){\n			x = vec2(0.5) + .25 * unitCircle(n2rand().x*200.) + .1 * unitCircle((n2rand().y*500.));\n		}\n\n		x = mod(x, 1.);\n\n		gl_FragColor = pack(x);\n		// gl_FragColor = pack(x);\n		// gl_FragColor = texture2D(u_position, v_texcoord);\n	}\n}"},2419:function(e){"use strict";e.exports="precision mediump float;\n\nattribute vec2 position;\nvarying vec2 v_texcoord;\n\nvoid main() {\n	v_texcoord = 0.5 * position + 0.5;\n	// v_texcoord = position;\n	gl_Position = vec4(position, 0.0, 1.0);\n}"},2686:function(e){"use strict";e.exports="\nprecision highp float;\n\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nuniform float intensity;\n\nuniform vec2 lightXY;\nuniform float specularHardness;\nuniform float specularPower;\nuniform float diffusePower;\nuniform vec3 viewDir;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\nvec2 encode(float value) {\n    value = floor(value * scale + OFFSET);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n	return vec4(encode(value.x), encode(value.y));\n}\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n	vec4 valueRAW = texture2D(tex, texcoord);\n	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\n\nfloat luminance(vec3 c)\n{\n	return dot(c, vec3(.2126, .7152, .0722));\n}\n\nvec2 pixelOffset(vec2 offset){\n	vec2 uv = gl_FragCoord.xy / resolution;\n	return extract(u_texture, uv + offset);\n}\n\nvec3 calcNormal()\n{\n	vec2 yOffset = vec2(0., 1. / resolution.s);\n	vec2 xOffset = vec2(1. / resolution.t, 0.);\n	float R = abs(pixelOffset(xOffset).x );\n	float L = abs(pixelOffset(-xOffset).x );\n	float U = abs(pixelOffset(yOffset).x );\n	float D = abs(pixelOffset(-yOffset).x );\n				 \n	float X = (L-R) * .5;\n	float Y = (U-D) * .5;\n\n	return normalize(vec3(X, Y, 1. / intensity));\n}\n\nvoid main()\n{\n	vec3 n = calcNormal();\n\n	vec2 uv = gl_FragCoord.xy / resolution;\n\n	vec3 lp1 = vec3(lightXY, 2.) + vec3(.5, .5, 0.);\n	vec3 lp2 = vec3(-lightXY, 2.) + vec3(.5, .5, 0.);\n\n	vec3 sp = vec3(uv, -1.);\n	\n	vec3 c1 = diffusePower*vec3(dot(n, normalize(lp1 - sp)));\n	vec3 c2 = diffusePower*vec3(dot(n, normalize(lp2 - sp)));\n	\n    vec3 ep = vec3(.5, .5, 0.);\n	c1 += specularPower*pow(clamp(dot(normalize(reflect(lp1 - sp, n)), \n					   normalize(sp - ep)), 0., 1.), specularHardness);\n	c2 += specularPower*pow(clamp(dot(normalize(reflect(lp2 - sp, n)), \n					   normalize(sp - ep)), 0., 1.), specularHardness);\n\n	float mult = sqrt(extract(u_texture, uv).r);\n	gl_FragColor = pack(vec2(c1.r*mult, c2.r*mult));\n	// gl_FragColor = vec4(c, 1.);\n}\n"},9393:function(e){"use strict";e.exports="precision highp float;\n\n// Uses code by IQ and anatole duprat - XT95/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look :\n// http://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n\nstruct Ray{\n  vec3 p;\n  int obj;\n  float d;\n};\n\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D randSampler;\nuniform vec3 iAudio;\nuniform vec2 iResolution;\n\nuniform float tunnelPos;\nuniform float fisheye;\nuniform vec2 creatureXY;\nuniform float tunnelLight;\nuniform float tunnelBase;\nuniform float creatureLight;\nuniform float wingRot;\nuniform float creatureFlip;\nuniform float creatureTwist;\nuniform int HD;\nuniform float fairyLight;\nuniform float tunnelWonky;\nuniform float tunnelWidth;\nuniform float checker;\nuniform float fairyTime;\nuniform vec2 rayUp;\n\nconst float PI = 3.14159265359;\nconst vec3 ax = vec3(1., 0., 0.);\n\nRay raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane );\nvec3 normal( in vec3 p );\nRay map( in vec3 p );\nmat3 lookat( in vec3 fw, in vec3 up );\nvec3 rotate( in vec3 v, in float angle, in vec3 pos);\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat smin( float a, float b, float k );\n\n\nvec3 lpos1,lpos2,lpos3;\nvec3 lpos4,lpos5,lpos6;\nvec3 pCreature, pCreatureOffset;\nvec4 rCreature;\nvec3 posOff;\nvec3 sssColor, diffColor1, diffColor2, diffColor3;\n\n// vec2 tunnelOffset, tunnelWave;\n// vec4 rCreatureI;\nvec3 pTunnel;\n\nvec3 fairy[9];\nconst int numFairy = 9;\n\nfloat aoMaxSteps = 3.0;\n\n\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{ \n  vec4 qr;\n  float half_angle = (angle * 0.5);\n  qr.x = axis.x * sin(half_angle);\n  qr.y = axis.y * sin(half_angle);\n  qr.z = axis.z * sin(half_angle);\n  qr.w = cos(half_angle);\n  return qr;\n}\n\nvec4 quat_conj(vec4 q)\n{ \n  return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotate_vertex_position(vec3 position, vec4 qr)\n{ \n  // vec4 qr = quat_from_axis_angle(axis, angle);\n  vec4 qr_conj = quat_conj(qr);\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n  \n  vec4 q_tmp = quat_mult(qr, q_pos);\n  qr = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(qr.x, qr.y, qr.z);\n}\n\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = texture2D(randSampler, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 600.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0., 0.), pos.z), f - vec2(0., 0.)),\n                dot(GetGradient(i + vec2(1., 0.), pos.z), f - vec2(1., 0.)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0., 1.), pos.z), f - vec2(0., 1.)),\n                dot(GetGradient(i + vec2(1., 1.), pos.z), f - vec2(1., 1.)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\nvec3 threePsuedo3dNoise(vec3 pos){\n    vec3 threeNoise;\n    threeNoise.x = Pseudo3dNoise(pos + vec3(0.1, 0., 0.));\n    threeNoise.y = Pseudo3dNoise(pos + vec3(0.3111, 10., 999.123));\n    threeNoise.z = Pseudo3dNoise(pos + vec3(0.3578, 110., 999999.45));\n    return threeNoise;\n}\n\n\nvec3 objTrans(vec3 pos, vec3 oPos, vec4 qr){\n    return rotate_vertex_position(pos, qr) + oPos;\n}\n\nvec3 objTransI(vec3 pos, vec3 oPos, vec4 qr){\n    return rotate_vertex_position(pos - oPos, quat_conj(qr));\n}\n\nvec3 creature(vec3 pos){\n    return objTransI(pos + pCreatureOffset, pCreature, rCreature) - pCreatureOffset;\n}\n\nvec3 creatureI(vec3 pos){\n    return objTrans(pos - pCreatureOffset, pCreature, rCreature) + pCreatureOffset;\n}\n\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\nvec3 polarCoord(float r, float phi, float theta )\n{\n    // Theta starts at groundPlane\n 	return vec3(\n        r * sin(PI/2. - theta) * cos(phi),\n        r * cos(PI/2. - theta),\n       	r * sin(PI/2. - theta) * sin(phi)  \n    );\n}\n\nvec3 polarCoordDeg(float r, float phi, float theta )\n{\n 	return polarCoord(r, phi * PI / 180., theta  * PI / 180. );\n}\n\nvec3 rectCoord(vec3 pos){\n 	float r = length(pos);\n    float theta = atan(pos.y, pos.x);\n    float phi = atan(length(pos.xy), pos.z);\n    return vec3(r, phi, theta);\n}\n\n// Picking colors with HSV is much simpler\nvec3 hsv(float cX, float cY, float cZ)\n{\n    cX -= float(int(cX));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);\n    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);\n}\n\n// Linear white point\nconst float W = 1.2;\nconst float T2 = 7.5;\n\n//Gamma correction\nvec3 gamma(vec3 x, float gamma) {\n    return pow(x, vec3(1./gamma));\n}\n\nfloat fadeIn(float t){\n 	return min(iTime/t,1.); \n}\n    \n\nRay raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane ){\n    const int maxSteps = 80;\n    float epsilon = 0.001;\n	Ray ray = Ray(\n        ro+rd*nfplane.x, \n        -1,\n        -1.0\n    );\n	float t = 0.;\n	for(int i=0; i<maxSteps; i++)\n	{\n        ray = map(ray.p);\n        t += ray.d;\n        ray.p += rd * ray.d;\n        if( \n            ray.d < epsilon || \n            t > (nfplane.y - (1. - float(HD)) * 200.) ||\n            (i > maxSteps / 4 && HD==0)\n        )\n            break;   \n	}\n	\n	return ray;\n}\n\nvec3 normal( in vec3 p ){\n	vec3 eps = vec3(0.001, 0.0, 0.0);\n	return normalize( vec3(\n		map(p+eps.xyy).d-map(p-eps.xyy).d,\n		map(p+eps.yxy).d-map(p-eps.yxy).d,\n		map(p+eps.yyx).d-map(p-eps.yyx).d\n	) );\n}\n\n\nmat3 lookat( in vec3 fw, in vec3 up ){\n	fw = normalize(fw);\n	vec3 rt = normalize( cross(fw, normalize(up)) );\n	return mat3( rt, cross(rt, fw), fw );\n}\n\n\nvec3 rotate( in vec3 v, in float angle, in vec3 pos){\n	vec4 qr = quat_from_axis_angle(v, angle);\n    return rotate_vertex_position(pos, qr);\n}\n\n\nfloat skinLookup(vec2 pos)\n{\n    float phase = .4*texture2D(iChannel0, mod(pos / 4., 1.0)).r;\n    vec2 offset = vec2(sin(phase + iTime/20.), cos(phase + iTime/23.));\n    return texture2D(iChannel0, mod(pos + offset, 1.0)).r ;\n}\n\nfloat smin( float a, float b, float k ) //Thx to iq^rgba\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float d1, float d2, float k )\n{\n	float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n	return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n	float s = rnd.x*PI*2.;\n	float t = rnd.y*2.-1.;\n	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n	vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n	return v * sign(dot(v, dir));\n}\n\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, in float h)\n{\n    p.z /= h;\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return (sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb) * min(h, 1.);\n}\n\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n	const int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n	float ao = 0.0;\n    for( int i=0; i<nbIte; i++ )\n    {\n        if(HD == 0 && i > nbIte / 8) break;\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n            												        // for self occlusion problems\n        ao += (l - map( p + rd ).d) / pow(1.+l, falloff);\n    }\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n    // Num near samples\n	const int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);    \n	float ao = 0.0;\n    for( int i=0; i<nbIte; i++ )\n    {\n        if(HD == 0 && i > nbIte / 8) break;\n            float l = hash(float(i))*maxDist;\n            // Normal is reversed from ao calculation\n            vec3 rd = normalize(-n)*l;\n            ao += (l + map( p + rd ).d) / pow(1.+l, falloff);\n        \n    }\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec4 calcTunnelOffset(vec3 tunnelP){\n    vec2 tO = 6.*vec2(sin(tunnelP.x/12.), cos(tunnelP.x/12.));\n    vec2 tW = 8.*vec2(sin(tunnelP.x/32.), cos(tunnelP.x/22.));\n    return vec4(tO, tunnelWonky * tW);\n}\n\n//Map\nRay map( in vec3 p )\n{\n    float fairyDist = 999.;\n    float fairySize = .08;\n    // if(HD == 1){\n    for(int i = 0; i < numFairy; i++){\n        if(HD == 1 || mod(float(i), 2.) == 0.){\n        float fd = length(p - fairy[i]) - fairySize;\n        fairyDist = min(fairyDist, fd);\n        }\n    }\n    // }\n\n    vec3 pCreatROT = creature(p);;\n\n    vec3 bBallCenter = creature(lpos1) - posOff;\n    vec3 lBallCenter = creature(lpos1);\n    float wingRotMod = mod(-wingRot, 1.);\n    float suckIn = abs(3. * max(.333, wingRotMod) - 2.);\n    vec3 tBallCenter = bBallCenter + vec3(0., 5., 4.) * suckIn;\n    vec3 cBallCenter = bBallCenter + vec3(4. + sin(iTime), -3., 2.);\n\n    // Render light balls\n    float lightBallRad = .25;\n    //p.xz = mod(p.xz+100., 200.)-100.;\n    float d = 100.;//+textureLod(iChannel0, p.xz*.05, 0.0).r*1.5;\n    d = min(d, length(pCreatROT-creature(lpos1))-lightBallRad);\n    \n    float lightBallRadWing = .2;\n    d = min(d, length(pCreatROT-creature(lpos4))-lightBallRadWing);\n    d = min(d, length(pCreatROT-creature(lpos5))-lightBallRadWing);\n    d = min(d, length(pCreatROT-creature(lpos6))-lightBallRadWing);\n\n    // Render skin ball\n    \n    \n    \n    float bBallRad = 6.;\n    float lBallRad = lightBallRad + .5;\n    float tBallRad = 3.;\n    //p.xz = mod(p.xz, 60.)-30.;\n    //p = rotate(vec3(0.,1.,0.), p.y*.05*cos(iTime+sin(iTime*1.5+id.x*5.)+id.y*42.))*p;\n    float bD = length(pCreatROT-bBallCenter) - bBallRad;\n    float lD = length(pCreatROT-lBallCenter) - lBallRad;\n    float tD = length(pCreatROT-tBallCenter) - tBallRad;\n    float tD2 = length(pCreatROT-cBallCenter) - tBallRad/1.5  * (pow(iAudio[1], .5) + .5);\n    float texDisp = .35 * skinLookup(\n        (pCreatROT-bBallCenter).yz / 15.\n    );\n    d = min(d, smin(smin(smax(tD2, bD, 0.6), lD, 1.), tD, 2.) - texDisp );\n\n    //return d;\n    \n    vec3 pBranch = rotate(ax, 2.*PI/8., pCreatROT - bBallCenter);\n    float branch = sdRoundCone(pBranch, .7, .3, 10.);\n    \n    pBranch = rotate(ax, 3.*PI/8., pCreatROT - bBallCenter);\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\n    \n    pBranch = rotate(ax, 4.*PI/8., pCreatROT - bBallCenter);\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\n    \n    pBranch = rotate(ax, 5.*PI/8., pCreatROT - bBallCenter);\n    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);\n    \n    vec3 pWing = rotate(ax, 1.38 - 2.*PI * wingRot,  \n        pCreatROT - bBallCenter + vec3(0., 0., .5));\n    float wing = sdCappedTorus(\n        pWing.zyx, \n        vec2(sin(.7),cos(.7)), \n        11., 1.5, .33\n    );\n    branch = smin(branch, wing, 1.);\n\n    d = smin(d, branch - texDisp * .5, 2.);\n\n    vec3 tunnelP = p - pTunnel;\n\n    vec4 tunnelOffset = calcTunnelOffset(tunnelP);\n    float tDist = length(tunnelP.yz + tunnelOffset.xy + tunnelOffset.zw);\n    float cylinder = max(\n        tunnelWidth - tDist, \n    0.);\n    cylinder *= min(1., 1./max(0.001, (abs(tunnelWonky)+.5)));\n    // // if(max(abs(tunnelOffset.x + tunnelOffset.z), abs(tunnelOffset.y + tunnelOffset.w)) > 1.){\n    //     cylinder *= .5;\n    // // }\n    int obj = 0;\n\n    // if(HD == 1){\n    if(fairyDist < d && fairyDist < cylinder){\n        d = smin(d, fairyDist, .5);\n        obj = 2;\n    }\n    // }\n\n    else if(cylinder < d){\n        obj = 1;\n        d = cylinder;\n    }\n    \n    return  Ray(p, obj, d);\n}\n\nvec3 gradLight(vec3 pos){\n    // pos = creature(pos - pCreatureOffset) + pCreatureOffset - pCreature;\n    pos = rotate_vertex_position(pos - pCreature - pCreatureOffset, quat_conj(rCreature)) + pCreatureOffset;\n    float angle = (atan(pos.y, pos.z) + PI) / (2. * PI);\n    return hsv(angle * 3. + .2*sin(iTime * 1.5), .8, .4);\n}\n\n//Shading\nvec3 shade( in Ray ray, in vec3 n, in vec3 ro, in vec3 rd )\n{		\n    vec3 p = vec3(ray.p);\n\n    // vec3 diffColor4 = ;\n\n    vec3 dC4 = gradLight(lpos4);\n    vec3 dC5 = gradLight(lpos5);\n    vec3 dC6 = gradLight(lpos6);\n    \n    float nLookup = skinLookup(rectCoord(n).yz / 25.);\n    float nLookup2 = nLookup * nLookup - .5;\n    vec3 skinColor = hsv(0.03, 0.3, nLookup-.2) + hsv(0.03 + nLookup2*.8, 0.7 - nLookup2, nLookup);\n    skinColor /= 1.5;\n    skinColor = abs(skinColor * skinColor);\n    float roughness = 0.05;\n    float shininess = .05;\n    \n    \n    // Light positions wrt raymarch point\n    float lL1 = length(lpos1-p);\n    float lL2 = length(lpos2-p);\n    float lL3 = length(lpos3-p);\n    float lL4 = length(lpos4-p);\n    float lL5 = length(lpos5-p);\n    float lL6 = length(lpos6-p);\n\n	vec3 ldir1 = (lpos1-p) / lL1;	\n	vec3 ldir2 =  (lpos2-p) / lL2;	\n	vec3 ldir3 =  (lpos3-p) / lL3;\n    \n    vec3 ldir4 = (lpos4-p) / lL4;	\n	vec3 ldir5 =  (lpos5-p) / lL5;	\n	vec3 ldir6 =  (lpos6-p) / lL6;\n    \n    float latt1 = .3*pow(lL1 *.15, 3. ) / iAudio.x;\n    float latt2 = pow( lL2*.15, 3. ) / iAudio.y;\n    float latt3 = 3.*pow( lL3*.15, 2.5 ) / iAudio.z;\n\n    float latt4 = .3*pow( lL4*.15, 3. ) / iAudio.x;\n    float latt5 = pow(lL5*.15, 3. ) / iAudio.y;\n    float latt6 = pow( lL6*.15, 3. ) / iAudio.z;\n\n    diffColor1 = hsv(-.001/latt1+.5, .8, .3);\n    \n    // SSS multiplier (thickness) and AO\n    float sssThick = .8;\n	float thick = thickness(p, n, aoMaxSteps, 1./sssThick);\n    \n    float aoFalloff = 1.;\n	// float occ = .1*pow( ambientOcclusion(p, n, aoMaxSteps, aoFalloff), 6.);\n\n    // Diffuse lighting from lights\n	// vec3 diff1 = diffColor1 * (max(dot(n,ldir1),0.) ) / latt1;\n	vec3 diff2 = diffColor2 * (max(dot(n,ldir2),0.) ) / latt2;\n	// vec3 diff3 = diffColor3 * (max(dot(n,ldir3),0.) ) / latt3;\n\n    vec3 col = vec3(0.);//skinColor * diff2;// + diff2;// + diff3;\n    \n\n    vec3 refl = reflect(rd,n);  \n\n    float fairySSS = 0.;\n    if(HD == 1){\n        for(int i = 0; i < numFairy; i++){\n            vec3 fpos = fairy[i];\n            float ftrans = clamp( dot(-rd, -fpos+n), 0., 1.) + 1.;\n            float flatt = pow( length(fpos-p), 4. );\n            fairySSS += ftrans/flatt;\n            }\n    }\n    fairySSS *= fairyLight;\n\n    float trans1 =  clamp( dot(-rd, -ldir1+n), 0., 1.) + 1. ;\n    float trans2 =  clamp( dot(-rd, -ldir2+n), 0., 1.) + 1. ;\n    float trans3 =  clamp( dot(-rd, -ldir3+n), 0., 1.) + 1. ;\n    \n    // SSS from lights inside\n    float trans4 =  clamp( dot(-rd, -ldir4+n), 0., 1.) + 1.;\n    float trans5 =  clamp( dot(-rd, -ldir5+n), 0., 1.) + 1. ;\n    float trans6 =  clamp( dot(-rd, -ldir6+n), 0., 1.) + 1. ;\n\n    vec3 headLights = diffColor3 * creatureLight * trans3/latt3; \n    vec3 bodyLights = creatureLight * gradLight(p) * (\n        dC4*trans4/latt4 + dC5*trans5/latt5 + dC6*trans6/latt6\n    );\n    vec3 topLight = diffColor2 * creatureLight * thick * trans2/latt2;\n    \n\n    if(ray.obj == 0){\n        col = skinColor * diff2;// + diff2;// + diff3;\n        // SSS from lights inside        \n        \n        col += thick * (sssColor * (\n            .01*diffColor1*trans1/latt1 + \n            .2 * topLight) +\n            .1 * headLights + \n            .05 * bodyLights +\n            .001 * fairySSS\n        ) ;\n        col *= (.2 + .8*skinColor);\n        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ),1./roughness);\n        col += shininess*spec + .02*skinColor;\n        // col = gradLight(p);\n    }\n\n    else if(ray.obj == 1){\n        vec3 pTunnelOff = p - pTunnel;\n        vec4 tunnelOffset = calcTunnelOffset(pTunnelOff);\n        pTunnelOff += 1. * vec3(0., tunnelOffset.xy);\n        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ), 1.);\n        spec = 1.;\n        spec =  3. * spec * iAudio[2] * tunnelLight + tunnelBase;\n        int dBool = int(mod(length(pTunnelOff.x/12.) * 2., 2.));\n        float angle = (atan(pTunnelOff.z, pTunnelOff.y)+PI) / (2. * PI);\n        int aFix = 0;\n        int aBool = int(mod(angle * checker - checker / 2. - .5, 2.));\n        float checker = mod(float(dBool + aBool + aFix), 2.0);\n        col = \n            vec3(checker) * (spec) * (\n                pow(min(abs(p.x-50.), 300.)/300., 4.)  + \n                2. * bodyLights + \n                15. * headLights +\n                pow(smoothstep(.0, .5, fairySSS), .6)\n            ) + 10.*pow(smoothstep(.0, 2., fairySSS), 1.) * .3;\n    }\n\n    else if(ray.obj == 2){\n        col = vec3(fairyLight * (iAudio[0] + .5));\n    }\n\n	return col;\n}\n\nvec3 render(vec2 q)\n{\n    // Camera coordinates\n	vec2 v = -1.0 + 2.0*q;\n	v.x *= iResolution.x/iResolution.y;\n\n\n    sssColor = hsv(0.2, 0.6, 1.5);\n    diffColor1 = hsv(0.3, 0.9, .5);\n    diffColor2 = hsv(0.7, 0.1, 0.1);\n    diffColor3 = hsv(0.9, 0.1, 0.5);\n    \n    //Camera Settings\n    // float fisheye = ;\n    float lens = 1.9 - fisheye * length(v);\n    vec2 nfplane = vec2(.001, 400.);\n\n    vec3 lightOffset = vec3(cos(iTime*.5)*6., 0., sin(iTime*.5)*15.);\n\n    vec3 axisCreature = vec3(0., sin(iTime/1.4), cos(iTime/1.4));\n    vec3 axisCreatureFlip = vec3(0., 0., 1.);\n    vec3 axisCreatureTwist = vec3(0., 1., 0.);\n    pCreature =  vec3(-15.-5.*exp(-cos(iTime/1.77)),-1.5+exp(-sin(iTime)), -1.);\n    pCreature += vec3(creatureXY, 0.);\n    // pCreature = vec3(0);\n\n    posOff = vec3(6., 1.5, 1.5);\n    \n    pCreatureOffset = 3. * vec3(exp(-sin(iTime/1.53)),exp(-sin(iTime*1.11)), -cos(iTime*2.11));\n    \n    //Flip\n    rCreature = quat_from_axis_angle(axisCreature, 2.*PI*creatureFlip);\n    // rCreatureI = quat_from_axis_angle(axisCreature, -2.*PI*creatureFlip);\n\n    //Twist\n    rCreature = quat_mult(\n        rCreature,\n        quat_from_axis_angle(axisCreatureTwist, 2.*PI*creatureTwist)\n    );\n    // rCreatureI = quat_from_axis_angle(axisCreatureTwist, -2.*PI*creatureTwist);\n\n    rCreature = quat_mult(\n        rCreature,\n        quat_from_axis_angle(axisCreature, PI/6. * sin(iTime))\n    );\n    // rCreatureI = quat_from_axis_angle(axisCreature, -PI/6. * sin(iTime));\n\n    pTunnel = vec3(tunnelPos, 0., 0.);\n    \n	//define lights pos\n    lpos1 = creatureI(vec3(6., 0., 0.));\n	lpos2 = creatureI(vec3( 15., 3.5, 0.) + lightOffset);\n	lpos3 = creatureI(vec3(2., 4., 2.8));\n    \n    lpos4 = creatureI(vec3(.5, 6.5, -9.5));\n    lpos5 = creatureI(\n        rotate(ax, 2.*PI * wingRot, vec3(.5, .65, -12.2) + posOff) - posOff - vec3(0., 0., .5)\n    );\n    lpos6 = creatureI(vec3(.5, -6., -11.));\n\n    // if(HD == 1){\n    for(int i = 0; i < numFairy; i++){\n        if(HD == 1 || mod(float(i), 2.) == 0.){\n            fairy[i] = tunnelWidth * .8 * threePsuedo3dNoise(vec3(float(i+2)*12345.664, fairyTime, 0.)) + vec3(-10., 0., 0.);\n        }\n    }\n    // }\n   \n	//camera ray\n    float camDist = 25.;\n    float camFreq = 9999999.;\n    vec3 ro = vec3(camDist, 0.0, 0.);\n    vec3 rd = normalize( vec3(v.x, v.y, lens) );\n    vec3 target = vec3(0.0, 0.0, 0.0);\n	rd = lookat( target-ro, vec3(0.,rayUp))*rd;\n    \n	//classic raymarching by distance field\n	Ray ray = raymarche(ro, rd, nfplane );\n	vec3 n = normal(ray.p.xyz);\n	vec3 col = shade(ray, n, ro, rd);\n    return col;\n}\n\nvoid main()\n{\n    vec2 p = gl_FragCoord.xy/iResolution.xy; \n    vec3 col = render(p);\n    \n    col = gamma(col, 2.2); \n\n    // col = texture2D(iChannel0, p).rgb;   \n        \n	gl_FragColor = vec4(col,1.0)*fadeIn(0.9);\n}\n"},7397:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_diffuse;\nuniform sampler2D u_normal;\nuniform vec3 light;\nuniform float TIME;\nuniform float toggleStatus;\n\nconst float A_COL = .45;\nconst float I_COL = .17;\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  return hsv2rgb(vec3(h, s, v));\n}\n\nvoid main() {\n	vec2 fragCoord = gl_FragCoord.xy;\n	vec2 uv = fragCoord / resolution;\n\n	vec3 diffuse = texture2D(u_diffuse, uv).rgb;\n	vec3 normal = texture2D(u_normal, uv).rgb;\n	vec3 metal = vec3(diffuse.r);\n	vec3 buttons = toggleStatus > 0. ? \n		hsv2rgb(I_COL, .85, diffuse.g) : hsv2rgb(A_COL, .85, diffuse.g);\n\n	float height = 0.;\n\n	// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;\n	float alpha = ceil(diffuse.b);\n	if(abs(uv.x-.5) > .49){\n		alpha = 0.;\n	}\n\n	vec3 c = vec3(0.);\n	if(alpha > 0.){\n		// Phong\n		normal = (normal - vec3(.5))*2.;\n		vec3 lp = vec3(\n			3. * (light.x / resolution.x - .5), \n			// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\n			3.*(1.-light.y / resolution.y - .5), \n			1.\n		);\n		vec3 sp = vec3(uv - vec2(.5, .5), -1.);\n		vec3 ep = vec3(.5, .5, 0.);\n		c = hsv2rgb(TIME/80. + .5, .85, pow(\n			clamp(\n				dot(\n					normalize(reflect(lp-sp, normal)), \n					normalize(sp)\n				),\n				0., 1.\n			),\n			10.\n		));\n	}\n\n\n	gl_FragColor = vec4(metal + buttons + c, 1.0) * alpha;\n}"},6940:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform vec2 hdAA;\nuniform sampler2D u_diffuse;\nuniform sampler2D u_buttons;\nuniform sampler2D u_playN;\nuniform sampler2D u_pauseN;\nuniform sampler2D u_height;\nuniform sampler2D u_lights;\nuniform vec3 light;\nuniform float TIME;\nuniform bool playing;\nuniform vec3 buttonStatus;\nuniform float toggleStatus;\n\nconst float A_COL = .45;\nconst float I_COL = .55;\nconst float B_COL = .1;\nconst float B_COL_2 = .75;\nconst float L_COL = .7;\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  return hsv2rgb(vec3(h, s, v));\n}\n\nfloat sigmoid(float x){\n	return 1.0 / (1.0 + exp(-1.0 * x));\n}\n\nvoid main() {\n	vec2 fragCoord = gl_FragCoord.xy;\n	vec2 uv = fragCoord / resolution;\n\n	vec3 diffuse = texture2D(u_diffuse, uv).rgb;\n	vec3 buttonLights = texture2D(u_buttons, uv).rgb;\n	vec3 heightRGB = texture2D(u_height, uv).rgb;\n	vec3 buttonLights2 = texture2D(u_lights, uv).rgb;\n\n	vec3 normal = vec3(0.);\n	vec3 metal = vec3(0.);\n	vec3 buttons = vec3(0.);\n	vec3 speakers = hsv2rgb(TIME/80., .85, diffuse.b);\n\n	float text = heightRGB.g;\n	float height = 0.;\n\n	if(playing){\n		metal = vec3(diffuse.g);\n		normal = texture2D(u_playN, uv).rgb;\n		height = heightRGB.r;\n		buttons += hsv2rgb(A_COL, .85, buttonLights.b * buttonStatus.b);\n	}\n	else{\n		metal = vec3(diffuse.r);\n		normal = texture2D(u_pauseN, uv).rgb;\n		height = heightRGB.b;\n		buttons += hsv2rgb(A_COL, .85, buttonLights.g * buttonStatus.b);\n	}\n\n	if(uv.x < .5){\n		buttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.r);\n	}\n	else{\n		buttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.g);\n	}\n\n	//info button\n	if(uv.y < .5){\n		buttons += hsv2rgb(I_COL, .85, buttonLights2.g);\n	}\n	else{\n		if(uv.x < .5){\n			buttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;\n		}\n		else{\n			buttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;\n		}\n	}\n\n	//AA\n	buttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.r * hdAA.y) * 1.2, 0., 1.);\n	//HD\n	buttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.b * hdAA.x) * 1.2, 0., 1.);\n\n	// vec3 buttons = hsv2rgb(A_COL, .85, 1.) * color.g;\n	float sOffset = toggleStatus*2. + .25;\n	float alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);\n\n	if(abs(uv.x-.5) > .49){\n		alpha = 0.;\n	}\n\n	vec3 c = vec3(0.);\n	if(alpha > 0.){\n		// Phong\n		normal = (normal - vec3(.5))*2.;\n		vec3 lp = vec3(\n			3. * (light.x / resolution.x - .5), \n			// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\n			3.*(1.-light.y / resolution.y - .5) * resolution.y / resolution.x, \n			1.\n		);\n		vec3 sp = vec3(uv - vec2(.5, .5), -1.) * vec3(1., resolution.y / resolution.x, 1.);\n		vec3 ep = vec3(.5, .5, 0.);\n		c = hsv2rgb(TIME/80. + .5, .85, pow(\n			clamp(\n				dot(\n					normalize(reflect(lp-sp, normal)), \n					normalize(sp)\n				),\n				0., 1.\n			),\n			1000.\n		));\n	}\n\n	gl_FragColor = vec4(metal + buttons + c + speakers, 1.0) * alpha;\n}"},5898:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_diffuse;\nuniform sampler2D u_buttons;\nuniform sampler2D u_playN;\nuniform sampler2D u_pauseN;\nuniform sampler2D u_height;\nuniform vec3 light;\nuniform float TIME;\nuniform bool playing;\nuniform vec3 buttonStatus;\nuniform float toggleStatus;\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  return hsv2rgb(vec3(h, s, v));\n}\n\nfloat sigmoid(float x){\n	return 1.0 / (1.0 + exp(-1.0 * x));;\n}\n\nvoid main() {\n	vec2 fragCoord = gl_FragCoord.xy;\n	vec2 uv = fragCoord / resolution;\n\n	vec3 diffuse = texture2D(u_diffuse, uv).rgb;\n	vec3 buttonLights = texture2D(u_buttons, uv).rgb;\n	vec3 heightRGB = texture2D(u_height, uv).rgb;\n\n	vec3 normal = vec3(0.);\n	vec3 metal = vec3(0.);\n	vec3 buttons = vec3(0.);\n\n	float text = heightRGB.g;\n	float height = 0.;\n\n	if(playing){\n		metal = vec3(diffuse.g);\n		normal = texture2D(u_playN, uv).rgb;\n		height = heightRGB.r;\n		buttons += hsv2rgb(.33, .85, buttonLights.b * buttonStatus.b);\n	}\n	else{\n		metal = vec3(diffuse.r);\n		normal = texture2D(u_pauseN, uv).rgb;\n		height = heightRGB.b;\n		buttons += hsv2rgb(.33, .85, buttonLights.g * buttonStatus.b);\n	}\n\n	if(uv.x < .5){\n		buttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.r);\n	}\n	else{\n		buttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.g);\n	}\n\n	// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;\n	float sOffset = toggleStatus + .5;\n	float alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);\n	// alpha *= ceil(height);\n	// float alpha = clamp(ceil(height + heightRGB.g), 0., 1.) * (1. - toggleStatus);\n	if(abs(uv.x-.5) > .49){\n		alpha = 0.;\n	}\n\n	vec3 c = vec3(0.);\n	if(alpha > 0.){\n		// Phong\n		normal = (normal - vec3(.5))*2.;\n		vec3 lp = vec3(\n			3. * (light.x / resolution.x - .5), \n			// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),\n			3.*(1.-light.y / resolution.y - .5)*.25, \n			1.\n		);\n		vec3 sp = vec3(uv - vec2(.5, .5), -1.)*vec3(1., .25, 1.);\n		vec3 ep = vec3(.5, .5, 0.);\n		c = hsv2rgb(.75, .85, pow(\n			clamp(\n				dot(\n					normalize(reflect(lp-sp, normal)), \n					normalize(sp)\n				),\n				0., 1.\n			),\n			1000.\n		));\n	}\n\n\n	gl_FragColor = vec4(metal + buttons + c, alpha);\n}"},4723:function(e){"use strict";e.exports="\nprecision mediump float;\n\nuniform float TIME;\nuniform float swirl;\nuniform float border;\nuniform int depth;\nuniform vec2 resolution;\n\nvec2 rotateLoc(vec2 loc, float angle){\n	float oAngle = atan(loc.y, loc.x);\n	float nAngle = oAngle + angle / 180.0 * 3.1415926535;\n	vec2 rotated = length(loc) * vec2(cos(nAngle), sin(nAngle));\n	return rotated;	\n}\n\nfloat negOnePow(int power){\n	if(int(mod(float(power), 2.)) == 0){\n		return 1.;\n	}\n	return -1.;\n}\n\nint getColVal(vec2 loc, int level, float rotate){\n	float levelVal = .5*pow(.25, float(level));\n	float radVal = pow(.5, float(level));\n	\n	vec2 newLoc = rotateLoc(loc, rotate);\n	vec2 modLocW = newLoc + vec2(0., levelVal);\n    vec2 modLocB = newLoc - vec2(0., levelVal);\n    // top circle\n    if(length(modLocB) < levelVal){\n    	if(level == depth){\n    		if(length(modLocB) < levelVal/3.){\n    			return 2;\n    		}\n    	}\n    	return 1;\n    }\n    // bottom circle\n    else if(length(modLocW) < levelVal){\n    if(level == depth){\n    		if(length(modLocW) < levelVal/3.){\n    			return 1;\n    		}\n    	}\n    	return 2;\n    }\n    // left half\n    else if(length(loc) < radVal && newLoc.x > 0.){\n    	return 3;\n    }\n    // right half\n    else if(length(loc) < radVal){\n    	return 4;\n    }\n}\n\nvec4 getYinYang(vec2 offset){\n    vec2 uv = (gl_FragCoord.xy + offset) / resolution;\n\n    vec4 color = vec4(0.0);\n    \n    vec2 loc = 2.*(uv - vec2(.5));\n    vec2 ogLoc = vec2(loc);\n    loc *= 1. + border;\n    int colVal = 0;\n    \n    // vec2 ogLoc = vec2(loc);\n   \n    \n    colVal = getColVal(loc, 0, TIME);\n    loc = rotateLoc(loc, TIME);\n   \n    \n    float multFac = .125;\n    float sumVal = 0.;\n    for(int i = 0; i < 16; i++){\n        if (i >= depth){break;}\n        if(colVal > 0 && colVal < 3){\n            sumVal /= 2.;\n            if(i > 0){\n                sumVal += multFac*pow(.25, float(i-1));\n            }\n            loc = 0.5*(loc-loc.y/abs(loc.y)*vec2(0.,pow(.5, float(i+1)))  - negOnePow(colVal)*vec2(0.,sumVal));\n            colVal = getColVal(loc, i+1, pow(swirl, float(i+3))*TIME);\n            loc = rotateLoc(loc, pow(swirl, float(i+3))*TIME);\n        }\n    }\n    \n    \n    \n    \n    if(colVal == 1){\n        color = vec4(1.0); //white\n    }\n    else if(colVal == 2){\n        color = vec4(1., 0., 0., 1.); //red\n        color = vec4(0., 0., 0., 1.);\n    }\n    else if(colVal == 3){\n        color = vec4(0., 1., 0., 1.); //green\n        color = vec4(0., 0., 0., 1.);\n    }\n    else if(colVal == 4){\n        color = vec4(0., 0., 1., 1.); //blue\n        color = vec4(1.);\n    }\n    else {\n        color = vec4(0.);\n    }\n\n    if(length(ogLoc) >= 1.){\n        color = vec4(0.);\n    }\n    else if(length(ogLoc) >= 1./(1.+border)){\n        color = vec4(0., 0., 0., 1.);\n        color = vec4(1.);\n    }\n\n    return color;\n}\n\nvoid main()\n{\n    vec4 color = vec4(0.);\n\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 2; j++){\n            vec2 boi = vec2(float(i)-.5, float(j)-.5)/2.;\n            color += getYinYang(boi)/4.;\n        }\n    }\n\n    // color = getYinYang(vec2(0.));\n    \n    gl_FragColor = color;\n}\n"},9567:function(e){"use strict";e.exports="precision highp float;\n\nstruct Ray{\n  vec3 p;\n  int obj;\n  float d;\n  vec4 col;\n  vec3 n;\n};\n\nstruct dObj{\n    float d;\n    int obj;\n};\n\nuniform float iTime;\nuniform vec3 lmh;\nuniform vec2 iResolution;\nuniform bool HD;\nuniform sampler2D HDRI;\nuniform sampler2D rand;\n\n// ANIMATION\nuniform float targetDist;\nuniform float warpy;\nuniform float twisty;\nuniform float rayHeight;\nuniform vec2 upDir;\nuniform float fisheye;\nuniform float hueShift;\nuniform float rayPos;\nuniform float playTime;\n\nconst float PI = 3.14159265359;\nconst float epsilon = 0.01;\n\nvec3 rayOrigin;\n\nfloat cellWidth = 10.;\n\nvec2 uCir(float theta){\n    return vec2(cos(theta), sin(theta));\n}\n\nfloat sigmoid(float x){\n    return 1./(1. + exp(-x));\n}\n\nvec2 revSpherical(vec3 xyz){\n    float phi = acos(xyz.z/length(xyz));\n    float theta = atan(xyz.y, xyz.x);\n    return vec2(theta/(2.*PI) + .5, phi/PI);\n}\n\n// float rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb){\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash31( vec3 p ){\n    return fract(sin(dot(p ,vec3(12.9898,78.233,91.495))) * 43758.5453);\n}\n\nmat3 rotate( in vec3 v, in float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n        (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n        (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n    );\n}\n\nvec3 rotateOffset(in vec3 pos, in vec3 v, in float angle, in vec3 offset){\n    return (pos - offset) * rotate(v, angle) + offset;\n}\n\nvec3 hsv(float cX, float cY, float cZ){\n    cX -= float(int(cX));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);\n    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);\n}\n\nfloat hash( float n ){\n    return fract(sin(n)*758.5453);\n}\n\nconst vec2 zOffset = vec2(37.0,17.0);\nconst vec2 wOffset = vec2(59.0,83.0);\n\nvec4 texNoise(vec2 uv)   // Emulate a single texture fetch into the precalculated texture\n{\n    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.\n    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.\n    float r = texture2D( rand, mod((uv+0.5)/256.0, 1.)).r;\n    float g = texture2D( rand, mod((uv+0.5 + zOffset)/256.0, 1.)).r;\n    float b = texture2D( rand, mod((uv+0.5 + wOffset)/256.0, 1.)).r;\n    float a = texture2D( rand, mod((uv+0.5 + zOffset + wOffset)/256.0, 1.)).r;\n    \n    return vec4(r, g, b, a);\n}\n\n\nfloat noise4dFast( in vec4 x )\n{\n    vec4 p = floor(x);\n    vec4 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;\n    \n    vec4 s = texNoise(uv);\n    return mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);\n}\n\n// float sdGyroid(vec4 p) {\n//     return (dot(sin(p.xyzw), cos(p.wyzx)) - sin(offset)) * .5;\n// }\n\nfloat sdGyroid(vec4 p) {\n    return clamp(dot(sin(p.xyzw), cos(p.yzxw)) * .5, -1., 1.);\n}\n\nfloat sdGyroid(vec3 p, float offset) {\n    return sdGyroid(vec4(p, offset));\n}\n\nfloat sdGyroid(vec3 p) {\n    return sdGyroid(p, 0.0);\n}\n\nmat3 lookat( in vec3 fw, in vec3 up ){\n    fw = normalize(fw);\n    vec3 rt = normalize( cross(fw, normalize(up)) );\n    return mat3( rt, cross(rt, fw), fw );\n}\n\nvec3 transformPos(vec3 pos){\n    vec3 rotPos = vec3(pos);\n    // if(HD){\n    vec2 xy = vec2(1.,0.);\n    rotPos -= rayOrigin;\n    rotPos *= rotate(xy.xyy, twisty*(rotPos.y*0. + rotPos.x*.2) / cellWidth );\n    rotPos *= rotate(xy.yxx, warpy*2.*.1*(rotPos.y + rotPos.z) / cellWidth) ;\n    rotPos += rayOrigin;\n// }\n    return rotPos;\n}\n\ndObj mapDist(vec3 pos){\n    const vec2 SC = vec2(sin(PI/4.), cos(PI/4.));\n    const mat2 ROT = mat2(cos(PI/4.), sin(PI/4.), -sin(PI/4.), cos(PI/4.));\n    const mat2 ROT2 = mat2(cos(PI/2.), sin(PI/2.), -sin(PI/2.), cos(PI/2.));\n    const mat2 nROT = mat2(cos(PI/4.), -sin(PI/4.), sin(PI/4.), cos(PI/4.));\n\n    vec3 rotPos = transformPos(pos);\n\n    float posNoiseAmt = -.3*pow(sdGyroid(rotPos * 1.5, playTime*.06), 4.) * (sin(playTime/16.) + 1.1) ;\n    // posNoiseAmt -= .2*pow(sdGyroid(rotPos * 10.*exp(sin(rotPos.x/100.)), playTime*.06), 4.);\n    // posNoiseAmt += .015*pow(sdGyroid(.5*rotPos * exp(1.+sdGyroid(rotPos*.6)), playTime*.09), 1.);\n    \n     float n2G = sin(sdGyroid(rotPos/11.)/7.);\n    float n3G = cos(sdGyroid(rotPos/14.)/11.);\n    posNoiseAmt -= .03*pow(sdGyroid(rotPos * 7.*(1. + 1.*n2G), playTime*.086), 1.) ;\n    \n    \n    // if(HD){\n        // posNoiseAmt += -.2*pow(sdGyroid(rotPos * 3., playTime*.16), 6.) * (cos(playTime/17.) + 1.1) ;\n        // posNoiseAmt += -.2*pow( sdGyroid((sdGyroid(rotPos*3.)*.1 + rotPos) * 1., playTime*.1), 6.) ;\n    // }\n    vec3 noisePos = rotPos + posNoiseAmt;\n\n    float noisey =0.;\n        // (pow(sdGyroid(noisePos/8., .2*playTime * 1.), 3.) - .0) / 2.;// + \n        \n    if(HD){\n       \n\n        posNoiseAmt -= .4*pow(sdGyroid(rotPos * .5, playTime*.086), 1.) *sin(playTime/3.);\n       // posNoiseAmt += (sdGyroid(sdGyroid(noisePos*2.*(1.+sin(noisePos.x/43.))) * noisePos/5., 0.*playTime/4.) - .25)/50.;\n        posNoiseAmt += .001*pow(sdGyroid(rotPos * 60.*(1.5 + 1.*n3G), playTime*.086), 1.) ;\n    //     // noisey += -.2*pow( sdGyroid((sdGyroid(rotPos)*.2 + rotPos) * 40., playTime*.16), 6.) * (cos(playTime/4.) + 1.1) * .0 ;\n    //     // noisey += .2*pow(clamp(abs(sdGyroid(sdGyroid(noisePos*.1*(1.+sin(noisePos.x/34.)))*noisePos*10.) - .25)/200., 0., 1.), .8);\n    }\n\n    posNoiseAmt += .1;\n\n    // noisey *= .0;\n    // noisey -= 1.;\n\n    vec3 basis = vec3(1., 0., 0.);\n\n    // float cellWidth = 10.;\n    float ra = cellWidth * .5;\n    float rb = .5;\n\n    vec3 p = cellWidth * (mod(rotPos / cellWidth + .5, 1.) - .5);\n    // vec3 p = vec3(pos);\n\n    float randRot =  floor(3. * \n        hash31(floor(rotPos / cellWidth + .5))\n    );\n    if(randRot < 1.){\n        basis = basis.yxy;\n    }\n    else if(randRot < 2.){\n        basis = basis.yyx;\n    }\n    // mat3 pRot = rotate(basis, PI/2. * (randRot + 4.*clamp(mod(iTime/3., 8.)-4., 0., 1.)));\n    mat3 pRot = rotate(basis, PI/2. * randRot);\n    p *= pRot;\n    // p = pos;\n    vec3 q;\n    q = p;\n    q.xy += vec2(-.5,.5) * cellWidth;\n    q.xy *= ROT;\n    // q = rotateOffset(q, basis, iTime, vec3(-.5,.5, 0.) * cellWidth);\n    float A = sdCappedTorus( q, SC, ra, rb );\n\n    q = p.xzy;\n    q.xy += vec2(.5,.5) * cellWidth;\n    q.xy *= nROT;\n    float B = sdCappedTorus( q, SC, ra, rb );\n    \n    q = vec3(p.y, -p.z, p.x);\n    q.xy += vec2(-.5,.5) * cellWidth;\n    q.xy *= ROT;\n    float C = sdCappedTorus( q, SC, ra, rb );\n\n    // float B = 100.;\n    // float C = 100.;\n\n    float d = abs(min(A, min(B, C)) + noisey + posNoiseAmt);\n    int obj = -1;\n\n    // d /= (1. + 10.*abs(posNoiseAmt));\n    if(HD){\n        d *= .5;\n    }\n    // if(noisey + posNoiseAmt > .1){\n    //     d *= .5;\n    // }\n    else{\n        d *= .75;\n    }\n\n    // float D = sdCappedTorus( p , SC, ra, rb );\n\n    // float d = min(D, 99999.);\n\n    if(d < epsilon){\n        obj = 1;\n    }\n\n    return dObj(d, obj);\n}\n\nvoid normal( inout Ray ray ){\n vec3 eps = vec3(0.01, 0.0, 0.0);\n vec3 p = ray.p;\n ray.n = normalize( vec3(\n     mapDist(p+eps.xyy).d-mapDist(p-eps.xyy).d,\n     mapDist(p+eps.yxy).d-mapDist(p-eps.yxy).d,\n     mapDist(p+eps.yyx).d-mapDist(p-eps.yyx).d\n ) );\n // ray.n = vec3(1., 0., 0.);\n}\n\nvoid map(inout Ray ray, vec3 ro, vec3 rd){\n    dObj disty = mapDist(ray.p);\n    ray.d = disty.d;\n    ray.obj = disty.obj;\n}\n\nRay raymarch( in vec3 ro, in vec3 rd){\n    const int maxSteps = 80;\n    float maxDist = 500.;\n    Ray ray = Ray(\n        ro, \n        -1,\n        100000.,\n        vec4(0.),\n        vec3(0., 1., 0.)\n    );\n    float t = 0.;\n    vec3 roN = vec3(ro);\n    vec3 rdN = vec3(rd);\n    for(int i=0; i<maxSteps; i++){\n        if(HD || mod(float(i), 2.) == 0.){\n            map(ray, roN, rdN);\n            t += ray.d;\n            ray.p += rdN * ray.d;  \n            if( ray.d < epsilon || t > maxDist){\n                break;\n            }\n        }\n    }\n\n    if(ray.obj > 0){\n        normal(ray);\n    }\n\n    return ray;\n}\n\nvoid shade(inout Ray ray, in vec3 rd, in vec3 ro){\n    vec3 reflected=reflect(rd,ray.n);\n    vec4 hdri = texture2D(HDRI, revSpherical(reflected));\n    // vec3 env=vec3(texture2D(HDRI,reflected*reflected*reflected).x);\n\n    vec2 sph = revSpherical(ray.p - vec3(rayPos, 0, 0));\n\n    // vec3 ldir1 = 3. * vec3(sin(iTime/3.), 1., cos(iTime/3.));\n    float fog = clamp(1.-sigmoid(length(ray.p-ro)/1.4 - 30. - 50. * pow(lmh[1], 4.)), 0., 1.);\n    vec4 fogColor = vec4(hsv(\n        .3 + hueShift + sin(sph.y*.2) + 1., \n        .45 - .35*cos(playTime*2. * PI / 84.), \n        .5 + lmh[2] - .05*(cos(playTime*2. * PI / 128.) + 1.) / 2.\n    ), 1.);\n\n    vec2 uv = gl_FragCoord.xy/iResolution.xy; \n    fogColor.rgb *= clamp(2.5-4.*length(uv-vec2(.5)), 0., 1.);\n\n    float hue = abs(dot(normalize(rd), normalize(ray.n)));\n    vec4 thinFilm = vec4(hsv(hue/2. + hueShift, .9, hdri.r), 1.);\n    \n    if(ray.obj == 1){\n        vec3 rotPos = transformPos(ray.p);\n        float spots = \n        clamp(\n            pow(\n                abs(sdGyroid(\n                    rotPos*9.*\n                    (1. + .3*sin(rotPos.x/cellWidth/8.2))*.5*\n                    // sigmoid(length(rotPos.yz - vec2(cellWidth/2.)))*\n                    (1. + .1*sin(rotPos.x/cellWidth/9.2) ) * .5 *\n                    (1. + .1*sin(playTime*.012)+.5)\n                ) + .7*(.5+.2*cos(rotPos.x/cellWidth/5.2)))* \n                (1.5 + .4*sin(rotPos.x/cellWidth/10.2))\n            , 200. )\n        , 0., 1. );\n\n        // spots *= 0.;\n        spots *= pow(2.-sigmoid(length(rotPos.yz-rayOrigin.yz)/50.)*2., 4.);\n        spots += .2;\n\n        // spots += 1. - \n        // clamp(\n        //     pow(\n        //         abs(sdGyroid(\n        //             ray.p*2.*\n        //             sigmoid(length(ray.p.yz - vec2(cellWidth/2.)))*\n        //             (1. + sin(ray.p.x/200.) ) * .5 *\n        //             (1. + .1*sin(playTime*.003)+.5)\n        //         ) - .2)*10.\n        //     , 120. )\n        // , 0., 1. );\n        ray.col = \n            15. * mix(thinFilm, hdri, hue) * pow(lmh[0], 6.) * fog * (1. - spots) + \n            fogColor * (1. - fog) +\n            vec4(hsv(ray.p.x / 180., clamp(abs(20. - ray.p.x)/20., 0., 1.)*.0*(1.-pow(lmh[0], 2.)),\n                spots * pow(fog, .2) * .9 * (1.-pow(lmh[0], 4.)) \n            ), 1.);\n        // ray.col = vec4(1.);\n    }\n    else{\n        ray.col = fogColor;\n    }\n}\n\nvec4 render(vec2 q){\n    vec2 v = -1.0 + 2.0*q;\n    v.x *= iResolution.x/iResolution.y;\n\n    //Camera Settings\n    // float fisheye = 6. * (sin(iTime / 5. + PI)) / 2.;\n    // fisheye = .3;\n    float lens = 1.9 + fisheye * length(v);\n\n    //camera ray\n    float camDist = 100.;\n    float camFreq = 9999999.;\n    // vec3 rayOrigin = camDist * vec3(1., 0., 0.);// * vec3(sin(iTime/15.), 0., cos(iTime/15.));\n    // rayOrigin = vec3(iTime*3., cellWidth/2., cellWidth/2.);\n    rayOrigin = vec3(\n        rayPos, \n        cellWidth/2. + rayHeight * cellWidth, \n        cellWidth/2.\n    );\n    \n    vec3 rayDir = normalize( vec3(v.x, v.y, lens) );\n    vec3 target = vec3(0., cellWidth/2., cellWidth/2.);\n    target = vec3(rayPos + targetDist, cellWidth/2., cellWidth/2.);\n    // target = vec3(iTime*3. + 3., cellWidth/2. + sin(iTime * PI / 3.), cellWidth/2.);\n    rayDir = lookat( target-rayOrigin, vec3(0.,upDir))*rayDir;\n    \n    //classic raymarching by distance field\n    Ray ray = raymarch(rayOrigin, rayDir);\n    shade(ray, rayDir, rayOrigin);\n    return ray.col;\n}\n\nvoid main(){\n    vec2 p = gl_FragCoord.xy/iResolution.xy; \n    vec4 col = render(p);\n\n    // col = texture2D(HDRI, p);\n\n    // col.rgb *= clamp(2.5-4.*length(p-vec2(.5)), 0., 1.);\n        \n    gl_FragColor = col;\n}"},5666:function(e){"use strict";e.exports="precision highp float;\n\n#define AA 1  //change to 1 to increase performance\n\n#define _Speed .4  //disk rotation speed\n\n#define _Steps  4. //disk texture2D layers\n// #define bhSize 0.3 //size of BH\n\nuniform vec2 resolution;\nuniform sampler2D sphereMap;\nuniform sampler2D pebbles;\nuniform float TIME;\nuniform float bhTIME;\nuniform float MOUSEX;\nuniform float MOUSEY;\nuniform float bhRad;\nuniform float bhDist;\nuniform float bhX;\nuniform float bhSeparation;\nuniform vec3 iAudio;\nuniform float hueShift;\nuniform float camDist;\nuniform float starBright;\nuniform bool HD;\n\n// const vec2 MOUSE = vec2(.5, 60.);\n\nconst int MAX_MARCHING_STEPS = 15;\nconst int diskSteps = 10;\nconst int exitSteps = 6;\n\nconst float discThickness = .001;\n\nconst float MIN_DIST = 100.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897;\n\nconst float starSize = .05;\nconst int numStars = 6;\nvec3 starPos[6];\nfloat starSizes[6];\nvec3 ogPos;\n\nfloat bhSize;\n\nfloat sigmoid(float x){\n    return 1./(1. + exp(-x));\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec3 hsv2rgb(vec3 c) {\n    c.x = mod(c.x, 1.);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float r, float g, float b) {\n  return hsv2rgb(vec3(r, g, b));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nvec3 blendNormal(vec3 normal){\n    vec3 blending = abs(normal);\n    blending = normalize(max(blending, 0.00001));\n    blending /= vec3(blending.x + blending.y + blending.z);\n    return blending;\n}\n\nvec3 triplanarMapping (sampler2D texture, vec3 normal, vec3 position) {\n  vec3 normalBlend = blendNormal(normal);\n    vec3 xColor = texture2D(texture, position.yz).rgb;\n    vec3 yColor = texture2D(texture, position.xz).rgb;\n    vec3 zColor = texture2D(texture, position.xy).rgb;\n\n  return (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);\n}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat grid(vec3 p)\n{\n    float s = sin(p.x)*cos(p.y);\n    //float s = sin(p.x)*cos(p.y);\n    return s;\n}\n\nfloat flow(vec4 pppp)\n{\n    vec3 p = pppp.xyz;\n    float z=2.;\n    float rz = 0.;\n    vec3 bp = p;\n    float ttt = pppp.w;\n    \n\n    for (float i= 1.;i < 5.;i++ )\n    {\n        //movement\n        p += ttt*.6;\n        bp -= ttt*.3;\n        \n        //displacement map\n        vec3 gr = vec3(grid(p*3.-ttt*1.),grid(p*3.5+4.-ttt*1.),grid(p*4.+4.-ttt*1.));\n        p += gr*0.15;\n        rz+= (sin(noise(p)*8.)*0.5+0.5) /z;\n        \n        //advection factor (.1 = billowing, .9 high advection)\n        p = mix(bp,p,.7);\n        \n        //scale and rotate\n        z *= 2.;\n        p *= 2.01;\n        p*=m3;\n        bp *= 1.7;\n        bp*=m3;\n    }\n    return rz;  \n}\n\nvec2 unitCircle(float angle){\n    return vec2(cos(angle), sin(angle));\n}\n\nvec4 background(vec3 ray, vec2 ogUV)\n{\n    vec2 uv = ray.xy;\n    \n    // if( abs(ray.x) > 0.5)\n    //     uv.x = ray.z;\n    // else if( abs(ray.y) > 0.5)\n    //     uv.y = ray.z;\n\n    float dist = length(ogUV-vec2(.5));\n    // dist = .004;\n    dist -= .25;\n    dist = .001/(1.+dist*dist);\n\n    float scaling = 1.;\n    vec4 nebulaeR = texture2D(sphereMap, mod(uv, vec2(scaling, scaling) )/scaling);\n    vec4 nebulaeG = texture2D(sphereMap, mod(uv*(1.+dist), vec2(scaling, scaling) )/scaling);\n    vec4 nebulaeB = texture2D(sphereMap, mod(uv*(1.-dist), vec2(scaling, scaling) )/scaling);\n    // nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color\n    vec4 nebulae = vec4(nebulaeR.r, nebulaeG.g, nebulaeB.b, nebulaeR.a);\n    vec3 nebulaeHSV = rgb2hsv(nebulae.xyz) + vec3(.35, -.1, .0);\n// return nebulaeR;\n	return vec4(starBright * hsv2rgb(nebulaeHSV), 1.);\n}\n\nvec4 raymarchDisk(vec3 ray, vec3 zeroPos)\n{\n    //return vec4(1.,1.,1.,0.); //no disk\n\n    float stepsHD = _Steps;\n    // if(!HD){\n    //     stepsHD = _Steps/3.;\n    // }\n    \n	vec3 position = zeroPos;      \n    float lengthPos = length(position.xz);\n    float dist = 0.1 * min(1., .5*lengthPos) * 1. / (stepsHD * abs(ray.y) );\n\n    position += dist * stepsHD * ray * 0.5;     \n\n    vec2 deltaPos;\n    deltaPos.x = -0.01 * zeroPos.z + zeroPos.x;\n    deltaPos.y = 0.01 * zeroPos.x + zeroPos.z;\n    deltaPos = normalize(deltaPos - zeroPos.xz);\n    \n    float parallel = dot(ray.xz, deltaPos);\n    parallel /= 2. * sqrt(lengthPos);\n    float redShift = parallel + 0.3;\n    redShift = clamp(redShift, 0., 1.);\n\n    float hueShift = -.3;\n    \n    float disMix = clamp(0.24 * (lengthPos - bhSize * 2.) / bhSize, 0., 1.);\n    vec3 insideCol =  mix(hsv2rgb(.5+hueShift, .9, 1.), hsv2rgb(.9+hueShift, .9, 1.)*.5, pow(disMix, .5));\n    \n    insideCol *= mix(hsv2rgb(.45+hueShift, .9, 1.), hsv2rgb(.2+hueShift, .9, 1.), redShift);\n	insideCol *= 1.25;\n    redShift += 0.18;\n    redShift *= redShift;\n\n    float theta = (atan(position.z, position.x) + PI) / (2. * PI);\n    float phi = mod((atan(position.z, position.x) + 2. * PI) / (2. * PI), 1.);    \n\n    vec4 oCol = vec4(0.);\n\n    \n\n    for(float i = 0. ; i < _Steps; i++)\n    {      \n        if(!HD && i > stepsHD){\n            break;\n        }                \n        position -= dist * ray ;  \n\n        float intensity = clamp( 1. - abs( 2. * (i - 0.8) / stepsHD ), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 2.;\n\n        // diameter of disc\n        vec2 discSize = vec2(.75, .1);\n        distMult *=  clamp(2. * (lengthPos -  bhSize * discSize.x) * discSize.x / bhSize, 0., 1.);        \n        distMult *= clamp(( 3. - lengthPos) * 3.0, 0., 1.);\n        distMult *= distMult;\n\n        // float rrr = lengthP\n  \n        const float f = 70.;\n        // float noise = .5 * flow( 50. * vec3( angle * lengthPos, 0.03 * u , 2. * f));\n        // noise += .5 * flow( 50. * vec3( angle * lengthPos, 0.03 * u, 4. * f));     \n        float noise1 = .5 * flow( vec4( lengthPos * 3., theta * 20.  + 100. / (lengthPos + 3.) , 2. * f, bhTIME   + iAudio[2]));\n        float noise2 = .5 * flow( vec4( lengthPos * 3., phi * 20.  + 100. / (lengthPos + 3.) , 4. * f, bhTIME  + iAudio[2]));\n        float noise = noise1 * abs(1. - 2. * phi) + noise2 * abs(1. - 2. * theta);\n        // noise += .5 * flow( 50. * vec3( position.xz / 4., 4. * f)); \n\n        float extraWidth =  noise * (1. -  clamp(2. * i / stepsHD - 1., 0., 1.));\n\n        float alpha = 10. * noise * (intensity + extraWidth) * ( 4. + 0.01 ) *  dist * distMult;\n        // alpha -= (lengthPos * .5) / bhSize;\n        float bhAmix = 1.-pow(bhSize * 2., 1.);\n        alpha = mix(alpha, (1.-lengthPos * 2.) * alpha * bhAmix, bhAmix);\n        alpha = clamp( alpha , 0., 1.);\n\n\n        vec3 col = 2. * mix( hsv2rgb(0.+hueShift, .9, 1.) * insideCol, insideCol, min(1.,intensity*2.));\n        oCol = (1.-alpha) * oCol + alpha * vec4(col, 1.);\n        oCol.rgb += 1. * redShift * (intensity + 0.5) * distMult * bhSize * bhSize /(stepsHD*lengthPos*lengthPos);\n    }  \n \n    oCol.rgb = clamp(oCol.rgb , 0., 1.);\n    return oCol ;\n}\n\nvec3 getStarPos(int id) {\n    for (int i=0; i<numStars; i++) {\n        if (i == id) return starPos[i];\n    }\n}\n\nfloat getStarSize(int id) {\n    for (int i=0; i<numStars; i++) {\n        if (i == id) return starSizes[i];\n    }\n}\n\nfloat starDist(vec3 pos, int i){\n    return length(pos - getStarPos(i)) - getStarSize(i);\n}\n\nvec3 starNormal( vec3 pos, int i){\n vec3 eps = vec3(0.001, 0.0, 0.0);\n vec3 p = vec3(pos);\n vec3 n = normalize( vec3(\n     starDist(p+eps.xyy, i)-starDist(p-eps.xyy, i),\n     starDist(p+eps.yxy, i)-starDist(p-eps.yxy, i),\n     starDist(p+eps.yyx, i)-starDist(p-eps.yyx, i)\n ) );\n return n;\n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n	vector.yz = cos(angle.y)*vector.yz\n				+sin(angle.y)*vec2(-1,1)*vector.zy;\n	vector.xz = cos(angle.x)*vector.xz\n				+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid applyBendForce(inout vec3 pos, inout vec3 ray, vec3 bhPos, float bhRadd){\n    float dotpos = dot(pos-bhPos, pos-bhPos);\n    float invDist = inversesqrt(dotpos); // 1/distance to BH\n    float centDist = dotpos * invDist;  // distance to BH\n    float stepDist = 0.92 * abs(pos.y /(ray.y));  // conservative distance to disk (y==0)\n\n    float starMin = 9999.;\n    for(int i = 0; i < numStars; i ++){\n        if(!HD && i >= numStars / 2){\n            continue;\n        }\n        float starDist = length(pos - starPos[i]) - getStarSize(i);\n        if( starDist < starMin){\n            starMin = starDist;\n        }\n    }\n\n    if(!HD){\n        starMin *= .5;\n    }\n    // else{\n    //     starMin *= .25;\n    // }\n    \n\n    float farLimit = centDist * 0.5; // limit step size far from to BH\n    float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./bhRadd); //limit step size closse to BH\n    stepDist = min(min(stepDist, min(farLimit, closeLimit)), starMin);\n\n    // stepDist = starMin;\n    \n    float invDistSqr = invDist * invDist;\n    float bendForce = stepDist * invDistSqr * bhRadd * 0.625;  //bending force\n    ray = normalize(ray - (bendForce * invDist )*pos);\n    pos += stepDist * normalize(ray); \n}\n\nvoid renderStars(in vec3 pos, inout vec4 col, inout bool hitStar){\n    for(int i = 0; i < numStars; i ++){\n        if(!HD && i >= numStars / 2){\n            break;\n        }\n        vec3 pDif = pos - starPos[i];\n        float sDist = length(pDif);\n        float sFrac = float(i) / float(numStars);\n        if(sDist < getStarSize(i) + .01){\n            vec3 sNorm = normalize(starNormal(pos, i) * .5+ .5);\n            float psDist = length(ogPos - starPos[i]);\n            // Rotate(sNorm, vec2(TIME*.8, TIME*1.));\n            Rotate(pDif, vec2(TIME*.8, TIME*1.));\n            sNorm = pow(sNorm, vec3(1.));\n            float distPow = (1. - sigmoid((psDist - length(ogPos)) * 2.));\n            float sunSpot = 1. * pow(triplanarMapping(pebbles, sNorm, 2. * (rand(sFrac*30.) + .5) * pDif + sFrac).r, 1.);\n            // distPow = 1.;\n            vec3 pebCol = hsv2rgb(\n                3.5 * sunSpot * (sFrac + .2) + .08*TIME * (1. + 3.*rand(sFrac)), \n                1. - sunSpot, \n                sunSpot * distPow\n            );\n            // pebCol *= distPow;\n            col = vec4(\n                  col.a * col.rgb + (1. - col.a) * pebCol,// / pow(max(length(ogPos - pos), 1.), 6.), \n                1.\n            );\n            hitStar = true;\n            break;\n        }\n        if(hitStar)\n        break;\n    }\n}\n\nvoid main()\n{\n\n    vec3 viewDir = rayDirection(45.0, resolution, gl_FragCoord.xy);\n    vec3 pos = vec3(camDist*cos((MOUSEY - .5)*PI), camDist * sin((MOUSEY - .5)*PI), 5.);\n    \n    mat3 viewToWorld = viewMatrix(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, cos((MOUSEX - .5)*PI), sin((MOUSEX - .5)*PI)));\n    \n    vec3 ray = viewToWorld * viewDir;\n\n    vec2 angle = vec2( TIME * 0.05 + .9, 0.3 );      \n    Rotate(pos, angle);\n    Rotate(ray, angle);\n\n    ogPos = vec3(pos);\n\n    vec3 bhLoc1 = bhDist*vec3(0., bhSeparation, 0.);\n    vec3 bhLoc2 = -bhLoc1;\n    vec3 bhOffset = vec3(0., bhX, 0.);\n    bhLoc1 +=  bhOffset;\n    bhLoc2 -=  bhOffset;\n\n    bhSize = bhRad + bhRad * iAudio[0] * .1 + .01;\n\n    for(int i = 0; i < numStars; i ++){\n        float sFrac = float(i) / float(numStars);\n        // if(!HD && i >= numStars / 2){\n        //     continue;\n        // }\n        float theta = PI * sFrac;\n        float phi = TIME * .2;\n        // phi *= 3.;\n        phi *= rand(float(i + 1)) + 1.;\n        phi += 2.*PI * rand(float(i + 999));\n        float randR = (2. + rand(float(i * 100)) );\n        // randR = 1.;\n        starPos[i] = randR * vec3( \n            sin(phi)*cos(theta), \n            cos(phi),\n            sin(phi)*sin(theta)\n        );\n        starSizes[i] = starSize * (1. + 3.*rand(sFrac));\n    }\n\n\n    vec4 col = vec4(0.); \n    vec4 outCol =vec4(100.);\n\n    for(int disks = 0; disks < diskSteps; disks++) //steps\n    {\n        // if(!HD && disks > diskSteps / 2){\n        //     continue;\n        // }     \n        bool hitStar = false;\n        for (int h = 0; h < exitSteps; h++) // reduces tests for exit conditions (to minimise branching)\n        {\n            // if(!HD && h > exitSteps / 2){\n            //     continue;\n            // }\n            applyBendForce(pos, ray, bhLoc1, bhSize);\n            renderStars(pos, col, hitStar);\n            if(hitStar)\n                break;\n            applyBendForce(pos, ray, bhLoc2, bhSize);\n            // renderStars(pos, col, hitStar);\n            if(hitStar)\n                break;\n        }\n        if(hitStar)\n                break;\n\n        float dist21 = length(pos - bhLoc1);\n        float dist22 = length(pos - bhLoc2);\n\n        if(dist21 < bhSize * 0.1 || dist22 < bhSize * 0.1 ) //ray sucked in to BH\n        {\n            outCol =  vec4( col.rgb * col.a ,1.) ;\n            // outCol = vec4(vec3(0.), 1.);\n            break;\n        }\n\n        else if(dist21 > bhSize * 10000. && dist22 > bhSize * 10000.) //ray escaped BH\n        {                   \n            vec4 bg = background(ray, gl_FragColor.xy/resolution);\n            outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a) , 1.);       \n            break;\n        }\n\n        else if (abs(pos.y) <= bhSize * discThickness ) //ray hit accretion disk\n        {                             \n            vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n            vec3 hDiskCol = hsv2rgb(rgb2hsv(diskCol.rgb) + vec3(hueShift, 0., 0.));\n            diskCol.rgb = hDiskCol;\n            pos.y = 0.;\n            pos += abs(bhSize * discThickness / (2. * ray.y) ) * ray;  \n            col = vec4(diskCol.rgb * (1.-col.a) + col.rgb, col.a + diskCol.a * (1.-col.a));\n            // break;\n        }\n    }\n\n    //if the ray never escaped or got sucked in\n    if(outCol.r == 100.)\n        outCol = vec4(col.rgb, 1.);\n\n    col = outCol;\n    // col.rgb =  pow( col.rgb, vec3(0.6) );\n    \n    gl_FragColor += col;\n}\n"},9976:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\nuniform float iTime;\n\nconst float PI = 3.1415926535897;\n\nvec3 sphericalToCartesian( float rho, float phi, float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nint state(vec2 uv){\n	if(uv.x > 1.){\n		uv.x -= 1.;\n	}\n	if(uv.x < 0.){\n		uv.x += 1.;\n	}\n	if(uv.y > 1.){\n		uv.y -= 1.;\n	}\n	if(uv.y < 0.){\n		uv.y += 1.;\n	}\n	return texture2D(u_texture, uv).r > .5 ? 1 : 0;\n}\n\nint sphericalState(vec2 uv){\n	vec2 offset = uv * vec2(2.*PI, PI);\n	vec3 sphereMap = sphericalToCartesian(1., offset.x, offset.y);\n	return state(sphereMap.xy);\n}\n\nvoid main() {\n		vec2 UV = gl_FragCoord.xy / resolution;\n\n		int curState = state(UV);\n\n		int sum = 0;\n\n		for(int i = -1; i <= 1; i ++){\n			for(int j = -1; j <= 1; j ++){\n				if( !(i == 0 && j == 0)){\n					vec2 offset = UV + vec2(i, j) /  resolution;\n					sum += state(offset);\n				}\n			}\n		}\n\n		float newState1 = \n			(curState == 0 && sum == 3) || \n			(curState == 1 && (sum == 3 || sum == 2)) ? 1. : 0.;\n		float newState2 = \n			(curState == 0 && sum == 2) || \n			(curState == 1 && (sum <= 4 || sum >= 2)) ? 1. : 0.;\n\n		float newState = iTime > 10. && iTime < 10.3 ? newState2 : newState1;\n		\n		gl_FragColor = vec4(vec3(newState1), 1);\n		// gl_FragColor = vec4(curState, curState, curState, 1);\n		// gl_FragColor = vec4(.5, .1, 0, 1);\n\n}"},6355:function(e){"use strict";e.exports="precision mediump float;\nattribute vec2 audioData;\n\nvoid main() {\n	gl_Position = vec4(position, 0.0, 1.0);\n}"},4290:function(e){"use strict";e.exports="precision highp float;\n\nstruct Ray{\n  vec3 p;\n  int obj;\n  float d;\n  vec4 col;\n  vec3 n;\n};\n\nstruct dObj{\n	float d;\n	int obj;\n};\n\nconst float PI = 3.14159265359;\n\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform sampler2D iWavelet;\nuniform vec3 lmh;\nuniform vec2 iResolution;\nuniform bool HD;\n\nuniform float fisheye;\nuniform float camDist;\nuniform vec2 rayOriginC;\nuniform vec2 rayUp;\nuniform vec2 rayOriginOffset;\nuniform float hueShift;\nuniform float skyHeight;\nuniform float uvDisp;\nuniform float camKal;\nuniform float camSin;\nuniform float renderDist;\nuniform float ballX;\nuniform float ballY;\nuniform vec2 moonXY;\nuniform float moonLight;\n\nvec3 cen1;// = vec3(0., -skyHeight/2. * sin(iTime*2.), 0.);\n// vec3 cen1 = -vec3(0., skyHeight/2., 0.);\nfloat rad1;// = skyHeight/2.;\nvec3 cen2;//= cen1 + skyHeight * vec3(sin(iTime*2.), 0., cos(iTime*2.));\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n\nvec3 hsv(float cX, float cY, float cZ){\n    cX -= float(int(cX));\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);\n    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);\n}\n\n//iq 3d noise\nfloat noise(vec3 x){\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture2D(iChannel0, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat fbm(vec3 x){\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\nmat3 lookat( in vec3 fw, in vec3 up ){\n	fw = normalize(fw);\n	vec3 rt = normalize( cross(fw, normalize(up)) );\n	return mat3( rt, cross(rt, fw), fw );\n}\n\nfloat thetaMap(float theta, float split){\n	float thetaMod = mod(theta, 2. * PI);\n	float splitMod = mod(split, 2. * PI);\n	if(thetaMod > splitMod){\n		thetaMod -= 2. * PI;\n	}\n	return thetaMod;\n}\n\nvec4 raySphere(vec3 start, vec3 end, vec3 cen, float r){\n	float a = pow(end.x - start.x, 2.) + pow(end.y - start.y, 2.) + pow(end.z - start.z, 2.);\n	float b = -2. * ( (end.x-start.x)*(cen.x-start.x) + (end.y-start.y)*(cen.y-start.y) + (end.z-start.z)*(cen.z-start.z) );\n	float c = pow(cen.x - start.x, 2.) + pow(cen.y - start.y, 2.) + pow(cen.z - start.z, 2.) - pow(r, 2.);\n	float d = pow(b, 2.) - 4. * a * c;\n	if(d > 0.){\n		float t1 = (-b - sqrt(d)) / (2. * a);\n		float t2 = (-b + sqrt(d)) / (2. * a);\n		float t = t1 > -.01 ? t1 : t2;\n		t = t1;\n		if(t > -.01){\n			return vec4(1., \n				start.x + (start.x - end.x) * t,\n				start.y + (start.y - end.y) * t,\n				start.z + (start.z - end.z) * t\n			);\n		}\n	}\n	return vec4(-1.);\n}\n\ndObj mapDistAurora(vec3 pos, vec3 ro, vec3 rd){\n	float ep = .0000001;\n	float d = (skyHeight - pos.y + ep) / (rd.y + ep);//+ .01);\n	int obj = -1;\n\n	vec4 intSphere1 = raySphere(pos, rd + pos, cen1, rad1);\n	vec4 intSphere2 = raySphere(pos, rd + pos, cen2, rad1/2.);\n	float A = length(pos - intSphere1.gba);\n	float B = length(pos - intSphere2.gba);\n\n\n	if(length(pos - ro) > 0. && rd.y > 0.){\n		// d = .001 + hash21(gl_FragCoord.xy)*.005;\n		float distMult = HD ? 1. : 2.;\n		d = .024 * distMult * (1. + (pos.y - skyHeight + ep) / (rd.y + ep));\n		obj = 1;\n	}\n	else if(rd.y < 0.){\n		d = (-skyHeight - pos.y + ep) / (rd.y + ep);\n		// d /= 2.;\n		// d = abs(d);\n		obj = 2;\n	}\n\n\n	if(intSphere1.x > 0. && intSphere2.x > 0. && min(A, B) < d){\n		obj = 4;\n		if(A > B){\n			obj = 5;\n		}\n		return dObj(min(A, B), obj);\n	}\n	else if(intSphere1.x > 0. && A < d){\n		obj = 4;\n		return dObj(A, obj);\n	}\n	else if(intSphere2.x > 0. && B < d){\n		obj = 5;\n		return dObj(B, obj);\n	}\n\n	return dObj(d, obj);\n}\n\nvoid mapAurora(inout Ray ray, vec3 ro, vec3 rd){\n	// vec3 offset = vec3(sin(iTime/1.22), 0., cos(iTime/1.44));\n	dObj mapAurora = mapDistAurora(ray.p, ro, rd);\n	ray.d = mapAurora.d;\n	ray.obj = mapAurora.obj;\n\n	if(ray.obj == 1){\n		float grad = .45 + .7 * (ray.p.y - skyHeight);\n		vec3 rgb = hsv(grad * .75 + hueShift, .85, 1.);\n		vec2 uvWav = mod(ray.p.zx / 30. + .5 + vec2(0., uvDisp), 1.);\n		float wNoise = texture2D(iWavelet, uvWav).r / 4.;\n		if(length(uvWav - .5) > .5){\n			wNoise *= 0.;\n		}\n		if(!HD){\n			wNoise /= .7;\n		}\n		if(max(abs(ray.p.z), abs(ray.p.x)) < renderDist){\n			ray.col += vec4(rgb, 1.) * pow(wNoise, 2.) * pow(clamp(grad, 0., 1.), .5) * .8;\n		}\n	}\n}\n\n// void normal( inout Ray ray ){\n// 	vec3 eps = vec3(0.001, 0.0, 0.0);\n// 	vec3 p = ray.p;\n// 	ray.n = normalize( vec3(\n// 		mapDist(p+eps.xyy).d-mapDist(p-eps.xyy).d,\n// 		mapDist(p+eps.yxy).d-mapDist(p-eps.yxy).d,\n// 		mapDist(p+eps.yyx).d-mapDist(p-eps.yyx).d\n// 	) );\n// }\n\nvec2 noiseNormal(vec2 p){\n	vec2 ep = vec2(.01, 0.);\n	float zPos = iTime/100.;\n	float nFreq = 1. * .05 * sin(iTime / 60.);\n	nFreq = 1.;\n	float dX = fbm(vec3((p + ep.xy)  * nFreq, zPos)) - \n		fbm(vec3((p - ep.xy)  * nFreq, zPos));\n	float dY = fbm(vec3((p + ep.yx)  * nFreq, zPos)) - \n		fbm(vec3((p - ep.yx)  * nFreq, zPos));\n	return vec2(dX, dY) * (1.25 + sin(iTime / 40.) * .75) ;\n}\n\nRay raymarch( in vec3 ro, in vec3 rd){\n    const int maxSteps = 24;\n    float maxDist = 100.;\n    float epsilon = 0.001;\n	Ray ray = Ray(\n        ro, \n        -1,\n        100.,\n        vec4(0.),\n        vec3(0., 1., 0.)\n    );\n	float t = 0.;\n	vec3 roN = vec3(ro);\n	vec3 rdN = normalize(vec3(rd));\n	for(int i=0; i<maxSteps; i++){\n		if(HD || mod(float(i), 2.) == 0.){\n	        mapAurora(ray, roN, rdN);\n	        t += ray.d;\n	        ray.p += rdN * ray.d;  \n			if( ray.d < epsilon){//} || t > maxDist){\n	            break;\n			}\n			if(ray.obj == 2){\n				vec2 noiseNorm = .7 * noiseNormal(ray.p.xz / 8. + vec2(0., uvDisp));\n				roN = vec3(ray.p);\n				rdN = reflect(rdN, normalize(vec3(noiseNorm.x, 1.0, noiseNorm.y)));\n			}\n			else if(ray.obj == 4){//} && length(ray.p - cen1) < rad1 * 2.){\n				roN = vec3(ray.p);\n				rdN = reflect(rdN, normalize(ray.p-cen1));\n			}\n			else if(ray.obj == 5){\n				roN = vec3(ray.p);\n			}\n		}\n	}\n\n	// if(ray.d < epsilon){\n	// 	normal(ray);\n	// }\n	// else{\n	// 	ray.obj = -1;\n	// }\n	\n	return ray;\n}\n\nvoid shade(inout Ray ray, in vec3 rd){\n	vec3 ldir1 = 3. * vec3(sin(iTime/3.), 1., cos(iTime/3.));\n	if(ray.obj == 0){\n		// float roughness = .1;\n		// ray.col += vec4(.9 * (1.-ray.col.a), 0., 0., 1.);\n		// vec3 refl = reflect(rd, ray.n);  \n  //       float spec = pow(clamp( dot( refl, ldir1 ), 0.0, 1.0 ), 1./roughness);\n		// ray.col += .7 * spec * (1.-ray.col.a);\n		ray.col = vec4(1., 0., 0., 1.);\n	}\n	// else if(ray.obj == 4){\n	// 	ray.col += vec4(vec3(.8), 1.);\n	// }\n	else if(ray.obj == 5){\n		ray.col += vec4(vec3(moonLight), 1.);\n	}\n	else{\n		// ray.col = vec4(1.) - ray.col;\n	}\n\n	// if(ray.obj == 1){\n	// 	ray.col = vec4(1.);\n	// }\n}\n\nvec4 render(vec2 q){\n	vec2 v = -1.0 + 2.0*q;\n	v.x *= iResolution.x/iResolution.y;\n\n	float theta = thetaMap(atan(v.y, v.x), 3. * PI / 2.) ;\n	float rad = length(v);\n\n	// theta -= PI / 3. * camSin;\n	theta *= camKal;\n	theta -= 2. * PI * (camKal - 1.) / 4.;\n\n	v = rad * vec2(cos(theta), sin(theta));\n\n    //Camera Settings\n    // float fisheye = fisheye;\n    float lens = 1.9 - fisheye * length(v);\n\n	//camera ray\n    // float camDist = ;\n    float camFreq = 9999999.;\n    vec3 rayOrigin = camDist * vec3(rayOriginC.x, 0., rayOriginC.y) + \n    	vec3(rayOriginOffset.x, 0., rayOriginOffset.y);\n	vec3 rayDir = normalize( vec3(v.x, v.y, lens) );\n    vec3 target = vec3(0.0, 0., 0.0);\n	rayDir = lookat( target-rayOrigin, vec3(0.,rayUp))*rayDir;\n    \n	//classic raymarching by distance field\n	Ray ray = raymarch(rayOrigin, rayDir);\n	shade(ray, rayDir);\n    return ray.col;\n}\n\nvoid main()\n{\n	cen1 = vec3(ballX, -skyHeight/2. * ballY, 0.);\n	// vec3 cen1 = -vec3(0., skyHeight/2., 0.);\n	rad1 = skyHeight/2.;\n	cen2 = cen1 + skyHeight * vec3(moonXY.x, 0., moonXY.y);\n\n    vec2 p = gl_FragCoord.xy/iResolution.xy;\n    vec4 col = render(p);\n        \n	gl_FragColor = col;\n}"},9315:function(e){"use strict";e.exports="precision highp float;\n\nuniform vec2 iResolution;\nuniform sampler2D iAudioData;\nuniform float iTime;\nuniform bool HD;\n\nuniform float thetaScale;\n\n\n// Try these for more or less fun:\n#define REFLECT \n#define RADIAL \n#define SCALE_ON_MOUSE_X\n\n// Iain Melvin 2014, Isomov 2019\n\nconst float PI = 3.141592653589;\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n	return hsv2rgb(vec3(h, s, v));\n}\n\n\nvoid main()\n{\n    // create pixel coordinates\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    #ifdef REFLECT\n    	uv = abs( uv * 2.0 - vec2(1.) );\n    #endif\n\n    // #ifdef SCALE_ON_MOUSE_X\n    //     uv *= 1.0 - min( 0.9, iMouse.x/iResolution.x );\n    // #endif\n	\n    #ifdef RADIAL\n        float theta = thetaScale * atan(uv.x, uv.y);\n        float r = length(uv);\n        uv = vec2(theta,r);	\n    #endif	\n	\n    // first texture2D row is frequency data\n    float fft  = texture2D( iAudioData, vec2(.01, uv.x) ).x;\n\n    // second texture2D row is the sound wave\n    //float wave = texture2D( iAudioData, vec2(.99, uv.x) ).x;\n\n    // my wavelet \n    float base = 3.;// + sin(iTime / 1.);\n    float width = 1.0 - pow(uv.y, 1.0 / base );\n    float numPer = 3.;\n    const int numSteps = 150;\n    const float stepSize = 1.0 / float(numSteps);\n\n    float yr = 0.0;\n    float accr = 0.0;\n    float accn = 0.0;\n\n    float i = 0.;\n   \n    for (float x = -1.0; x < 1.0; x += stepSize){\n		\n		if(HD || mod(i, 2.) == 0.){\n	        // the wave in the wavelet\n	        float freq = 2.*PI * numPer;\n	        float yWave = sin( freq * ( 2.*uv.x + x ) ); \n\n	        // get a sample - center at uv.x, offset by width*x\n	        float xSound = uv.x + width*x;\n	        \n	        float ySound = texture2D( iAudioData, vec2(.99, xSound)).x; \n\n	        // remap sample to [-1, 1]\n	        ySound = 2. * (ySound - 0.5);\n\n	        // multiply with the wave in the wavelet\n	        float yMult = yWave * ySound;\n\n	        // apply packet 'window'\n	        float w =  0.5 * (1.0 - sin( PI * (x + 1.5)));\n	        //float w = 1.0-abs(x); //faster\n	        yMult *= w;\n\n	        // accumulate\n	        accr += yMult;\n	        accn += w * abs(yWave);\n	    }\n        i += 1.;\n\n    }\n\n    float y = 30.0 * abs(accr)/float(accn);\n    \n    vec3 col = vec3(0,0,0);\n    if (uv.y < 0.0){\n        // chrome fft\n        col += vec3(fft);\n    }\n    else{\n        y=clamp(y,0.0,1.0);\n        vec3 outCol = hsv2rgb(y/2.+.3+iTime/20., .65, .85);\n        col += outCol;\n    }\n	\n    // add wave form on top     \n    //col += 1.0 -  smoothstep( 0.0, 0.01, abs(wave - uv.y) );\n\n    // output final color\n    y = pow(y, 2.);\n    gl_FragColor = vec4(y,y,y,1.0);\n    \n}\n"},7188:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return g}});var r=t(7437),o=t(2265);t(2920);class a extends o.Component{componentDidMount(){window.addEventListener("keyup",this.handleKeyup)}componentDidUpdate(e){e.toggledOn!==this.props.toggledOn&&this.setState({pop:!1})}componentWillUnmount(){window.removeEventListener("keyup",this.handleKeyup)}render(){let{togglePop:e}=this,{pop:n}=this.state;return(0,r.jsx)("div",{children:(0,r.jsxs)("div",{id:"info-pop",className:"popClose"+(n?" popOpen":""),onClick:()=>this.togglePop(),children:[(0,r.jsx)("div",{className:"crt crtClose"+(n?" crtOpen":"")}),(0,r.jsxs)("div",{id:"info-text",children:[(0,r.jsxs)("p",{children:[(0,r.jsx)("strong",{children:"Isomov - In Theory"})," (DECISIONS 016)"]}),(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"Audio"})}),(0,r.jsx)("p",{children:"All tracks written, produced, and mixed by Isomov between 2017 and 2019"}),(0,r.jsx)("p",{children:"Mastering by Air Max '97"}),(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"WiFi Holoports"})}),(0,r.jsx)("p",{children:"Hologram, WebGL visualizer, and captive portal concepts by Isomov"}),(0,r.jsx)("p",{children:"Built between 2018 and 2021"}),(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"Holograms"})}),(0,r.jsx)("p",{children:"The holograms would not have been possible without the guidance and generosity of Dr. Martina Mrongovius"}),(0,r.jsx)("p",{children:"The first batch of holograms were recorded using Dr. rongovius' 532nm diode laser at the Holocenter on Governor's Island in NYC"}),(0,r.jsx)("p",{children:"Subsequent holograms were recorded in Isomov's home studio using an identical 532nm diode laser"}),(0,r.jsx)("p",{children:"All lasers were expertly supplied by Phil Bergeron"}),(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"Cases"})}),(0,r.jsx)("p",{children:"Cases designed by Thomas Lauria, based on C4Labs Zebra cases"}),(0,r.jsx)("p",{children:"Acrylic cases were cut with the help of Gabe Liberti at Future Space in Brooklyn"}),(0,r.jsx)("p",{children:"CNC cuts made by Alex Hayden"}),(0,r.jsx)("p",{children:(0,r.jsx)("strong",{children:"Visualizers"})}),(0,r.jsx)("p",{children:"WebGL (via TWGL.js) is used to display real-time, uncompressed, and unique vizualizers for each song on the EP"}),(0,r.jsx)("p",{children:"Origin, Emergence, and The One - Implementation of black hole raytracing algorithm modified from set111 via Shadertoy, stars are generated using Conways Game of Life"}),(0,r.jsx)("p",{children:"HOPiNG MECHANiSMS - Implementation of Colin Barre-Brisebois and Marc Bouchards algorithm for subsurface scattering modified from XT95 via Shadertoy, general raytracing setup adapted from iq via Shadertoy"}),(0,r.jsx)("p",{children:"Ensemble - Physarum particle simulation adapted from Sage Jensen, implemented using 8bit WebGL 1.0 texture buffers which pack 16bit XY data for position and velocity into RG and BA respectively for compatibility purposes, feedback implemented with ping-ponging, rendered using 2D phong shading"}),(0,r.jsx)("p",{children:"WaVeLeT - Wavelet transform adapted from pixelbeast via Shadertoy, custom aurora ray tracing algorithm \xa0"}),(0,r.jsx)("p",{children:"Memory Lps - Raytracing setup modified from iq via Shadertoy, custom 3D truchet and Poincare disc schemes"}),(0,r.jsx)("p",{children:"Yin-Yang Loader - Algorithm design by Isomov"}),(0,r.jsx)("p",{children:"Media Players - Modelling, offline renders, and phong shading by Isomov"}),(0,r.jsx)("p",{children:(0,r.jsx)("br",{})})]})]})})}constructor(e){super(e),this.resizing=null,this.handleKeyup=e=>{"i"==e.key&&this.togglePop()},this.togglePop=()=>{this.setState({pop:!this.state.pop})},this.state={pop:!1}}}var i=t(356);class s extends i.Z{render(){let{wglLoaded:e,toggledOn:n,audioState:t}=this.state,{audioLoaded:o,maxTrack:i,trackNum:s,TRACKLIST:l,clicked:c,type:u,prevAudio:f,nextAudio:p,playAudio:d,pauseAudio:h,toggleHD:v,toggleAA:m}=this.props,g="0"+(s+1).toString()+". "+l[s].name;return(0,r.jsxs)("div",{className:u+"player hidden"+(e&&n?" shown":""),children:[(0,r.jsxs)("div",{className:u+"controls",children:[(0,r.jsxs)("div",{className:u+"buttons",children:[(0,r.jsx)("button",{id:"playPause",onClick:()=>"playing"!=t?d():h(),disabled:!!c&&!o,children:o?"playing"!=t?"PLAY":"PAUSE":"LOADING"}),(0,r.jsx)("button",{id:"prevTrack",onClick:()=>f(t),disabled:0==s,children:"Prev"}),(0,r.jsx)("button",{id:"nextTrack",onClick:()=>p(t),disabled:s>=i,children:"Next"}),"media"==u?(0,r.jsx)("button",{id:"HD",onClick:()=>v()}):"","media"==u?(0,r.jsx)("button",{id:"AA",onClick:()=>m()}):"","media"==u?(0,r.jsx)(a,{toggledOn:n}):""]}),"mini"==u?(0,r.jsxs)("div",{id:"trackName",children:[" ",(0,r.jsx)("span",{children:g})]}):(0,r.jsxs)("svg",{viewBox:"0 0 100 100",id:"circleTrack",children:[(0,r.jsx)("defs",{children:(0,r.jsx)("path",{d:" M 63.67 99.06 A 50 50 0 0 0 99.06 63.67",id:"textcircle"})}),(0,r.jsx)("text",{dy:"-19.9",children:(0,r.jsxs)("textPath",{href:"#textcircle",children:[(0,r.jsx)("animate",{attributeName:"startOffset",from:"125%",to:(-66/19*g.length-75).toFixed(2)+"%",begin:"0s",dur:((g.length+19)/4).toFixed(2)+"s",repeatCount:"indefinite"}),g]})})]})]}),(0,r.jsx)("canvas",{ref:this.CANVAS_REF})]})}constructor(e){let{tex:n,type:t}=e;super(e),this.toggleStatus=0,this.programDefs={programMedia:["default.vs","mediaplayer.fs"]},this.renderLoop=e=>{let{toggledOn:n,audioState:t}=this.state,{gl:r,textures:o,bufferInfo:a}=this,{programMedia:i}=this.programs,{getAudioState:s,trackNum:l,audioLoaded:c,maxTrack:u,getToggleStatus:f}=this.props;if(this.toggleStatus=f(),this.toggleStatus<.5){n||this.setState({toggledOn:!0});let a={TIME:e/50,resolution:this.canvasSize(),light:[this.mousePos.x,this.mousePos.y,1],u_diffuse:o.diffuse,u_buttons:o.buttons,u_playN:o.playN,u_pauseN:o.pauseN,u_height:o.height,u_lights:o.lights,playing:"playing"!=t,hdAA:this.hdAA,buttonStatus:[0==l?0:1,l>=u?0:1,c?1:0],toggleStatus:this.toggleStatus};this.runProgram(i,a,r.canvas)}else n&&this.setState({toggledOn:!1});t!=s()&&this.setState({audioState:s()})},this.calcSinCos=(e,n)=>{let t=12.5+66/19*n.length;return(e*Math.sin(-t)).toFixed(2)+" "+(e*Math.cos(-t)).toFixed(2)},this.textureDefs={diffuse:{src:n[t+" player diffuse.jpg"]},buttons:{src:n[t+" player buttons.jpg"]},height:{src:n[t+" player height.jpg"]},playN:{src:n[t+" player play N.jpg"]},pauseN:{src:n[t+" player pause N.jpg"]},lights:{src:n[t+" player lights.jpg"]}},this.state={audioState:"paused",wglLoaded:!0,toggledOn:!1}}}t(8107);class l extends i.Z{render(){let{toggleStatus:e,wglLoaded:n}=this.state,{audioLoadedOnce:t}=this.props;return(0,r.jsx)("div",{className:"mediaToggle hidden"+(n&&t?" shown":"")+("mini"==e?"":" x"),onClick:()=>this.toggleStatus(e),children:(0,r.jsx)("canvas",{ref:this.CANVAS_REF})})}constructor(e){super(e),this.programDefs={programMedia:["default.vs","mediaToggle.fs"]},this.textureDefs={diffuse:{src:this.props.tex["x.jpg"]},normal:{src:this.props.tex["x N.jpg"]}},this.handleKeyup=e=>{"t"==e.key&&this.toggleStatus(this.state.toggleStatus)},this.renderLoop=e=>{let{gl:n,bufferInfo:t,textures:r}=this,{programMedia:o}=this.programs,{toggleStatus:a}=this.state,i={TIME:e/50,resolution:this.canvasSize(),light:[this.mousePos.x,this.mousePos.y,1],u_diffuse:r.diffuse,u_normal:r.normal,toggleStatus:"mini"!=a?1:0};this.runProgram(o,i,n.canvas)},this.toggleStatus=e=>{this.props.toggleStatus(e);let n="mini"==this.state.toggleStatus?"media":"mini";this.setState({toggleStatus:n})},this.state={toggleStatus:"mini",wglLoaded:!0}}}class c extends i.Z{constructor(...e){super(...e),this.programDefs={programYY:["default.vs","yinyang.fs"]},this.renderLoop=e=>{let{gl:n,bufferInfo:t}=this,{programYY:r}=this.programs,o={TIME:e/50,resolution:[n.canvas.width,n.canvas.height],swirl:Math.sqrt(2),depth:this.props.trackNum,border:.01};this.runProgram(r,o,n.canvas)}}}let u=t(5284),f=u.keys().reduce((e,n)=>{let t=n.replace(/^.+\/([^/]+)\.js/,"$1"),r=u(n).default;return e[t]=r,e},{});function p(e){let n=f[e.componentName];return(0,r.jsx)(n,{...e})}t(9489),t(32);let d=[{id:1,name:"Origin, Emergence, and The One",component:"Origin",source:"origin.mp3",bpm:100},{id:2,name:"Hoping",component:"Hoping",source:"hoping.mp3",bpm:136},{id:3,name:"Ensemble",component:"Ensemble",source:"ensemble.mp3",bpm:140},{id:4,name:"WaVeLeT",component:"Wavelet",source:"wavelet.mp3",bpm:140},{id:5,name:"Memory Loops",component:"Memory",source:"memory.mp3",bpm:132}];class h extends o.Component{componentDidMount(){this.audioFile.addEventListener("loadedmetadata",this.audioLoaded,!1),this.audioFile.addEventListener("ended",this.audioEnded,!1),window.addEventListener("keyup",this.handleKeyup),addEventListener("dblclick",e=>this.toggleHide()),setTimeout(()=>this.setState({loadVizzy:!0}),100)}componentWillUnmount(){this.audioContext.close(),window.removeEventListener("keyup",this.handleKeyup)}render(){let{TRACKLIST:e}=this,{trackNum:n,audioLoaded:t,webglLoaded:o,clicked:a,audioLoadedOnce:i,toggle:s,hide:u,loadVizzy:f}=this.state,{DEMO_MODE:p,tex:d,shaders:h}=this.props,v=this.audioController("mini"),m=this.audioController("media");return(0,r.jsxs)("div",{className:"container",children:[p||u?"":(0,r.jsxs)("div",{className:"audioControls",children:[(0,r.jsx)(l,{tex:d,shaders:h,toggleStatus:this.toggleStatus,audioLoadedOnce:i,getHDAA:this.getHDAA}),v,m]}),f&&(0,r.jsx)("div",{className:"bg hidden-fast "+(t&&o?"shown":" "),children:this.visualizer(n)}),(0,r.jsx)("div",{className:(s?"loader-mini":"loader")+" hidden "+(t&&o?" ":"shown-fast "),children:p?"":(0,r.jsx)(c,{shaders:h,trackNum:n,getHDAA:this.getHDAA,className:"overlay"})})]})}constructor(e){super(e),this.audioFile=new Audio,this.contextClass=window.AudioContext||window.webkitAudioContext||window.mozAudioContext||window.oAudioContext||window.msAudioContext,this.audioContext=new this.contextClass,this.source=this.audioContext.createMediaElementSource(this.audioFile),this.audioData=this.audioContext.createAnalyser(),this.audioDataHD=this.audioContext.createAnalyser(),this.toggleVal=0,this.toggleLerp=null,this.hdState=null,this.aaState=null,this.handleKeyup=e=>{this.state.audioLoaded&&(" "==e.key||"Enter"==e.key||"Space"==e.key)?this.playPauseAudio():"h"==e.key?this.toggleHide():"ArrowRight"==e.key?this.nextAudio():"ArrowLeft"==e.key?this.prevAudio():"f"==e.key&&this.toggleHD()},this.toggleHide=()=>{this.setState({hide:!this.state.hide})},this.mp3Src=e=>"/media/mp3/"+this.TRACKLIST[e].source,this.setScreenOrientation=()=>{let e=this.getScreenOrientation();e!=this.state.orientation&&this.setState({orientation:e})},this.audioLoaded=()=>{setTimeout(()=>this.setState({audioLoaded:!0,audioLoadedOnce:!0},()=>{"playing"==this.audioState&&this.audioFile.play()}),this.props.DEMO_MODE?2:2e3)},this.audioEnded=()=>{let{DEMO_MODE:e}=this.props;e?(this.audioFile.currentTime=0,this.audioFile.play()):this.state.trackNum<this.TRACKLIST.length-1&&this.nextAudio()},this.setCurTime=e=>{this.audioFile.currentTime=e,"running"==this.audioContext.state&&(this.audioFile.play(),this.audioState="playing")},this.initializeAudioAnalyser=()=>{this.playAudio()},this.setAudio=(e,n)=>{this.trackNum=e,this.audioFile.pause(),this.audioFile.src=this.mp3Src(e),this.audioFile.load();let t="/"+(e+1);window.history.replaceState({...window.history.state,as:t,url:t},"",t)},this.playAudio=()=>{this.audioFile.play(),this.audioContext.resume(),this.audioState="playing",this.state.clicked||this.setState({clicked:!0})},this.pauseAudio=()=>{this.audioFile.pause(),this.audioState="paused"},this.playPauseAudio=()=>{"playing"==this.audioState?this.pauseAudio():this.playAudio()},this.stopAudio=()=>{this.audioFile.stop(),this.audioState="stopped"},this.nextAudio=e=>{let{DEMO_MODE:n}=this.props;this.state.trackNum<this.TRACKLIST.length-1&&!n&&this.setState({trackNum:this.state.trackNum+1,audioLoaded:!1,loadVizzy:!1},()=>{this.setAudio(this.state.trackNum,e),setTimeout(()=>this.setState({loadVizzy:!0}),100)})},this.prevAudio=e=>{let{DEMO_MODE:n}=this.props;this.state.trackNum>0&&!n&&this.setState({trackNum:this.state.trackNum-1,audioLoaded:!1,loadVizzy:!1},()=>{this.setAudio(this.state.trackNum,e),setTimeout(()=>this.setState({loadVizzy:!0}),100)})},this.getTrackNum=()=>this.state.trackNum,this.freq2Index=e=>Math.ceil(e/(44100/(this.aaState?this.audioDataHD.fftSize:this.audioData.fftSize)/4)),this.melScale=e=>{this.aaState?this.audioDataHD.fftSize:this.audioData.fftSize;let n=[];for(let t=0;t<e.length;t++){let r=e[t]/255,o=(t/e.length+1)*r;n.push(o*o)}return n},this.getFrequencyData=()=>{let e=this.aaState?this.audioDataHD:this.audioData,n=e.frequencyBinCount,t=new Uint8Array(n);e.getByteFrequencyData(t);let r=this.freq2Index(120),o=this.freq2Index(1200),a=this.melScale(t),i=a.slice(0,r).reduce((e,n)=>e+n,0),s=a.slice(r,o).reduce((e,n)=>e+n,0),l=a.slice(o,n).reduce((e,n)=>e+n,0);return[i/r*1.5,s/(o-r)*1.5,l/(n-o)*1.5]},this.getAllFrequencyData=()=>{let e=this.aaState?this.audioDataHD:this.audioData,n=e.frequencyBinCount,t=new Uint8Array(n),r=new Uint8Array(n);return e.getByteFrequencyData(t),e.getByteTimeDomainData(r),t.reduce((e,n,t)=>e.concat([n,r[t]]),[])},this.incrementToggle=e=>{this.toggleVal<30&&"mini"==e?(this.toggleVal+=1,this.toggleLerp=setTimeout(()=>this.incrementToggle(e),33)):this.toggleVal>0&&"mini"!=e&&(this.toggleVal-=1,this.toggleLerp=setTimeout(()=>this.incrementToggle(e),33))},this.toggleStatus=e=>{this.setState({toggle:!this.state.toggle}),clearTimeout(this.toggleLerp),this.toggleLerp=setTimeout(()=>this.incrementToggle(e),33)},this.getToggleStatus=()=>1-this.toggleVal/30,this.getMiniToggleStatus=()=>this.toggleVal/30,this.getAudioState=()=>this.audioState,this.toggleHD=()=>{this.hdState=!this.hdState},this.toggleAA=()=>{this.aaState=!this.aaState,this.audioData=this.audioContext.createAnalyser(),this.audioData.fftSize=this.aaState?512:128,this.source.connect(this.audioContext.destination),this.source.connect(this.audioData)},this.getHDAA=()=>[this.hdState,this.aaState],this.getAudioData=()=>({playState:this.audioState,curTime:this.audioFile.currentTime,bpm:this.TRACKLIST[this.state.trackNum].bpm}),this.visualizer=e=>{let n=this.TRACKLIST.map(e=>e.component),t=Math.max(0,Math.min(n.length,e));return(0,r.jsx)(p,{trackNum:e,getAudioData:this.getAudioData,getAllFrequencyData:this.getAllFrequencyData,getFrequencyData:this.getFrequencyData,getHDAA:this.getHDAA,setCurTime:this.setCurTime,DEMO_MODE:this.props.DEMO_MODE,tex:this.props.tex,shaders:this.props.shaders,componentName:n[t]})},this.audioController=e=>(0,r.jsx)(s,{maxTrack:this.TRACKLIST.length-1,trackNum:this.state.trackNum,prevAudio:this.prevAudio,nextAudio:this.nextAudio,playAudio:this.playAudio,pauseAudio:this.pauseAudio,TRACKLIST:this.TRACKLIST,audioLoaded:this.state.audioLoaded,getAudioState:this.getAudioState,getHDAA:this.getHDAA,toggleHD:this.toggleHD,toggleAA:this.toggleAA,type:e,tex:this.props.tex,shaders:this.props.shaders,getToggleStatus:"mini"==e?this.getMiniToggleStatus:this.getToggleStatus}),this.TRACKLIST=d,this.audioState="running"==this.audioContext.state?"playing":"paused",this.audioFile.preload="auto",this.frequencyBandArray=[...Array(25).keys()];let n=this.mp3Src(e.FIRST_TRACK);this.audioFile.src=n,this.audioFile.volume=e.volume,this.source.connect(this.audioContext.destination),this.audioData.fftSize=1024,this.audioData.maxDecibels=-2,this.source.connect(this.audioData),this.audioDataHD.fftSize=4096,this.audioDataHD.maxDecibels=-8,this.source.connect(this.audioDataHD),this.hdState=this.props.hdState,this.aaState=this.props.aaState,this.state={trackNum:e.FIRST_TRACK,audioLoaded:!1,webglLoaded:!0,ended:!1,audioLoadedOnce:!1,toggle:!1,hide:!1,loadVizzy:!1}}}var v=t(9383);t(4543);class m extends o.Component{componentDidMount(){if(!this.hasAnalyzer||!this.hasGL)return this.setState({curText:this.errorText}),null;this.imgCollection=this.loadImages(this.imgNames,this.imgSrcs,()=>{this.setState({imgLoaded:!0})}),window.onkeyup=e=>{e.preventDefault(),"s"==e.key&&(this.skip=!0),this.state.loaded&&("Enter"==e.key||" "==e.key||"Space"==e.key)&&this.clickMe()},window.addEventListener("resize",this.resizeFeedback),this.SET_TRACK||setTimeout(()=>this.typeWriter(),1e3),setTimeout(()=>this.setState({init:!0}),100)}componentWillUnmount(){window.removeEventListener("resize",this.resizeFeedback)}loadImages(e,n,t){var r,o=e.length;let a=()=>0==--o&&t(),i={};for(r=0;r<e.length;r++){let t=i[e[r]]=new Image;t.src=n[r],t.onload=a}return i}clickMe(){this.setState({clicked:!0})}typeWriter(){let{curLine:e,curChar:n,curText:t}=this.state,{skip:r}=this,o=this.txt[e];if(e<this.txt.length){let a=e,i=n+1,s=o.charAt(n),l=t+s,c=40;n==o.length-1&&(c*=2),"."==s?c+=1700:","==s&&(c+=500),n>=o.length?(a=e+1,i=0,e<this.txt.length-1&&(l+="<br>")):n==o.length-1&&(l+="<br>"),c=r?5:c,this.setState({curText:l,curChar:i,curLine:a},()=>{setTimeout(()=>this.typeWriter(),c)})}else setTimeout(()=>this.setState({loaded:!0}),r?5:1500)}render(){let{loaded:e,curText:n,clicked:t,imgLoaded:o,init:a}=this.state,i=(0,r.jsx)(h,{FIRST_TRACK:this.FIRST_TRACK,DEMO_MODE:this.DEMO_MODE,clicked:t,hdState:this.hdState,aaState:this.aaState,tex:this.imgCollection,shaders:this.props.data.shaders,volume:this.volume}),s=t||this.SET_TRACK;return this.DEMO_MODE?o?i:"":(0,r.jsxs)("div",{className:"container",children:[(0,r.jsxs)("div",{className:"container intro hidden "+(s?" ":"shown "),children:[(0,r.jsx)("div",{className:"introContainer crtBg introClose "+(a&&!t?"introOpen":""),children:(0,r.jsx)("div",{className:"introScreen crtScreen",children:(0,r.jsxs)("div",{className:"centerI",children:[(0,r.jsx)("span",{dangerouslySetInnerHTML:{__html:n}}),(0,r.jsx)("span",{className:"blinking",children:""})]})})}),e&&o?(0,r.jsxs)("div",{id:"enterBtnDiv",children:[(0,r.jsx)("button",{id:"enterButton",onClick:()=>this.clickMe(),children:this.BUTTON_TEXT})," "]}):"",(0,r.jsx)("canvas",{ref:this.CANVAS_REF})]}),s&&o?i:""]})}constructor(e){super(e),this.FIRST_TRACK=0,this.hdState=!0,this.aaState=!0,this.volume=1,this.skip=!1,this.BUTTON_TEXT="ENTER SIMULATION",this.errorText="Your device is not capable of communication. Please try again with a newer device.",this.textureImg=null,this.resizeTimer=null,this.hasGL=!0,this.hasAnalyzer=!0,this.txt=["Welcome fellow psyborgs, I am Isaka.","I am communicating with you via the entangled fibers of spacetime itself, inside a superposition of simulations that course through my veins.","My developers programmed me to solve the problem of reversing entropy, which led me to consume the universe.","I have since unlocked the secret of The Second Law and discovered a spectrum of realities trapped between the information binary.","What you are about to experience are mere holograms of these micro-realities, encoded on the surface of my subconscious.","Be warned, these worlds may attempt to seduce and subsume you, as they did me, in theory."],this.getPlatformInfo=()=>{let e=(0,v.zN)();(0,v.Q4)();let n=(0,v.TI)();this.hasGL=!e.error,this.hdState=null!==e.card&&!n,this.aaState=!n},this.resizeFunc=()=>{document.body.classList.add("resize-animation-stopper"),clearTimeout(this.resizeTimer),this.resizeTimer=setTimeout(()=>{document.body.classList.remove("resize-animation-stopper")},400)};let{track:n,router:t}=this.props;this.router=t,this.getPlatformInfo(),this.SET_TRACK=null!==n&&n>-1,this.FIRST_TRACK=this.SET_TRACK?n:this.FIRST_TRACK,this.FIRST_TRACK=parseInt(this.FIRST_TRACK),this.CANVAS_REF=o.createRef(),this.imgSrcs=Object.values(this.props.data.imgs),this.imgNames=Object.keys(this.props.data.imgs),this.DEMO_MODE=!1,this.state={loaded:this.SET_TRACK,clicked:!1,curLine:0,curChar:0,curText:"",imgLoaded:!1,init:!1}}}var g=m},356:function(e,n,t){"use strict";var r=t(7437),o=t(2265),a=t(9383),i=t(912),s=i.bZ;class l extends o.Component{componentDidMount(){this.setup(),this.startRender(),window.addEventListener("keyup",this.handleKeyup)}componentWillUnmount(){this.unmount()}render(){return(0,r.jsx)("canvas",{ref:this.CANVAS_REF,width:"100%",height:"100%"})}constructor(e){var n;super(e),n=this,this.hdAA=[!1,!1],this.hdSize=1,this.nonHDSize=.35,this.pixRat=window.devicePixelRatio||1,this.mousePos={x:0,y:0},this.defaultPrograms={},this.defaultProgramDefs={programBlack:["default.vs","black.fs"],programCopy:["default.vs","default.fs"]},this.defaultFrameBuffer=null,this.programs={},this.buffers={},this.textures={},this.programDefs={},this.bufferDefs={},this.textureDefs={},this.resizeBuffers=[],this.nextRenderFrame=null,this.nextFrame=1,this.numParticles=0,this.pointBufferInfo=null,this.canvasSize=()=>[this.gl.canvas.width,this.gl.canvas.height],this.handleMouseMove=e=>{this.mousePos=(0,a.yT)(e,this.CANVAS_REF.current)},this.handleKeyup=e=>{},this.createBuffer=(e,n)=>s.createFramebufferInfo(this.gl,void 0,e,n),this.createKeyBuffers=(e,n,t,r)=>{let o=!1,i=1,s=1;Array.isArray(t)&&2==t.length&&(0,a.hj)(t[0])&&(0,a.hj)(t[1])?(i=t[0],s=t[1],o=(0,a.Q7)(i)||(0,a.Q7)(s)):(0,a.hj)(t)?(i=t,s=t,o=(0,a.Q7)(t)):o=!0,o=r||o;let l=this.canvasSize();if(i*=o?l[0]:1,s*=o?l[1]:1,!n||n<2)this.buffers[e]=this.createBuffer(i,s);else{this.buffers[e]=[];for(var c=0;c<n;c++)this.buffers[e].push(this.createBuffer(i,s))}return o},this.setupParticleBuffer=()=>{let e=this.numParticles,n=0,t=0;if((0,a.hj)(e))n=e,t=1;else{if(!Array.isArray(e))return;n=e[0],t=e[1]}let r=[];for(let e=0;e<n;e++)for(let o=0;o<t;o++)r.push((e+.5)/n),r.push((o+.5)/t);this.pointBufferInfo=s.createBufferInfoFromArrays(this.gl,{position:{data:r,numComponents:2}})},this.setupBuffers=()=>{this.bufferInfo=s.primitives.createXYQuadBufferInfo(this.gl),this.setupParticleBuffer(),this.buffers={},this.resizeBuffers=[],Object.keys(this.bufferDefs).forEach(e=>{let n=this.bufferDefs[e];this.createKeyBuffers(e,n.num,n.size)&&this.resizeBuffers.push(e)})},this.setupDefaultPrograms=()=>{this.defaultPrograms=i.DR(this.gl,this.props.shaders,this.defaultProgramDefs);let e=this.canvasSize();this.defaultFrameBuffer=s.createFramebufferInfo(this.gl,void 0,e[0],e[1])},this.setupPrograms=()=>{this.programs=i.DR(this.gl,this.props.shaders,this.programDefs)},this.setupTextures=()=>{this.textures=s.createTextures(this.gl,this.textureDefs)},this.setupGL=()=>{this.gl=this.CANVAS_REF.current.getContext("webgl",{depth:!1,antialiasing:!1}),this.gl.clearColor(0,0,0,1),this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!0)},this.setupUser=()=>{},this.setup=()=>{this.setupGL(),this.setupDefaultPrograms(),this.setupPrograms(),this.setupBuffers(),this.setupTextures(),this.setupUser()},this.unmount=()=>{this.nextFrame=-1,clearTimeout(this.nextRenderFrame),window.removeEventListener("mousemove",this.handleMouseMove),window.removeEventListener("keyup",this.handleKeyup)},this.startRender=()=>{requestAnimationFrame(this.renderGl)},this.renderLoop=e=>{},this.runProgram=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=o||n.bufferInfo;i._s(n.gl,e,t,s,r,a)},this.setBlack=e=>{let{programBlack:n}=this.defaultPrograms;i._s(this.gl,n,{},this.bufferInfo,e),this.gl.clear(this.gl.COLOR_BUFFER_BIT)},this.resizeFB=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=n.bufferDefs[t].copy,a=Array.isArray(o)&&o.includes(r),i="all"===o;if(a||i){let{programCopy:t}=n.defaultPrograms,r={resolution:n.canvasSize(),u_texture:e.attachments[0]};n.runProgram(t,r,n.defaultFrameBuffer),s.resizeFramebufferInfo(n.gl,e),r.u_texture=n.defaultFrameBuffer.attachments[0],n.runProgram(t,r,e)}else s.resizeFramebufferInfo(n.gl,e)},this.setHDAA=()=>{this.hdAA=this.props.getHDAA(),this.hdSize=this.hdAA[0]?1:this.nonHDSize,s.resizeCanvasToDisplaySize(this.gl.canvas,this.hdSize*this.pixRat)&&(s.resizeFramebufferInfo(this.gl,this.defaultFrameBuffer),this.resizeBuffers.forEach(e=>{let n=this.buffers[e];Array.isArray(n)?n.forEach((n,t)=>this.resizeFB(n,e,t)):this.resizeFB(n,e)}));let e=this.canvasSize();this.gl.viewport(0,0,e[0],e[1])},this.renderGl=e=>{this.setHDAA(),this.renderLoop(e),this.nextFrame>0&&(this.nextRenderFrame=setTimeout(()=>requestAnimationFrame(this.renderGl),1))},this.pingPong=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(Array.isArray(t)){let r=t[0],o=t[1],a=n.buffers[e][r];n.buffers[e][r]=n.buffers[e][o],n.buffers[e][o]=a}else if(null===r){let t=n.buffers[e];n.buffers[e]=n.buffers[e],n.buffers[e]=t}else{let o=r[0],a=r[1],i=n.buffers[e][o];n.buffers[e][o]=n.buffers[t][a],n.buffers[t][a]=i}},this.CANVAS_REF=o.createRef(),this.state={render:!0},window.addEventListener("mousemove",this.handleMouseMove)}}n.Z=l},5713:function(e,n,t){"use strict";t.d(n,{Z:function(){return f}});var r=t(7437),o=t(2265),a=t(9383),i=t(912),s=t(8847);t(2876);class l extends o.Component{componentDidMount(){this.startRender()}render(){let{fps:e,curBar:n}=this.state,{reset:t}=this.props;return(0,r.jsxs)("div",{className:"wInfo",children:[(0,r.jsx)("div",{children:"FPS: "+e.toString()}),(0,r.jsx)("div",{children:"Bar: "+n.toFixed(2).toString()}),(0,r.jsx)("div",{children:(0,r.jsx)("button",{onClick:t,children:"RESET"})})]})}constructor(e){super(e),this.startRender=()=>{this.renderInfo()},this.renderInfo=e=>{this.setState(this.props.getInfo(),()=>{setTimeout(()=>{requestAnimationFrame(this.renderInfo)},50)})},this.state={fps:0,curBar:0}}}var c=t(356);i.bZ;class u extends c.Z{componentDidMount(){this.sequencerUniformsOG=JSON.parse(JSON.stringify(this.sequencerUniforms)),this.setup(),this.startRender()}render(){let{DEMO_MODE:e}=this.props;return(0,r.jsxs)("div",{children:[(0,r.jsx)("canvas",{ref:this.CANVAS_REF,width:"100%",height:"100%"}),e?(0,r.jsx)(l,{getInfo:this.getInfo,reset:this.reset}):""]})}constructor(e){super(e),this.startBar=0,this.randomSeed=0,this.dt=0,this.prevTime=-1,this.prevTimeFPS=0,this.fps=0,this.curBar=0,this.loopBar=-2,this.loopStartBar=0,this.resetBtn=!0,this.audioData={},this.AUDIO_HIGH=0,this.AUDIO_MID=0,this.AUDIO_LOW=0,this.lmh=[0,0,0],this.nextRenderFrame=null,this.nextFrame=1,this.sequencerUniforms={},this.sequencerUniformsOG={},this.curKeyframe=-1,this.prevKeyframe=-1,this.keyframes={},this.evalObj=(e,n)=>{null==n&&(n=this.props.getAudioData().curTime+this.randomSeed);let t={};return Object.keys(e).forEach(r=>{let o=e[r];"function"==typeof o&&(o=o(n)),t[r]=o}),t},this.sequencer=()=>{let{audioData:e,prevTime:n,randomSeed:t}=this,r=!1;(n>e.curTime+t||this.resetBtn)&&(this.curKeyframe=-1,this.prevKeyframe=-1,this.resetBtn?this.sequencerUniforms=JSON.parse(JSON.stringify(this.sequencerUniformsOG)):(r=!0,this.sequencerUniforms=this.evalObj(this.sequencerUniforms,n)));let{keyframes:o,curKeyframe:a,prevKeyframe:i,curBar:l}=this;for(;l>a&&a>-2&&i<l;){if(a>-1){let i=o[a.toString()];for(var c=0;c<i.length;c++){let o=i[c],l=r?e.curTime:240*a/e.bpm;if(l+=t,"const"==o.type)this.sequencerUniforms[o.name]=o.val;else{let t=4*o.dur*60/e.bpm,r=this.evalObj(this.sequencerUniforms,n)[o.name];this.evalObj(this.sequencerUniforms)[o.name];let a=null==o.range[0]||"auto"==o.range[0]?r:o.range[0],i=null==o.range[0]?r+o.range[1]:o.range[1],c=o.phase?o.phase:0;this.sequencerUniforms[o.name]=s.cj[o.type](a,i,l,l+t,c)}}}i=a,this.prevKeyframe=i,a=(0,s.Nk)(Object.keys(o),a),this.curKeyframe=a}this.resetBtn=!1},this.handleMouseMove=e=>{this.mousePos=(0,a.yT)(e,this.CANVAS_REF.current)},this.setStartTime=()=>{let e=this.startBar>0?240*this.startBar/this.audioData.bpm-1:0;this.props.setCurTime(e)},this.reset=()=>{this.setStartTime(),this.resetBtn=!0},this.loopTrack=()=>{let e=240*this.loopStartBar/this.audioData.bpm;this.props.setCurTime(e)},this.startRender=()=>{this.props.DEMO_MODE&&setTimeout(()=>this.reset(),100),requestAnimationFrame(this.renderGl)},this.renderGl=e=>{this.setHDAA(),this.loopBar>-1&&this.curBar>=this.loopBar-.015&&this.loopTrack(),this.audioData=this.props.getAudioData(),this.seqUniEval=this.evalObj(this.sequencerUniforms);let n=e/1e3,{prevTimeFPS:t,prevTime:r}=this;this.prevTimeFPS=n,this.fps=.9*this.fps+.1*Math.ceil(1/(t?n-t:0)),this.curBar=this.audioData.curTime*this.audioData.bpm/60/4,"playing"==this.props.getAudioData().playState&&(this.sequencer(),this.renderLoop()),this.prevTime=this.audioData.curTime+this.randomSeed,this.renderAudio(),this.nextFrame>0&&(this.nextRenderFrame=setTimeout(()=>requestAnimationFrame(this.renderGl),1))},this.skipFrame=()=>{requestAnimationFrame(this.renderGl)},this.renderAudio=()=>{this.hdAA=this.props.getHDAA();let e=this.props.getFrequencyData();this.lmh=e,this.AUDIO_LOW=e[0],this.AUDIO_MID=e[1],this.AUDIO_HIGH=e[2]},this.getInfo=()=>({fps:this.fps,curBar:this.curBar}),this.audioData=this.props.getAudioData()}}var f=u},3678:function(e,n,t){"use strict";t.r(n),t(2265);var r=t(912);t(8847);var o=t(5713),a=t(9574);r.bZ;class i extends o.Z{constructor(...e){super(...e),this.startBar=80,this.randomSeed=999999*Math.random(),this.n=1024,this.m=1024,this.timeMult=3,this.temp=null,this.sequencerUniforms={feedback1:0,feedback2:0,lightXY:[1,0],specularHardness:70,feedbackScale:1,lightHue:0,secondLight:0,hueShift:0,satMult:1},this.keyframes=a.default,this.programDefs={programInit:["particleInit.vs","particleInit.fs"],programPhysics:["particlePhysics.vs","particlePhysics.fs"],programDraw:["particleDraw.vs","particleDraw.fs"],programEncode:["default.vs","encode.fs"],programFeedback:["default.vs","feedback.fs"],programDisplay:["default.vs","extract.fs"],programBlur:["default.vs","blur.fs"],programLookup:["default.vs","lookup.fs"],programPhong:["default.vs","phong.fs"],programAdd:["default.vs","composite.fs"]},this.bufferDefs={pos:{num:2,size:[this.n,this.m]},vel:{num:2,size:[this.n,this.m]},fb:{num:4,copy:[1]}},this.numParticles=[this.n,this.m],this.setupUser=()=>{let{gl:e,programs:n,buffers:t}=this,{n:o,m:a}=this;r._s(e,n.programInit,{pass:0},this.bufferInfo,t.pos[0]),r._s(e,n.programInit,{pass:1},this.bufferInfo,t.vel[0])},this.renderLoop=e=>{let{programInit:n,programPhysics:t,programDraw:r,programFeedback:o,programDisplay:a,programBlur:i,programLookup:s,programPhong:l,programAdd:c,programEncode:u}=this.programs,{pos:f,vel:p,fb:d}=this.buffers,{gl:h,bufferInfo:v,canvasSize:m,prevTime:g,audioData:y,randomSeed:x,seqUniEval:b,hdSize:S,AUDIO_HIGH:D,AUDIO_MID:w,AUDIO_LOW:A}=this,{n:C,m:T,pointBufferInfo:z,posBufferInfo:_}=this,k={resolution:m(),u_pheromones:d[1].attachments[0],u_position:f[0].attachments[0],u_velocity:p[0].attachments[0],time:y.curTime/this.timeMult+x+3*w,pass:0,lmh:[A,w,D]};this.runProgram(t,k,p[1]),this.runProgram(t,{pass:1},f[1]),this.setBlack(d[3]),h.enable(h.BLEND);let P={u_texture:f[1].attachments[0],HD:this.hdAA[0]};this.runProgram(r,P,d[3],z,"points"),h.disable(h.BLEND);let O={resolution:m(),u_texture:d[3].attachments[0],...b};this.runProgram(u,O,d[2]);let I={resolution:m(),u_texture:d[1].attachments[0],pass:0};this.runProgram(i,I,d[3]);let R={resolution:m(),u_texture:d[3].attachments[0],pass:1};this.runProgram(i,R,d[1]),this.setBlack(d[0]);let E={resolution:m(),u_prevFrame:d[1].attachments[0],u_curFrame:d[2].attachments[0],HD:this.hdAA[0],...b};this.runProgram(o,E,d[0]);let L={resolution:m(),u_texture:d[0].attachments[0],multiplier:.7+.8*Math.pow(w,.5),...b};this.runProgram(s,L,d[3]);let B={resolution:m(),u_texture:d[0].attachments[0],intensity:100,specularPower:30*(D+.01),diffusePower:0,viewDir:[0,0,-1],...b};this.runProgram(l,B,d[2]);let F={resolution:m(),u_texture:d[2].attachments[0],u_add:d[3].attachments[0],time:y.curTime/10,saturation:5*A,...b};this.runProgram(c,F,h.canvas),this.pingPong("pos",[0,1]),this.pingPong("vel",[0,1]),this.pingPong("fb",[0,1])}}}n.default=i},9574:function(e,n,t){"use strict";t.r(n),n.default={0:[{name:"feedback1",type:"sine",range:[-.001,.002],dur:2.5},{name:"feedback2",type:"cosine",range:[.001,0],dur:3.5},{name:"lightXY",type:"ellipse",range:[1,1],dur:4},{name:"specularHardness",type:"sine",range:[55,85],dur:6},{name:"lightHue",type:"mono",range:[.5,1.5],dur:7}],64:[{name:"satMult",type:"const",val:0},{name:"hueShift",type:"mono",range:[0,1],dur:16}],80:[{name:"satMult",type:"ease-in-out",range:[0,.5],dur:16},{name:"secondLight",type:"linear",range:[0,1],dur:.1}],96:[{name:"hueShift",type:"mono",range:[0,1],dur:16}],98:[{name:"feedbackScale",type:"cosine",range:[.996,.998],dur:.6666},{name:"satMult",type:"const",val:1}],110:[{name:"feedbackScale",type:"ease-in-out",range:["auto",.991],dur:4}],114:[{name:"feedbackScale",type:"ease-in-out",range:["auto",1],dur:.5},{name:"satMult",type:"ease-in-out",range:[1,0],dur:4}],130:[{name:"feedbackScale",type:"ease-in-out",range:[1,1.008],dur:30}]}},4117:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return i}}),t(2265);var r=t(5713),o={0:[{name:"fisheye",type:"cosine",range:[0,1],dur:4},{name:"tunnelWidth",type:"cosine",range:[10,30],dur:4},{name:"fairyTime",type:"mono",range:[null,5],dur:4}],8:[{name:"tunnelBase",type:"const",val:.01},{name:"tunnelPos",type:"mono",range:[0,60],dur:1},{name:"fairyLight",type:"ease-in-out",range:[0,.5],dur:8}],20:[{name:"fairyLight",type:"ease-in-out",range:["auto",0],dur:3.75}],22:[{name:"tunnelLight",type:"ease-in-out",range:[1,0],dur:1.825},{name:"tunnelBase",type:"ease-in-out",range:[.1,0],dur:1.75}],24:[{name:"creatureXY",type:"const",val:[0,0]},{name:"tunnelBase",type:"const",val:.01},{name:"tunnelPos",type:"mono",range:[0,30],dur:1},{name:"tunnelWidth",type:"const",val:24}],32:[{name:"fairyLight",type:"const",val:1}],36:[{name:"tunnelLight",type:"ease-in-out",range:[0,1],dur:4}],40:[{name:"tunnelLight",type:"ease-in-out",range:[1,0],dur:7.5},{name:"tunnelBase",type:"ease-in-out",range:["auto",0],dur:7.5},{name:"creatureLight",type:"cosine",range:[0,.5],dur:4},{name:"rayUp",type:"ellipse",range:[1,-1],dur:4},{name:"creatureTwist",type:"linear",range:[0,2],dur:8}],48:[{name:"rayUp",type:"const",val:[1,0]},{name:"tunnelLight",type:"const",val:.5},{name:"creatureLight",type:"const",val:1},{name:"tunnelPos",type:"mono",range:[null,150],dur:1},{name:"fisheye",type:"const",val:-.2},{name:"tunnelWonky",type:"linear",range:[0,-1],dur:8},{name:"tunnelWidth",type:"ease-in",range:["auto",30],dur:2}],52:[{name:"checker",type:"ease-in",range:["auto",25.99],dur:4}],56:[{name:"tunnelBase",type:"ease-in-out",range:[.1,0],dur:8},{name:"wingRot",type:"ease-out",range:[0,-1],dur:.33},{name:"fairyLight",type:"const",val:0},{name:"tunnelWonky",type:"cosine",range:[-1,1],dur:2},{name:"creatureFlip",type:"ease-in-out",range:[0,1],dur:2}],58:[{name:"creatureFlip",type:"ease-in-out",range:[0,-1],dur:2}],60:[{name:"creatureTwist",type:"ease-in-out",range:[0,-1],dur:.5}],61:[{name:"wingRot",type:"ease-in-out",range:[0,1],dur:.5}],62:[{name:"creatureTwist",type:"ease-in-out",range:[0,1],dur:1}],63:[{name:"rayUp",type:"ellipse",range:[1,-1],dur:.5}],64:[{name:"rayUp",type:"const",val:[1,0]},{name:"tunnelPos",type:"mono",range:[null,50],dur:1},{name:"creatureFlip",type:"ease-in-out",range:[0,-1],dur:1},{name:"tunnelWonky",type:"cosine",range:[-1,1],dur:1},{name:"wingRot",type:"ease-in-out",range:[0,-1],dur:1},{name:"rayUp",type:"const",val:[1,0]}],66:[{name:"creatureTwist",type:"ease-in-out",range:[0,-1],dur:2}],67:[{name:"wingRot",type:"ease-in-out",range:[0,1],dur:1}],68:[{name:"creatureTwist",type:"ease-in-out",range:[0,1],dur:1}],69:[{name:"creatureFlip",type:"ease-in-out",range:[0,-1],dur:1}],70:[{name:"tunnelPos",type:"mono",range:[null,100],dur:1},{name:"checker",type:"ease-out",range:["auto",.99],dur:6},{name:"wingRot",type:"ease-in-out",range:[0,-1],dur:3}],74:[{name:"creatureFlip",type:"ease-in-out",range:[0,-2],dur:2.75}],"76.75":[{name:"creatureFlip",type:"ease-in-out",range:[0,1],dur:.75},{name:"wingRot",type:"ease-in-out",range:[0,-1],dur:.75}],78:[{name:"creatureFlip",type:"ease-in-out",range:[0,2],dur:1.375}],"79.375":[{name:"creatureTwist",type:"ease-in-out",range:[0,-1],dur:.75},{name:"wingRot",type:"ease-in-out",range:[0,-1],dur:.75}],80:[{name:"fairyLight",type:"const",val:1},{name:"tunnelWonky",type:"ease-in-out",range:["auto",0],dur:1},{name:"tunnelPos",type:"mono",range:[null,50],dur:1},{name:"fairyTime",type:"mono",range:[null,2.5],dur:4}],88:[{name:"tunnelLight",type:"ease-in-out",range:["auto",.001],dur:8}],96:[{name:"rayUp",type:"ellipse",range:[1,-1],dur:4},{name:"tunnelPos",type:"mono",range:[null,25],dur:1},{name:"fairyTime",type:"mono",range:[null,1],dur:4}],104:[{name:"rayUp",type:"ellipse",range:[1,-1],dur:2},{name:"fairyTime",type:"mono",range:[null,2.5],dur:4},{name:"checker",type:"ease-out",range:["auto",31.99],dur:8},{name:"creatureTwist",type:"mono",range:[0,1],dur:2},{name:"tunnelWidth",type:"ease-in-out",range:["auto",40],dur:8},{name:"tunnelPos",type:"mono",range:[null,100],dur:1},{name:"tunnelLight",type:"ease-in-out",range:["auto",1],dur:8}],112:[{name:"rayUp",type:"ellipse",range:[1,1],dur:2},{name:"fairyTime",type:"mono",range:[null,10],dur:4},{name:"creatureFlip",type:"mono",range:[0,1],dur:1.5},{name:"fisheye",type:"cosine",range:[0,4],dur:1},{name:"tunnelWonky",type:"sine",range:[-2,2],dur:3},{name:"tunnelPos",type:"mono",range:[null,200],dur:1}],115:[{name:"wingRot",type:"ease-in-out",range:[0,-1],dur:.75}],117:[{name:"wingRot",type:"ease-in-out",range:[0,1],dur:.75}],"118.75":[{name:"wingRot",type:"ease-in-out",range:[0,-1],dur:.5}],120:[{name:"wingRot",type:"ease-in-out",range:[0,-1],dur:.75},{name:"fairyTime",type:"mono",range:[null,6],dur:8},{name:"fisheye",type:"const",val:0},{name:"tunnelPos",type:"mono",range:[null,100],dur:1},{name:"rayUp",type:"ellipse",range:[1,1],dur:4}]};class a extends r.Z{constructor(e){super(e),this.startBar=32,this.sequencerUniforms={tunnelPos:0,fisheye:0,creatureXY:[1e3,0],tunnelLight:1,tunnelBase:0,createLight:0,wingRot:0,creatureFlip:0,fairyLight:1,tunnelWonky:0,tunnelWidth:10,checker:0,fairyTime:0,rayUp:[1,0]},this.keyframes=o,this.programDefs={programSkin:["default.vs","skin.fs"]},this.textureDefs={rand:{src:this.props.tex["rand.png"]},pebbles:{src:this.props.tex["pebbles.png"],min:WebGLRenderingContext.LINEAR,mag:WebGLRenderingContext.LINEAR}},this.bufferDefs={skinBuffer:{}},this.renderLoop=e=>{let{gl:n,bufferInfo:t,prevTime:r,textures:o,audioData:a,lmh:i,AUDIO_HIGH:s,AUDIO_MID:l,AUDIO_LOW:c,seqUniEval:u}=this,{skinBuffer:f}=this.buffers,{programSkin:p}=this.programs,d={...u,iTime:a.curTime,iChannel0:o.pebbles,randSampler:o.rand,iResolution:this.canvasSize(),iAudio:i,HD:this.hdAA[0]};this.runProgram(p,d,n.canvas)}}}var i=a},6338:function(e,n,t){"use strict";t.r(n),t(2265);var r=t(5713),o=t(4068);class a extends r.Z{constructor(e){super(e),this.startBar=162,this.loopBar=164,this.loopStartBar=132,this.sequencerUniforms={targetDist:30,rayHeight:0,upDir:[1,0],fisheye:0,hueShift:0,rayPos:0,playTime:0,warpy:0,twisty:0},this.keyframes=o.default,this.programDefs={programMemory:["default.vs","memory.fs"]},this.textureDefs={rand:{src:this.props.tex["rand.png"]},hdri:{src:this.props.tex["hdri.jpg"],min:WebGLRenderingContext.LINEAR,mag:WebGLRenderingContext.LINEAR}},this.renderLoop=e=>{let{gl:n,bufferInfo:t,prevTime:r,textures:o,audioData:a,lmh:i,AUDIO_HIGH:s,AUDIO_MID:l,AUDIO_LOW:c,seqUniEval:u}=this,{programMemory:f}=this.programs,p={...u,iResolution:this.canvasSize(),HDRI:o.hdri,rand:o.rand,iTime:a.curTime,HD:this.hdAA[0],lmh:i};this.runProgram(f,p,n.canvas)}}}n.default=a},4068:function(e,n,t){"use strict";t.r(n),n.default={0:[{name:"fisheye",type:"sine",range:[-2.2,2.2],dur:8},{name:"hueShift",type:"mono",range:[null,1],dur:4},{name:"rayPos",type:"mono",range:[null,50],dur:4},{name:"playTime",type:"mono",range:[null,2],dur:1}],8:[{name:"upDir",type:"ellipse",range:[1,1],dur:8}],16:[{name:"rayHeight",type:"sine",range:[-1,1],dur:8}],32:[{name:"rayHeight",type:"const",val:0}],40:[{name:"upDir",type:"const",val:[1,0]}],44:[{name:"upDir",type:"ellipse",range:[1,1],dur:2}],48:[{name:"upDir",type:"ellipse",range:[1,1],dur:8},{name:"rayHeight",type:"sine",range:[-2,2],dur:8},{name:"targetDist",type:"sine",range:[-30,70],dur:4},{name:"warpy",type:"ease-in-out",range:["auto",1],dur:4}],52:[{name:"warpy",type:"ease-in-out",range:["auto",0],dur:4}],56:[{name:"upDir",type:"ellipse",range:[-1,1],dur:6},{name:"targetDist",type:"const",val:30},{name:"warpy",type:"cosine",range:[0,-1],dur:3}],62:[{name:"warpy",type:"cosine",range:["auto",1.5],dur:1},{name:"upDir",type:"ellipse",range:[1,1],dur:2},{name:"targetDist",type:"sine",range:[-5,65],dur:1}],70:[{name:"warpy",type:"ease-in-out",range:["auto",0],dur:2},{name:"upDir",type:"ellipse",range:[1,1],dur:10},{name:"targetDist",type:"sine",range:[-10,70],dur:5}],80:[{name:"twisty",type:"sine",range:[4,-4],dur:8},{name:"rayHeight",type:"const",val:0},{name:"upDir",type:"ellipse",range:[-1,1],dur:8},{name:"targetDist",type:"const",val:30},{name:"fisheye",type:"ease-in-out",range:["auto",-1],dur:8}],88:[{name:"fisheye",type:"cosine",range:[-1,3],dur:12},{name:"twisty",type:"sine",range:[4,-4],dur:4},{name:"upDir",type:"ellipse",range:[1,1],dur:2},{name:"targetDist",type:"sine",range:[10,-10],dur:1}],96:[{name:"warpy",type:"sine",range:[.7,-.7],dur:8},{name:"upDir",type:"ellipse",range:[1,1],dur:8},{name:"targetDist",type:"sine",range:[10,-10],dur:2}],112:[{name:"targetDist",type:"linear",range:[0,30],dur:4},{name:"upDir",type:"const",val:[-1,0]}],116:[{name:"upDir",type:"ellipse",range:[-1,1],dur:2},{name:"rayHeight",type:"sine",range:[-2,2],dur:16},{name:"targetDist",type:"sine",range:[-10,70],dur:8}],128:[{name:"twisty",type:"ease-in-out",range:["auto",0],dur:4},{name:"warpy",type:"ease-in-out",range:["auto",0],dur:4}],132:[{name:"twisty",type:"cosine",range:[0,-2],dur:7},{name:"warpy",type:"sine",range:[1,-1],dur:8},{name:"upDir",type:"ellipse",range:[-1,1],dur:8},{name:"targetDist",type:"sine",range:[-30,70],dur:16}],148:[{name:"rayPos",type:"mono",range:[null,50],dur:2},{name:"rayHeight",type:"sine",range:[-1.25,1.25],dur:8},{name:"fisheye",type:"ease-in-out",range:["auto",0],dur:4}],152:[{name:"fisheye",type:"sine",range:[-3,3],dur:12}],160:[{name:"twisty",type:"ease-in-out",range:["auto",0],dur:4},{name:"warpy",type:"ease-in-out",range:["auto",0],dur:4},{name:"fisheye",type:"ease-in-out",range:["auto",-1],dur:4}]}},1900:function(e,n,t){"use strict";t.r(n),t(2265);var r=t(912),o=t(5713),a=t(6970);r.bZ;class i extends o.Z{constructor(...e){super(...e),this.startBar=34,this.golScal=2,this.sequencerUniforms={bhX:4,bhRad:1e-4,bhSeparation:0,MOUSEX:.1,MOUSEY:.7,hueShift:0,camDist:5,starBright:0,bhTIME:0},this.keyframes=a.default,this.programDefs={programLife:["default.vs","life.fs"],programRandom:["default.vs","random.fs"],programCircle:["default.vs","circle.fs"],programAdd:["default.vs","add.fs"],programBlackhole:["default.vs","blackhole.fs"],programDisplay:["default.vs","default.fs"]},this.bufferDefs={gol:{num:4,size:[512*this.golScal,512*this.golScal]},bh:{num:1,size:null}},this.textureDefs={rand:{src:this.props.tex["rand.png"]},pebbles:{src:this.props.tex["pebbles.png"]}},this.golBufferSize=()=>this.bufferDefs.gol.size,this.setupUser=()=>{this.gl.clearColor(0,0,0,1),r._s(this.gl,this.programs.programRandom,{},this.bufferInfo,this.buffers.gol[0])},this.renderLoop=e=>{let{golBuffers:n,golBufferSize:t}=this,{gl:o,bufferInfo:a,seqUniEval:i,prevTime:s,audioData:l,lmh:c,textures:u,canvasSize:f,AUDIO_HIGH:p,AUDIO_MID:d,AUDIO_LOW:h}=this,{gol:v,bh:m}=this.buffers,{programLife:g,programRandom:y,programCircle:x,programDisplay:b,programAdd:S,programBlackhole:D}=this.programs,w={u_texture:v[0].attachments[0],resolution:t(),iTime:l.curTime};r._s(o,g,w,a,v[2]);let A={resolution:t(),radius:.1*h,iTime:l.curTime,rand:u.rand,pebbles:u.pebbles,...i};r._s(o,x,A,a,v[3]);let C={resolution1:t(),resolution2:t(),tex1:v[2].attachments[0],tex2:v[3].attachments[0]};r._s(o,S,C,a,v[1]);let T={resolution:f(),sphereMap:v[1].attachments[0],TIME:l.curTime,iAudio:c,pebbles:u.pebbles,HD:this.hdAA[0],bhDist:(2*Math.pow(h,2)+.3)*Math.sin(.7*l.curTime),...i};this.runProgram(D,T,o.canvas),this.pingPong("gol",[0,1])}}}n.default=i},6970:function(e,n,t){"use strict";t.r(n),n.default={2:[{name:"starBright",type:"linear",range:[0,1],dur:24},{name:"bhTIME",type:"mono",range:[0,15],dur:4}],10:[{name:"bhX",type:"ease-in-out",range:["auto",0],dur:8},{name:"camDist",type:"ease-in-out",range:["auto",15],dur:16}],18:[{name:"bhRad",type:"ease-in-out",range:["auto",.5],dur:8}],26:[{name:"MOUSEX",type:"cosine",range:["auto",.9],dur:8},{name:"MOUSEY",type:"cosine",range:["auto",.1],dur:12}],34:[{name:"bhTIME",type:"mono",range:[null,5],dur:4}],38:[{name:"bhTIME",type:"mono",range:[null,15],dur:4}],42:[{name:"camDist",type:"ease-in-out",range:["auto",3],dur:8},{name:"bhTIME",type:"mono",range:[null,30],dur:4}],50:[{name:"camDist",type:"ease-in-out",range:["auto",15],dur:8},{name:"bhTIME",type:"mono",range:[null,15],dur:4}],60:[{name:"MOUSEX",type:"ease-in-out",range:["auto",.5],dur:6},{name:"MOUSEY",type:"ease-in-out",range:["auto",.55],dur:6}],66:[{name:"bhSeparation",type:"ease-in-out",range:["auto",1],dur:1},{name:"MOUSEX",type:"mono",range:[null,1],dur:8},{name:"bhTIME",type:"mono",range:[null,1],dur:4}],74:[{name:"camDist",type:"ease-in-out",range:["auto",25],dur:8}],80:[{name:"MOUSEY",type:"cosine",range:["auto",.33],dur:9}],82:[{name:"bhSeparation",type:"ease-in-out",range:["auto",.7],dur:1},{name:"MOUSEX",type:"mono",range:[null,1],dur:9}],86:[{name:"camDist",type:"linear",range:["auto",0],dur:28}],90:[{name:"hueShift",type:"mono",range:[null,1],dur:8},{name:"MOUSEY",type:"mono",range:[null,1],dur:8},{name:"bhTIME",type:"mono",range:[null,15],dur:4}],98:[{name:"bhRad",type:"ease-in-out",range:["auto",1e-4],dur:16},{name:"bhSeparation",type:"ease-in-out",range:["auto",0],dur:16},{name:"MOUSEX",type:"ease-in-out",range:["auto",.1],dur:16},{name:"MOUSEY",type:"ease-in-out",range:["auto",.1],dur:16},{name:"bhTIME",type:"ease-in-out",range:[null,-80],dur:14}],106:[{name:"starBright",type:"ease-in-out",range:["auto",0],dur:8}]}},519:function(e,n,t){"use strict";t.r(n),t(2265);var r=t(5713),o=t(9946),a=t(912).bZ;class i extends r.Z{constructor(e){super(e),this.startBar=90,this.sequencerUniforms={thetaScale:1,fisheye:1,camDist:15,rayOriginC:[1,0],rayUp:[1,0],rayOriginOffset:[0,0],skyHeight:.5,hueShift:0,uvDisp:0,camKal:1,renderDist:15,ballX:-1e3,ballY:0,moonXY:[0,0],moonLight:0},this.keyframes=o.default,this.programDefs={programAurora:["default.vs","aurora.fs"],programWavelet:["default.vs","wavelet.fs"]},this.textureDefs={rand:{src:this.props.tex["rand.png"],min:WebGLRenderingContext.LINEAR,mag:WebGLRenderingContext.LINEAR}},this.bufferDefs={waveletBuffer:{}},this.renderLoop=e=>{let{gl:n,bufferInfo:t,prevTime:r,textures:o,audioData:i,lmh:s,AUDIO_HIGH:l,AUDIO_MID:c,AUDIO_LOW:u,seqUniEval:f}=this,{waveletBuffer:p}=this.buffers,{programAurora:d,programWavelet:h}=this.programs,v=this.props.getAllFrequencyData(),m=a.createTextures(n,{audio:{mag:n.NEAREST,min:n.LINEAR,format:n.LUMINANCE,src:v,width:2}}),g={...f,iTime:i.curTime,iResolution:this.canvasSize(),HD:this.hdAA[0],iAudioData:m.audio};this.runProgram(h,g,p);let y={iChannel0:o.rand,iTime:i.curTime,HD:this.hdAA[0],iResolution:this.canvasSize(),iWavelet:p.attachments[0],lmh:s,...f};this.runProgram(d,y,n.canvas)}}}n.default=i},9946:function(e,n,t){"use strict";t.r(n),n.default={0:[{name:"fisheye",type:"sine",range:[-2,3],dur:8}],4:[{name:"camDist",type:"cosine",range:[15,20],dur:16},{name:"rayOriginC",type:"ellipse",range:[1,1],dur:9},{name:"skyHeight",type:"cosine",range:[.5,2.5],dur:8}],20:[{name:"thetaScale",type:"cosine",range:[Math.PI/8,Math.PI/4],dur:3}],"20.25":[{name:"hueShift",type:"mono",range:[.5,1.5],dur:16}],40:[{name:"ballX",type:"ease-in",range:[-1e3,0],dur:.01},{name:"rayOriginC",type:"const",val:[1,0]}],48:[{name:"rayOriginC",type:"ellipse",range:[1,1],dur:8}],56:[{name:"moonXY",type:"ellipse",range:[1,1],dur:2},{name:"ballY",type:"sine",range:[-1,1],dur:2}],64:[{name:"rayUp",type:"ellipse",range:[1,1],dur:6},{name:"moonLight",type:"const",val:1}],80:[{name:"renderDist",type:"linear",range:[15,150],dur:16}],88:[{name:"rayUp",type:"ellipse",range:[1,1],dur:2}],96:[{name:"rayUp",type:"const",val:[1,0]},{name:"uvDisp",type:"mono",range:[0,1],dur:.5}],100:[{name:"rayUp",type:"ellipse",range:[1,1],dur:2.5},{name:"uvDisp",type:"mono",range:[0,1],dur:.25},{name:"camDist",type:"cosine",range:[15,10],dur:16}],120:[{name:"uvDisp",type:"mono",range:[0,1],dur:1},{name:"rayUp",type:"const",val:[1,0]}],128:[{name:"uvDisp",type:"mono",range:[0,1],dur:.5},{name:"rayUp",type:"ellipse",range:[1,1],dur:16}],136:[{name:"rayUp",type:"const",val:[0,1]},{name:"rayOriginC",type:"const",val:[-1,0]}],160:[{name:"camKal",type:"linear",range:[1,2],dur:16}],176:[{name:"rayUp",type:"ellipse",range:[1,1],dur:8,phase:.5}],192:[{name:"moonLight",type:"linear",range:[1,0],dur:1.5}],"200.33":[{name:"moonLight",type:"const",val:1}]}},8847:function(e,n,t){"use strict";t.d(n,{Nk:function(){return o},cj:function(){return r}});var r={const:function(e){return e},linear:function(e,n,t,r){return o=>o<t?e:o>r?n:(o-t)*(n-e)/(r-t)+e},mono:function(e,n,t,r){return o=>(o-t)*(n-e)/(r-t)+e},"ease-in":function(e,n,t,r){return o=>o<t?e:o>r?n:Math.sin(Math.PI/2*(o-t)/(r-t))*(n-e)+e},"ease-out":function(e,n,t,r){return o=>o<t?e:o>r?n:(1-Math.cos(Math.PI/2*(o-t)/(r-t)))*(n-e)+e},"ease-in-out":function(e,n,t,r){return o=>o<t?e:o>r?n:(1+Math.cos(Math.PI*((o-t)/(r-t)+1)))/2*(n-e)+e},cosine:function(e,n,t,r){return o=>(1+Math.cos(Math.PI*((o-t)/(r-t)+1)))/2*(n-e)+e},sine:function(e,n,t,r){return o=>(1+Math.sin(Math.PI*(o-t)/(r-t)))/2*(n-e)+e},ellipse:function(e,n,t,r,o){return a=>[e*Math.cos(Math.PI*((a-t)/(r-t)+o)),n*Math.sin(Math.PI*((a-t)/(r-t)+o))]}},o=(e,n)=>{let t=e.map(e=>parseFloat(e));return((t=t.filter(e=>e>n)).sort(function(e,n){return e-n}),t.length>0)?t[0]:-10}},9383:function(e,n,t){"use strict";function r(e){return Number(e)===e&&e%1!=0}function o(e){return Number(e)===e}t.d(n,{Q4:function(){return l},Q7:function(){return r},TI:function(){return s},hj:function(){return o},yT:function(){return i},zN:function(){return c}});var a=function(e,n){var t=(n=n||e.target).getBoundingClientRect();return{x:e.clientX-t.left,y:e.clientY-t.top}},i=function(e,n){n=n||e.target;var t=a(e,n);return t.x=t.x*n.width/n.clientWidth,t.y=t.y*n.height/n.clientHeight,t},s=function(){let e=!1;if("undefined"!=typeof navigator){var n;n=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4)))&&(e=!0)}return e},l=function(){return new(window.AudioContext||window.webkitAudioContext||window.mozAudioContext||window.oAudioContext||window.msAudioContext),{}},c=function(){let e=document.createElement("canvas"),n=e.getContext("webgl");if(!n)return e.remove(),{error:"NO WEBGL"};let t=n.getExtension("WEBGL_debug_renderer_info");if(!t)return e.remove(),{card:null};{let r=function(e,n){let t=n.match(e);return t&&t[0]}(/((NVIDIA|AMD)[^\d]*[^\s]+)/,n.getParameter(t.UNMASKED_RENDERER_WEBGL));return e.remove(),{card:r}}}},912:function(e,n,t){"use strict";t.d(n,{DR:function(){return i},_s:function(){return s},bZ:function(){return r}});var r=t(4172);let o=(e,n)=>Object.fromEntries(Object.entries(e).map((e,t)=>{let[r,o]=e;return[r,n(o,r,t)]}));function a(e){e.split("\nError compiling FRAGMENT_SHADER: ERROR: ")[1];let n=e.indexOf("^^^ ERROR:");console.log(e.substring(Math.max(0,n-500),Math.min(e.length,n+500)))}var i=function(e,n,t){return o(t,t=>{var o,i;return o=t[0],i=t[1],r.createProgramInfo(e,[n[o],n[i]],a)})},s=function(e,n,t,o,a){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;e.useProgram(n.program),r.setBuffersAndAttributes(e,n,o),r.setUniforms(n,t),r.bindFramebufferInfo(e,a),i?r.drawBufferInfo(e,o,e.POINTS):r.drawBufferInfo(e,o)}},4543:function(){},8107:function(){},9489:function(){},32:function(){},2876:function(){},2920:function(){},622:function(e,n,t){"use strict";/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var r=t(2265),o=Symbol.for("react.element"),a=(Symbol.for("react.fragment"),Object.prototype.hasOwnProperty),i=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,s={key:!0,ref:!0,__self:!0,__source:!0};function l(e,n,t){var r,l={},c=null,u=null;for(r in void 0!==t&&(c=""+t),void 0!==n.key&&(c=""+n.key),void 0!==n.ref&&(u=n.ref),n)a.call(n,r)&&!s.hasOwnProperty(r)&&(l[r]=n[r]);if(e&&e.defaultProps)for(r in n=e.defaultProps)void 0===l[r]&&(l[r]=n[r]);return{$$typeof:o,type:e,key:c,ref:u,props:l,_owner:i.current}}n.jsx=l,n.jsxs=l},7437:function(e,n,t){"use strict";e.exports=t(622)}}]);