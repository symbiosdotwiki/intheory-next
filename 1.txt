1:HL["/_next/static/css/ef46db3751d8e999.css","style"]
0:["e7mrdGT-tlxmS7QqFp3sO",[[["",{"children":[["id","1","d"],{"children":["__PAGE__?{\"id\":\"1\"}",{}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ef46db3751d8e999.css","precedence":"next"}]],"$L3"]]]]
4:HL["/_next/static/css/1f3e61366d75a951.css","style"]
5:I{"id":1443,"chunks":["272:static/chunks/webpack-3c607542019d470f.js","971:static/chunks/fd9d1056-8a63aa861feeb827.js","864:static/chunks/864-50dded804bdc16dd.js"],"name":"","async":false}
6:I{"id":8639,"chunks":["272:static/chunks/webpack-3c607542019d470f.js","971:static/chunks/fd9d1056-8a63aa861feeb827.js","864:static/chunks/864-50dded804bdc16dd.js"],"name":"","async":false}
2:[null,["$","html",null,{"lang":"en","children":["$","body",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children",["id","1","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L7","$L8",null],"segment":"__PAGE__?{\"id\":\"1\"}"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/1f3e61366d75a951.css","precedence":"next"}]]}],"segment":["id","1","d"]},"styles":[]}]}]}],null]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"In Theory"}],["$","meta","2",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
9:I{"id":7188,"chunks":["750:static/chunks/e6f75348-27aa028ef5fea883.js","188:static/chunks/188-567110ce3c89c38c.js","531:static/chunks/app/[id]/page-a1b504119b3426e4.js"],"name":"","async":false}
a:T5b9,precision highp float;

uniform vec2 resolution;
// uniform vec2 center;
uniform float radius;
uniform sampler2D rand;
uniform sampler2D pebbles;
uniform float iTime;

const vec2 zOffset = vec2(37.0,17.0);
const vec2 wOffset = vec2(59.0,83.0);

vec4 texNoise(vec2 uv)   // Emulate a single texture fetch into the precalculated texture
{
    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.
    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.
    float r = texture2D( rand, mod((uv+0.5)/256.0, 1.)).r;
    float g = texture2D( rand, mod((uv+0.5 + zOffset)/256.0, 1.)).r;
    float b = texture2D( rand, mod((uv+0.5 + wOffset)/256.0, 1.)).r;
    float a = texture2D( rand, mod((uv+0.5 + zOffset + wOffset)/256.0, 1.)).r;
    
    return vec4(r, g, b, a);
}


float noise4dFast( in vec4 x )
{
    vec4 p = floor(x);
    vec4 f = fract(x);
    f = f*f*(3.0-2.0*f);
    
    vec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;
    
    vec4 s = texNoise(uv);
    return mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);
}

void main() {
	vec2 uv = 2.*(gl_FragCoord.xy / resolution - vec2(.5));
	vec4 col = vec4(vec3(0.), 1.);

	vec2 center = vec2(0.);
	center.x = 1.6 * noise4dFast(vec4(vec3(0.), iTime / 3. + 0.)) - .8;
	center.y = 1.6 * noise4dFast(vec4(iTime / 3. + 9999., vec3(0.))) - .8;

	if(length(uv-center)<radius){
		col.xyz = texture2D(pebbles, (uv-center) / radius).rgb;
	}
	gl_FragColor = col;
}b:T482,precision highp float;

uniform vec2 resolution;
uniform sampler2D u_texture;
uniform int pass;

const float BASE = 255.0;
const float scale = BASE * BASE;
const float OFFSET = 0.0;

vec2 encode(float value) {
    value = floor(value * scale + OFFSET);
    float x = mod(value, BASE);
    float y = floor(value / BASE);
    return vec2(x, y) / BASE;
}

vec4 pack(vec2 value){
	return vec4(encode(value.x), encode(value.y));
}

float decode(vec2 channels) {
    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;
}

vec2 extract(sampler2D tex, vec2 texcoord){
	vec4 valueRAW = texture2D(tex, texcoord);
	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));
}

void main() {
	float sum = 0.;

	const int count = 1;
	int length = 2 * count + 1;
	float scale = float(length * length);
	scale = float(length);

	for(int i = -count; i <= count; i++){
		// for(int j = -count; j <= count; j++){
			vec2 fragCoord = gl_FragCoord.xy + vec2(i, 0.);
			if(pass > 0){
				fragCoord = gl_FragCoord.xy + vec2(0., i);
			}
			vec2 uv = fragCoord / resolution;
			sum += extract(u_texture, uv).x / scale;
		// }
	}
	gl_FragColor = pack(vec2(sum, 0.));
}c:T983,precision highp float;

uniform float time;
uniform float saturation;
uniform vec2 resolution;
uniform sampler2D u_texture;
uniform sampler2D u_add;

uniform float lightHue;
uniform float secondLight;
uniform float hueShift;
uniform float satMult;

const float BASE = 255.0;
const float scale = BASE * BASE;
const float OFFSET = 0.0;

const float PI = 3.1415926535;

vec2 encode(float value) {
    value = floor(value * scale + OFFSET);
    float x = mod(value, BASE);
    float y = floor(value / BASE);
    return vec2(x, y) / BASE;
}

vec4 pack(vec2 value){
	return vec4(encode(value.x), encode(value.y));
}

float decode(vec2 channels) {
    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;
}

vec2 extract(sampler2D tex, vec2 texcoord){
	vec4 valueRAW = texture2D(tex, texcoord);
	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));
}

vec3 hsv2rgb(vec3 c) {
	c.r = mod(c.r, 1.);
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 thinfilm(float t, float x, float d){
	return .5*(vec3(
		cos( 2.*PI * (x) ),
		cos( 2.*PI * 1.1 * t * (x + .0) ),
		cos( 2.*PI * 1.2 * t * (x + .0) )
	) * exp(-d * t) + 1.);
}


void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec2 l = extract(u_texture, uv);
	float lh = 1. + sin(lightHue);

	vec3 tf = vec3(
		sin(lightHue * 2. * PI),
		sin(lightHue * 2.1 * PI + .5), 
		sin(lightHue * 2.3 * PI + 1.)
	);
	lh = rgb2hsv(tf).x;

	//vec3 light1 = thinfilm(3.*lh, .5, .3);// 1./saturation);
	vec3 light1 = l.x * hsv2rgb(vec3(lh, saturation * satMult, .85));
	// vec3 light2 = l.y * thinfilm(1.-l.y, lightHue, 1./saturation);
	// light2 = vec3(0.);
	vec3 light2 = l.y * hsv2rgb(vec3(lh + .5, saturation * satMult, .85));
	vec3 rgb = texture2D(u_add, uv).rgb;
	// rgb = rgb2hsv(rgb);
	// rgb = hsv2rgb(rgb + vec3(hueShift, 0., 0.));
	vec3 val = light1 + secondLight * light2 + rgb;
	gl_FragColor = vec4(val, 1.);
	// gl_FragColor = vec4(light1, 1.);
	// gl_FragColor = vec4(thinfilm(uv.x*4., .8, .2), 1.);
}d:T539,precision highp float;

uniform vec2 resolution;
uniform sampler2D u_curFrame;
uniform sampler2D u_prevFrame;
uniform float feedback1;
uniform float feedback2;
uniform float feedbackScale;
uniform bool HD;

const float BASE = 255.0;
const float RANGE = BASE * BASE;
const float OFFSET = 0.0;

vec2 encode(float value) {
    value = floor(value * RANGE + OFFSET);
    float x = mod(value, BASE);
    float y = floor(value / BASE);
    return vec2(x, y) / BASE;
}

vec4 pack(vec2 value){
	return vec4(encode(value.x), encode(value.y));
}

float decode(vec2 channels) {
    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / RANGE;
}

vec2 extract(sampler2D tex, vec2 texcoord){
	vec4 valueRAW = texture2D(tex, texcoord);
	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));
}

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec2 uvScaled = ( uv - vec2(.5) ) * feedbackScale + vec2(.5);
	// uv -= .5;
	// uv *= scale;
	// uv += .5;
	float prevFrame = extract(u_prevFrame, uvScaled).x;
	float curFrame = extract(u_curFrame, uv).x;

	// float alpha = curFrame.y;

	// prevFrame.a = 0.0;

	float feedback = 0.985 + feedback1 + feedback2;
	if(!HD){
		feedback *= .998;
	}
      

	float nextFrame = curFrame + feedback * prevFrame;

	if(nextFrame > 1.0){
		nextFrame = 1.0;
	}

	gl_FragColor = pack(vec2(nextFrame, 0.));
	
}e:T8ca,precision highp float;


uniform vec2 resolution;
uniform sampler2D u_texture;
const int numColors = 4;
uniform float multiplier;
uniform float hueShift;

const float BASE = 255.0;
const float scale = BASE * BASE;
const float OFFSET = 0.0;
const float PI = 3.1415926535897;


vec3 hsv2rgb(vec3 c) {
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsv2rgb(float c1, float c2, float c3) {
	return hsv2rgb(vec3(c1, c2, c3));
}

float decode(vec2 channels) {
    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;
}

vec2 extract(sampler2D tex, vec2 texcoord){
	vec4 valueRAW = texture2D(tex, texcoord);
	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));
}

void main () {
	vec3 colors[numColors];
	// colors[0] = hsv2rgb(0., 0., 0.);
	// colors[1] = hsv2rgb(.2, .6, .75);
	// colors[2] = hsv2rgb(.9, .75, .95);
	// colors[3] = hsv2rgb(.65, .9, .95);

	// colors[0] = hsv2rgb(0., 0., 0.);
	// colors[1] = hsv2rgb(.02, .6, .75);
	// colors[2] = hsv2rgb(.55, .75, .95);
	// colors[3] = hsv2rgb(.25, .9, .95);

	colors[0] = hsv2rgb(0. + sin(hueShift * 1. * PI) + hueShift, 0., 0.);
	colors[1] = hsv2rgb(.42 - sin(hueShift * 2. * PI), .6, .75);
	colors[2] = hsv2rgb(.95 + 1.5*sin(hueShift * 1. * PI) + hueShift, .75, .95);
	colors[3] = hsv2rgb(.15 + 2.*sin(hueShift * 2. * PI), .9, .95);

	float positions[numColors];
	positions[0] = .001;
	positions[1] = .15;
	positions[2] = .4;
	positions[3] = .999;

	vec2 uv = gl_FragCoord.xy / resolution;
	float val = extract(u_texture, uv).x;// * multiplier;
	// val = pow(val, .6);

	vec3 color = vec3(0.);

	bool found = false;

	if(positions[0] > val){
		color = colors[0];
	}
	else if(positions[numColors-1] < val){
		color = colors[numColors-1];
	}
	else{
		for(int i = 1; i < numColors; i++){
			if(positions[i] > val && !found){
				vec3 color1 = colors[i-1];
				vec3 color2 = colors[i];
				float range = positions[i] - positions[i-1];
				float alpha = (val - positions[i-1]) / range;
				color = alpha * color2 + (1.-alpha)*color1;
				found = true;
			}
		}
	}

	// color = vec3(val);

	// vec3 color = hsv2rgb(vec3(val, .5, .95));

	gl_FragColor = vec4(color, 1.);
}f:T21ee,precision highp float;

varying vec2 v_texcoord;
uniform vec2 resolution;
uniform sampler2D u_pheromones;
uniform sampler2D u_position;
uniform sampler2D u_velocity;
uniform int pass;
uniform float time;
uniform vec3 lmh;

const float BASE = 255.0;
const float scale = BASE * BASE;
const float OFFSET = 0.0;
const float PI = 3.1415926535;

float atan2(in float y, in float x)
{
    float s = (abs(x) > abs(y)) ? 1. : 0.;
    return mix(PI/2.0 - atan(x,y), atan(y,x), s);
}

float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

float noise(vec3 p){
    vec3 a = floor(p);
    vec3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);

    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
    vec4 k1 = perm(b.xyxy);
    vec4 k2 = perm(k1.xyxy + b.zzww);

    vec4 c = k2 + a.zzzz;
    vec4 k3 = perm(c);
    vec4 k4 = perm(c + 1.0);

    vec4 o1 = fract(k3 * (1.0 / 41.0));
    vec4 o2 = fract(k4 * (1.0 / 41.0));

    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

    return o4.y * d.y + o4.x * (1.0 - d.y);
}

float noise(vec2 uv, float time){
	return noise(vec3(uv, time));
}

vec2 encode(float value) {
    value = floor(value * scale + OFFSET);
    float x = mod(value, BASE);
    float y = floor(value / BASE);
    return vec2(x, y) / BASE;
}

float sinh(float x){
	return ( exp(x) - exp(-x) ) / 2.;
}

float cosh(float x){
	return ( exp(x) + exp(-x) ) / 2.;
}

float tanh(float x){
	return sinh(x) / cosh(x);
}

float sStep(float x, int nSteps, int aI){
	float a = float(aI);
	x *= 2.;
	x = mod(x, 1.);
	float h = 1. / (.00001 + float(nSteps));
	float w = h;
	// return 1. - abs(1. - h * (
	// 	1./(2.*tanh(a/2.)) * tanh(
	// 		a * (fract(x/w)-0.5)
	// 	) + .5 + floor(x/w)
	// ));
	return 1. - abs(
		1. - h * (
			.5 / tanh(a/2.) * tanh(
				a * (
					(x/w - floor(x/w)) - 0.5)
				) + .5 + floor(x/w)
			)
		);
}

vec4 pack(vec2 value){
	return vec4(encode(value.x), encode(value.y));
}

float decode(vec2 channels) {
    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;
}

vec2 extract(sampler2D tex, vec2 texcoord){
	vec4 valueRAW = texture2D(tex, mod(texcoord, 1.));
	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));
}

vec2 n2rand(float mult) {
	return vec2(
		fract(sin(dot(v_texcoord.xy * mult, vec2(12.9898, 78.233))) * 43758.5453),
		fract(sin(dot(v_texcoord.xy * 1.61803 * mult, vec2(12.9898, 78.233))) * 43758.5453)
	);
}

vec2 n2rand() {
	return n2rand(1.);
}

vec2 unitCircle(float angle){
	return vec2( cos(angle), sin(angle) );
}

vec2 unitCircleDeg(float angle){
	return unitCircle(PI*angle/180.0);
}

void main() {
	float maxVel = 1.8 + .45 * sin(time*3.111) +  + .9 * cos(time*.411);
	if(pass == 0){
		vec2 r, d, a, x, v;

		vec2 velOut, posOut;

		x = extract(u_position, v_texcoord);
		v = extract(u_velocity, v_texcoord);

		velOut = (2. * v - 1.);

		vec2 uv = x;

		float velMult = 1.;

		// sin(time*1.63)*
		float sensorDist = 33. + 32.*(pow(noise(
			uv * sStep(.0173*time, 12, 1) * 6., 
			time * .43752
		), 1.) *2. - 1.);

		// sensorDist = 30.;

		// sensorDist = 30.;

		// float sensorDist2 = 15. + 14.*(pow(noise(vec3(
		// 	uv * 1.*(1. + cos(time * 3.21334)), 
		// 	time * 15.232)
		// ), 2.) *2. - 1.);

		// float sensorDist3 = 70. + 69.*(pow(noise(vec3(
		// 	uv * 15.*(1. + cos(time * 1.21334)), 
		// 	time * 5.232)
		// ), 2.) *2. - 1.);
		float multy = sStep(.773*time, 10, 4) * 3. + 1.;
		// multy = 3.;
		// multy = pow(noise(uv * 1., time * .122), 2.) * 3. + 1.;
		float sensorDist2 = sensorDist / multy;
		float sensorDist3 = sensorDist * multy;

		// float degTurn = 1.// + 8.2*(sin(time*1.512)+1.)/2.567;
		// + 5.*(pow(noise(
		// 	uv*(2. + 3.5*sin(time*1.885)), 
		// 	time*0.7112
		// ) * 2. - 1., 33.));

		float degTurn = 20.*(2. + sin(time*.1347))*sStep(
			noise(
				uv*(sStep(time*.07742, 10, 4)*3.), 
				.2144*time
			),
		10, 6);

		float randAngle = 90.*sStep(
			noise(
				uv*(1. + sStep(time*.06342, 10, 2)*4.),
				.5131*time
			),
		16, 6);
		// randAngle = degTurn;

		// + 8.2*(sin(time*5.12)+1.)/2.56;
		degTurn = radians(degTurn);
		randAngle = radians(randAngle);

		float degRange = degTurn * sStep(.0143*time, 4, 4);

		// float degRange = 180.*sStep(300.*time, 8, 100);
		// degRange = radians(degRange);

		float curSensor = extract(u_pheromones, uv).r * 4. * (1.5+sin(time / 3.12));

		float degMulty= 1.5 * 2.-curSensor;
		float velMulty = 1.2 * curSensor;
		degRange *= curSensor;
		randAngle *= curSensor * sin(time / 1.12);
		degTurn *= 1.1 + sin(curSensor / 3.3);
		sensorDist *= pow(curSensor, 1.+sin(time*2.114));
		sensorDist2 *= curSensor;
		sensorDist3 *= curSensor;

		float velAngle = atan2(velOut.y, velOut.x);

		vec2 sensorDistScaled = sensorDist / resolution;
		vec2 sensorDistScaled2 = sensorDist2 / resolution;
		vec2 sensorDistScaled3 = sensorDist3 / resolution;


		vec2 fSensorOffset = sensorDistScaled * unitCircle(velAngle);
		vec2 lSensorOffset = sensorDistScaled * unitCircle(velAngle + degRange);
		vec2 rSensorOffset = sensorDistScaled * unitCircle(velAngle - degRange);

		float fSensor = extract(u_pheromones, uv + fSensorOffset).r;
		float lSensor = extract(u_pheromones, uv + lSensorOffset).r;
		float rSensor = extract(u_pheromones, uv + rSensorOffset).r;


		// vec2 fSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle);
		// vec2 lSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle + degRange/degMulty);
		// vec2 rSensorOffset2 = sensorDistScaled2 * unitCircle(velAngle - degRange/degMulty);

		// float fSensor2 = extract(u_pheromones, uv + fSensorOffset2).r;
		// float lSensor2 = extract(u_pheromones, uv + lSensorOffset2).r;
		// float rSensor2 = extract(u_pheromones, uv + rSensorOffset2).r;


		// vec2 fSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle);
		// vec2 lSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle + degRange*degMulty);
		// vec2 rSensorOffset3 = sensorDistScaled3 * unitCircle(velAngle - degRange*degMulty);

		// float fSensor3 = extract(u_pheromones, uv + fSensorOffset3).r;
		// float lSensor3 = extract(u_pheromones, uv + lSensorOffset3).r;
		// float rSensor3 = extract(u_pheromones, uv + rSensorOffset3).r;


		// // fSensor3 = 0.;
		// // lSensor3 = 0.;
		// // rSensor3 = 0.;

		// fSensor = max(max(fSensor, fSensor2), fSensor3);
		// lSensor = max(max(lSensor, lSensor2), lSensor3);
		// rSensor = max(max(rSensor, rSensor2), rSensor3);

		float lrDiff = abs(lSensor - rSensor);
		lrDiff *= 3.;
		lrDiff = 1. / (lrDiff + 2.1);


		if(fSensor >= lSensor && fSensor >= rSensor){
			velOut = unitCircle(velAngle) * lrDiff;
		}
		if(lSensor >= fSensor && lSensor >= rSensor){
			// if(lSensor == lSensor2){
			// 	degTurn /= degMulty;
			// 	velMult *= velMulty;
			// }
			// else if(lSensor == lSensor3){
			// 	degTurn *= degMulty;
			// 	velMult /= velMulty;
			// }
			velOut = unitCircle(velAngle + degTurn) * lrDiff;
		}
		else if(rSensor >= lSensor && rSensor >= fSensor){
			// if(rSensor == rSensor2){
			// 	degTurn /= degMulty;
			// 	velMult *= velMulty;
			// }
			// else if(rSensor == rSensor3){
			// 	degTurn *= degMulty;
			// 	velMult /= velMulty;
			// }
			velOut = unitCircle(velAngle - degTurn) * lrDiff;
		}
		else{
		//   float randVal = n2rand();
			float rNum = sin(5000000.*time*n2rand(time*10.).r);
			rNum = n2rand(time*10.).r - .5;

				// float curVal = texture2D(u_pheromones, uv).r;
			 //  velOut = unitCircle(velAngle + fSensor * degTurn * sin(time));
			 if(rNum > 0.){
			 	velOut = unitCircle(velAngle - randAngle) * .9;
			 }
			 else{
			 	velOut = unitCircle(velAngle + randAngle) * .9;
			 }

			 // velOut = vec2(0.);

			 // velOut = unitCircle(velAngle + 8. * sin(time*2.997));
		  // velOut = rNum;
		}

		// velOut -= vec2(.75, 0.);

		// posOut += velOut;
		velOut *= noise(vec3(uv * 3.* (1.1 + sin(time*.11325)), time*1.113)) * .5 + .5;
		velOut *= velMult * dot(vec3(1.), lmh) * 4.5;// * 2.;
		v = (velOut + vec2(1.)) / 2.;

		

		gl_FragColor = pack(v);
	}
	if(pass == 1){
		vec2 x = extract(u_position, v_texcoord);
		vec2 v = extract(u_velocity, v_texcoord);

		float lenX = pow(smoothstep(0., .5, length(x-.5)), 4.) * .8;

		v = 2. * v - vec2(1.);
		// v = -.3 * (1. - lenX) * x ;//+ lenX * v;
		v = -lenX * (x - .5) * .3 + (1.-lenX)*v;
		x += v * maxVel / resolution;


		if(length(x -.5 + .1*unitCircle(n2rand().r * 22.*PI)) > .45){
			x = vec2(0.5) + .25 * unitCircle(n2rand().x*200.) + .1 * unitCircle((n2rand().y*500.));
		}

		x = mod(x, 1.);

		gl_FragColor = pack(x);
		// gl_FragColor = pack(x);
		// gl_FragColor = texture2D(u_position, v_texcoord);
	}
}10:T856,
precision highp float;


uniform vec2 resolution;
uniform sampler2D u_texture;

uniform float intensity;

uniform vec2 lightXY;
uniform float specularHardness;
uniform float specularPower;
uniform float diffusePower;
uniform vec3 viewDir;

const float BASE = 255.0;
const float scale = BASE * BASE;
const float OFFSET = 0.0;

vec2 encode(float value) {
    value = floor(value * scale + OFFSET);
    float x = mod(value, BASE);
    float y = floor(value / BASE);
    return vec2(x, y) / BASE;
}

vec4 pack(vec2 value){
	return vec4(encode(value.x), encode(value.y));
}

float decode(vec2 channels) {
    return (dot(channels, vec2(BASE, BASE * BASE)) - OFFSET) / scale;
}

vec2 extract(sampler2D tex, vec2 texcoord){
	vec4 valueRAW = texture2D(tex, texcoord);
	return vec2(decode(valueRAW.rg), decode(valueRAW.ba));
}


float luminance(vec3 c)
{
	return dot(c, vec3(.2126, .7152, .0722));
}

vec2 pixelOffset(vec2 offset){
	vec2 uv = gl_FragCoord.xy / resolution;
	return extract(u_texture, uv + offset);
}

vec3 calcNormal()
{
	vec2 yOffset = vec2(0., 1. / resolution.s);
	vec2 xOffset = vec2(1. / resolution.t, 0.);
	float R = abs(pixelOffset(xOffset).x );
	float L = abs(pixelOffset(-xOffset).x );
	float U = abs(pixelOffset(yOffset).x );
	float D = abs(pixelOffset(-yOffset).x );
				 
	float X = (L-R) * .5;
	float Y = (U-D) * .5;

	return normalize(vec3(X, Y, 1. / intensity));
}

void main()
{
	vec3 n = calcNormal();

	vec2 uv = gl_FragCoord.xy / resolution;

	vec3 lp1 = vec3(lightXY, 2.) + vec3(.5, .5, 0.);
	vec3 lp2 = vec3(-lightXY, 2.) + vec3(.5, .5, 0.);

	vec3 sp = vec3(uv, -1.);
	
	vec3 c1 = diffusePower*vec3(dot(n, normalize(lp1 - sp)));
	vec3 c2 = diffusePower*vec3(dot(n, normalize(lp2 - sp)));
	
    vec3 ep = vec3(.5, .5, 0.);
	c1 += specularPower*pow(clamp(dot(normalize(reflect(lp1 - sp, n)), 
					   normalize(sp - ep)), 0., 1.), specularHardness);
	c2 += specularPower*pow(clamp(dot(normalize(reflect(lp2 - sp, n)), 
					   normalize(sp - ep)), 0., 1.), specularHardness);

	float mult = sqrt(extract(u_texture, uv).r);
	gl_FragColor = pack(vec2(c1.r*mult, c2.r*mult));
	// gl_FragColor = vec4(c, 1.);
}
11:T4fab,precision highp float;

// Uses code by IQ and anatole duprat - XT95/2015
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look :
// http://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/

struct Ray{
  vec3 p;
  int obj;
  float d;
};

uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D randSampler;
uniform vec3 iAudio;
uniform vec2 iResolution;

uniform float tunnelPos;
uniform float fisheye;
uniform vec2 creatureXY;
uniform float tunnelLight;
uniform float tunnelBase;
uniform float creatureLight;
uniform float wingRot;
uniform float creatureFlip;
uniform float creatureTwist;
uniform int HD;
uniform float fairyLight;
uniform float tunnelWonky;
uniform float tunnelWidth;
uniform float checker;
uniform float fairyTime;
uniform vec2 rayUp;

const float PI = 3.14159265359;
const vec3 ax = vec3(1., 0., 0.);

Ray raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane );
vec3 normal( in vec3 p );
Ray map( in vec3 p );
mat3 lookat( in vec3 fw, in vec3 up );
vec3 rotate( in vec3 v, in float angle, in vec3 pos);
float thickness( in vec3 p, in vec3 n, float maxDist, float falloff );
float ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff );
float smin( float a, float b, float k );


vec3 lpos1,lpos2,lpos3;
vec3 lpos4,lpos5,lpos6;
vec3 pCreature, pCreatureOffset;
vec4 rCreature;
vec3 posOff;
vec3 sssColor, diffColor1, diffColor2, diffColor3;

// vec2 tunnelOffset, tunnelWave;
// vec4 rCreatureI;
vec3 pTunnel;

vec3 fairy[9];
const int numFairy = 9;

float aoMaxSteps = 3.0;


vec4 quat_from_axis_angle(vec3 axis, float angle)
{ 
  vec4 qr;
  float half_angle = (angle * 0.5);
  qr.x = axis.x * sin(half_angle);
  qr.y = axis.y * sin(half_angle);
  qr.z = axis.z * sin(half_angle);
  qr.w = cos(half_angle);
  return qr;
}

vec4 quat_conj(vec4 q)
{ 
  return vec4(-q.x, -q.y, -q.z, q.w); 
}
  
vec4 quat_mult(vec4 q1, vec4 q2)
{ 
  vec4 qr;
  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);
  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);
  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);
  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);
  return qr;
}

vec3 rotate_vertex_position(vec3 position, vec4 qr)
{ 
  // vec4 qr = quat_from_axis_angle(axis, angle);
  vec4 qr_conj = quat_conj(qr);
  vec4 q_pos = vec4(position.x, position.y, position.z, 0);
  
  vec4 q_tmp = quat_mult(qr, q_pos);
  qr = quat_mult(q_tmp, qr_conj);
  
  return vec3(qr.x, qr.y, qr.z);
}

vec2 GetGradient(vec2 intPos, float t) {
    
    // Texture-based rand (a bit faster on my GPU)
    float rand = texture2D(randSampler, intPos / 64.0).r;
    
    // Rotate gradient: random starting rotation, random rotation rate
    float angle = 600.283185 * rand + 4.0 * t * rand;
    return vec2(cos(angle), sin(angle));
}


float Pseudo3dNoise(vec3 pos) {
    vec2 i = floor(pos.xy);
    vec2 f = pos.xy - i;
    vec2 blend = f * f * (3.0 - 2.0 * f);
    float noiseVal = 
        mix(
            mix(
                dot(GetGradient(i + vec2(0., 0.), pos.z), f - vec2(0., 0.)),
                dot(GetGradient(i + vec2(1., 0.), pos.z), f - vec2(1., 0.)),
                blend.x),
            mix(
                dot(GetGradient(i + vec2(0., 1.), pos.z), f - vec2(0., 1.)),
                dot(GetGradient(i + vec2(1., 1.), pos.z), f - vec2(1., 1.)),
                blend.x),
        blend.y
    );
    return noiseVal / 0.7; // normalize to about [-1..1]
}

vec3 threePsuedo3dNoise(vec3 pos){
    vec3 threeNoise;
    threeNoise.x = Pseudo3dNoise(pos + vec3(0.1, 0., 0.));
    threeNoise.y = Pseudo3dNoise(pos + vec3(0.3111, 10., 999.123));
    threeNoise.z = Pseudo3dNoise(pos + vec3(0.3578, 110., 999999.45));
    return threeNoise;
}


vec3 objTrans(vec3 pos, vec3 oPos, vec4 qr){
    return rotate_vertex_position(pos, qr) + oPos;
}

vec3 objTransI(vec3 pos, vec3 oPos, vec4 qr){
    return rotate_vertex_position(pos - oPos, quat_conj(qr));
}

vec3 creature(vec3 pos){
    return objTransI(pos + pCreatureOffset, pCreature, rCreature) - pCreatureOffset;
}

vec3 creatureI(vec3 pos){
    return objTrans(pos - pCreatureOffset, pCreature, rCreature) + pCreatureOffset;
}

float hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}

vec3 polarCoord(float r, float phi, float theta )
{
    // Theta starts at groundPlane
 	return vec3(
        r * sin(PI/2. - theta) * cos(phi),
        r * cos(PI/2. - theta),
       	r * sin(PI/2. - theta) * sin(phi)  
    );
}

vec3 polarCoordDeg(float r, float phi, float theta )
{
 	return polarCoord(r, phi * PI / 180., theta  * PI / 180. );
}

vec3 rectCoord(vec3 pos){
 	float r = length(pos);
    float theta = atan(pos.y, pos.x);
    float phi = atan(length(pos.xy), pos.z);
    return vec3(r, phi, theta);
}

// Picking colors with HSV is much simpler
vec3 hsv(float cX, float cY, float cZ)
{
    cX -= float(int(cX));
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);
    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);
}

// Linear white point
const float W = 1.2;
const float T2 = 7.5;

//Gamma correction
vec3 gamma(vec3 x, float gamma) {
    return pow(x, vec3(1./gamma));
}

float fadeIn(float t){
 	return min(iTime/t,1.); 
}
    

Ray raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane ){
    const int maxSteps = 80;
    float epsilon = 0.001;
	Ray ray = Ray(
        ro+rd*nfplane.x, 
        -1,
        -1.0
    );
	float t = 0.;
	for(int i=0; i<maxSteps; i++)
	{
        ray = map(ray.p);
        t += ray.d;
        ray.p += rd * ray.d;
        if( 
            ray.d < epsilon || 
            t > (nfplane.y - (1. - float(HD)) * 200.) ||
            (i > maxSteps / 4 && HD==0)
        )
            break;   
	}
	
	return ray;
}

vec3 normal( in vec3 p ){
	vec3 eps = vec3(0.001, 0.0, 0.0);
	return normalize( vec3(
		map(p+eps.xyy).d-map(p-eps.xyy).d,
		map(p+eps.yxy).d-map(p-eps.yxy).d,
		map(p+eps.yyx).d-map(p-eps.yyx).d
	) );
}


mat3 lookat( in vec3 fw, in vec3 up ){
	fw = normalize(fw);
	vec3 rt = normalize( cross(fw, normalize(up)) );
	return mat3( rt, cross(rt, fw), fw );
}


vec3 rotate( in vec3 v, in float angle, in vec3 pos){
	vec4 qr = quat_from_axis_angle(v, angle);
    return rotate_vertex_position(pos, qr);
}


float skinLookup(vec2 pos)
{
    float phase = .4*texture2D(iChannel0, mod(pos / 4., 1.0)).r;
    vec2 offset = vec2(sin(phase + iTime/20.), cos(phase + iTime/23.));
    return texture2D(iChannel0, mod(pos + offset, 1.0)).r ;
}

float smin( float a, float b, float k ) //Thx to iq^rgba
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return mix( b, a, h ) - k*h*(1.0-h);
}

float smax( float d1, float d2, float k )
{
	float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
	return mix( d2, -d1, h ) + k*h*(1.0-h);
}


vec3 randomSphereDir(vec2 rnd)
{
	float s = rnd.x*PI*2.;
	float t = rnd.y*2.-1.;
	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
}

vec3 randomHemisphereDir(vec3 dir, float i)
{
	vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );
	return v * sign(dot(v, dir));
}


float sdRoundCone( in vec3 p, in float r1, float r2, float h )
{
    vec2 q = vec2( length(p.xz), p.y );
    
    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q,vec2(-b,a));
    
    if( k < 0.0 ) return length(q) - r1;
    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
    return dot(q, vec2(a,b) ) - r1;
}

float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, in float h)
{
    p.z /= h;
    p.x = abs(p.x);
    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);
    return (sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb) * min(h, 1.);
}

float sdCappedCylinder( vec3 p, float r, float h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}


float ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )
{
	const int nbIte = 8;
    const float nbIteInv = 1./float(nbIte);
    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)
    
	float ao = 0.0;
    for( int i=0; i<nbIte; i++ )
    {
        if(HD == 0 && i > nbIte / 8) break;
        float l = hash(float(i))*maxDist;
        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal
            												        // for self occlusion problems
        ao += (l - map( p + rd ).d) / pow(1.+l, falloff);
    }
    return clamp( 1.-ao*nbIteInv, 0., 1.);
}


float thickness( in vec3 p, in vec3 n, float maxDist, float falloff )
{
    // Num near samples
	const int nbIte = 8;
    const float nbIteInv = 1./float(nbIte);    
	float ao = 0.0;
    for( int i=0; i<nbIte; i++ )
    {
        if(HD == 0 && i > nbIte / 8) break;
            float l = hash(float(i))*maxDist;
            // Normal is reversed from ao calculation
            vec3 rd = normalize(-n)*l;
            ao += (l + map( p + rd ).d) / pow(1.+l, falloff);
        
    }
    return clamp( 1.-ao*nbIteInv, 0., 1.);
}

vec4 calcTunnelOffset(vec3 tunnelP){
    vec2 tO = 6.*vec2(sin(tunnelP.x/12.), cos(tunnelP.x/12.));
    vec2 tW = 8.*vec2(sin(tunnelP.x/32.), cos(tunnelP.x/22.));
    return vec4(tO, tunnelWonky * tW);
}

//Map
Ray map( in vec3 p )
{
    float fairyDist = 999.;
    float fairySize = .08;
    // if(HD == 1){
    for(int i = 0; i < numFairy; i++){
        if(HD == 1 || mod(float(i), 2.) == 0.){
        float fd = length(p - fairy[i]) - fairySize;
        fairyDist = min(fairyDist, fd);
        }
    }
    // }

    vec3 pCreatROT = creature(p);;

    vec3 bBallCenter = creature(lpos1) - posOff;
    vec3 lBallCenter = creature(lpos1);
    float wingRotMod = mod(-wingRot, 1.);
    float suckIn = abs(3. * max(.333, wingRotMod) - 2.);
    vec3 tBallCenter = bBallCenter + vec3(0., 5., 4.) * suckIn;
    vec3 cBallCenter = bBallCenter + vec3(4. + sin(iTime), -3., 2.);

    // Render light balls
    float lightBallRad = .25;
    //p.xz = mod(p.xz+100., 200.)-100.;
    float d = 100.;//+textureLod(iChannel0, p.xz*.05, 0.0).r*1.5;
    d = min(d, length(pCreatROT-creature(lpos1))-lightBallRad);
    
    float lightBallRadWing = .2;
    d = min(d, length(pCreatROT-creature(lpos4))-lightBallRadWing);
    d = min(d, length(pCreatROT-creature(lpos5))-lightBallRadWing);
    d = min(d, length(pCreatROT-creature(lpos6))-lightBallRadWing);

    // Render skin ball
    
    
    
    float bBallRad = 6.;
    float lBallRad = lightBallRad + .5;
    float tBallRad = 3.;
    //p.xz = mod(p.xz, 60.)-30.;
    //p = rotate(vec3(0.,1.,0.), p.y*.05*cos(iTime+sin(iTime*1.5+id.x*5.)+id.y*42.))*p;
    float bD = length(pCreatROT-bBallCenter) - bBallRad;
    float lD = length(pCreatROT-lBallCenter) - lBallRad;
    float tD = length(pCreatROT-tBallCenter) - tBallRad;
    float tD2 = length(pCreatROT-cBallCenter) - tBallRad/1.5  * (pow(iAudio[1], .5) + .5);
    float texDisp = .35 * skinLookup(
        (pCreatROT-bBallCenter).yz / 15.
    );
    d = min(d, smin(smin(smax(tD2, bD, 0.6), lD, 1.), tD, 2.) - texDisp );

    //return d;
    
    vec3 pBranch = rotate(ax, 2.*PI/8., pCreatROT - bBallCenter);
    float branch = sdRoundCone(pBranch, .7, .3, 10.);
    
    pBranch = rotate(ax, 3.*PI/8., pCreatROT - bBallCenter);
    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);
    
    pBranch = rotate(ax, 4.*PI/8., pCreatROT - bBallCenter);
    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);
    
    pBranch = rotate(ax, 5.*PI/8., pCreatROT - bBallCenter);
    branch = smin(branch, sdRoundCone(pBranch, .7, .3, 10.), 2.);
    
    vec3 pWing = rotate(ax, 1.38 - 2.*PI * wingRot,  
        pCreatROT - bBallCenter + vec3(0., 0., .5));
    float wing = sdCappedTorus(
        pWing.zyx, 
        vec2(sin(.7),cos(.7)), 
        11., 1.5, .33
    );
    branch = smin(branch, wing, 1.);

    d = smin(d, branch - texDisp * .5, 2.);

    vec3 tunnelP = p - pTunnel;

    vec4 tunnelOffset = calcTunnelOffset(tunnelP);
    float tDist = length(tunnelP.yz + tunnelOffset.xy + tunnelOffset.zw);
    float cylinder = max(
        tunnelWidth - tDist, 
    0.);
    cylinder *= min(1., 1./max(0.001, (abs(tunnelWonky)+.5)));
    // // if(max(abs(tunnelOffset.x + tunnelOffset.z), abs(tunnelOffset.y + tunnelOffset.w)) > 1.){
    //     cylinder *= .5;
    // // }
    int obj = 0;

    // if(HD == 1){
    if(fairyDist < d && fairyDist < cylinder){
        d = smin(d, fairyDist, .5);
        obj = 2;
    }
    // }

    else if(cylinder < d){
        obj = 1;
        d = cylinder;
    }
    
    return  Ray(p, obj, d);
}

vec3 gradLight(vec3 pos){
    // pos = creature(pos - pCreatureOffset) + pCreatureOffset - pCreature;
    pos = rotate_vertex_position(pos - pCreature - pCreatureOffset, quat_conj(rCreature)) + pCreatureOffset;
    float angle = (atan(pos.y, pos.z) + PI) / (2. * PI);
    return hsv(angle * 3. + .2*sin(iTime * 1.5), .8, .4);
}

//Shading
vec3 shade( in Ray ray, in vec3 n, in vec3 ro, in vec3 rd )
{		
    vec3 p = vec3(ray.p);

    // vec3 diffColor4 = ;

    vec3 dC4 = gradLight(lpos4);
    vec3 dC5 = gradLight(lpos5);
    vec3 dC6 = gradLight(lpos6);
    
    float nLookup = skinLookup(rectCoord(n).yz / 25.);
    float nLookup2 = nLookup * nLookup - .5;
    vec3 skinColor = hsv(0.03, 0.3, nLookup-.2) + hsv(0.03 + nLookup2*.8, 0.7 - nLookup2, nLookup);
    skinColor /= 1.5;
    skinColor = abs(skinColor * skinColor);
    float roughness = 0.05;
    float shininess = .05;
    
    
    // Light positions wrt raymarch point
    float lL1 = length(lpos1-p);
    float lL2 = length(lpos2-p);
    float lL3 = length(lpos3-p);
    float lL4 = length(lpos4-p);
    float lL5 = length(lpos5-p);
    float lL6 = length(lpos6-p);

	vec3 ldir1 = (lpos1-p) / lL1;	
	vec3 ldir2 =  (lpos2-p) / lL2;	
	vec3 ldir3 =  (lpos3-p) / lL3;
    
    vec3 ldir4 = (lpos4-p) / lL4;	
	vec3 ldir5 =  (lpos5-p) / lL5;	
	vec3 ldir6 =  (lpos6-p) / lL6;
    
    float latt1 = .3*pow(lL1 *.15, 3. ) / iAudio.x;
    float latt2 = pow( lL2*.15, 3. ) / iAudio.y;
    float latt3 = 3.*pow( lL3*.15, 2.5 ) / iAudio.z;

    float latt4 = .3*pow( lL4*.15, 3. ) / iAudio.x;
    float latt5 = pow(lL5*.15, 3. ) / iAudio.y;
    float latt6 = pow( lL6*.15, 3. ) / iAudio.z;

    diffColor1 = hsv(-.001/latt1+.5, .8, .3);
    
    // SSS multiplier (thickness) and AO
    float sssThick = .8;
	float thick = thickness(p, n, aoMaxSteps, 1./sssThick);
    
    float aoFalloff = 1.;
	// float occ = .1*pow( ambientOcclusion(p, n, aoMaxSteps, aoFalloff), 6.);

    // Diffuse lighting from lights
	// vec3 diff1 = diffColor1 * (max(dot(n,ldir1),0.) ) / latt1;
	vec3 diff2 = diffColor2 * (max(dot(n,ldir2),0.) ) / latt2;
	// vec3 diff3 = diffColor3 * (max(dot(n,ldir3),0.) ) / latt3;

    vec3 col = vec3(0.);//skinColor * diff2;// + diff2;// + diff3;
    

    vec3 refl = reflect(rd,n);  

    float fairySSS = 0.;
    if(HD == 1){
        for(int i = 0; i < numFairy; i++){
            vec3 fpos = fairy[i];
            float ftrans = clamp( dot(-rd, -fpos+n), 0., 1.) + 1.;
            float flatt = pow( length(fpos-p), 4. );
            fairySSS += ftrans/flatt;
            }
    }
    fairySSS *= fairyLight;

    float trans1 =  clamp( dot(-rd, -ldir1+n), 0., 1.) + 1. ;
    float trans2 =  clamp( dot(-rd, -ldir2+n), 0., 1.) + 1. ;
    float trans3 =  clamp( dot(-rd, -ldir3+n), 0., 1.) + 1. ;
    
    // SSS from lights inside
    float trans4 =  clamp( dot(-rd, -ldir4+n), 0., 1.) + 1.;
    float trans5 =  clamp( dot(-rd, -ldir5+n), 0., 1.) + 1. ;
    float trans6 =  clamp( dot(-rd, -ldir6+n), 0., 1.) + 1. ;

    vec3 headLights = diffColor3 * creatureLight * trans3/latt3; 
    vec3 bodyLights = creatureLight * gradLight(p) * (
        dC4*trans4/latt4 + dC5*trans5/latt5 + dC6*trans6/latt6
    );
    vec3 topLight = diffColor2 * creatureLight * thick * trans2/latt2;
    

    if(ray.obj == 0){
        col = skinColor * diff2;// + diff2;// + diff3;
        // SSS from lights inside        
        
        col += thick * (sssColor * (
            .01*diffColor1*trans1/latt1 + 
            .2 * topLight) +
            .1 * headLights + 
            .05 * bodyLights +
            .001 * fairySSS
        ) ;
        col *= (.2 + .8*skinColor);
        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ),1./roughness);
        col += shininess*spec + .02*skinColor;
        // col = gradLight(p);
    }

    else if(ray.obj == 1){
        vec3 pTunnelOff = p - pTunnel;
        vec4 tunnelOffset = calcTunnelOffset(pTunnelOff);
        pTunnelOff += 1. * vec3(0., tunnelOffset.xy);
        float spec = pow(clamp( dot( refl, ldir2 ), 0.0, 1.0 ), 1.);
        spec = 1.;
        spec =  3. * spec * iAudio[2] * tunnelLight + tunnelBase;
        int dBool = int(mod(length(pTunnelOff.x/12.) * 2., 2.));
        float angle = (atan(pTunnelOff.z, pTunnelOff.y)+PI) / (2. * PI);
        int aFix = 0;
        int aBool = int(mod(angle * checker - checker / 2. - .5, 2.));
        float checker = mod(float(dBool + aBool + aFix), 2.0);
        col = 
            vec3(checker) * (spec) * (
                pow(min(abs(p.x-50.), 300.)/300., 4.)  + 
                2. * bodyLights + 
                15. * headLights +
                pow(smoothstep(.0, .5, fairySSS), .6)
            ) + 10.*pow(smoothstep(.0, 2., fairySSS), 1.) * .3;
    }

    else if(ray.obj == 2){
        col = vec3(fairyLight * (iAudio[0] + .5));
    }

	return col;
}

vec3 render(vec2 q)
{
    // Camera coordinates
	vec2 v = -1.0 + 2.0*q;
	v.x *= iResolution.x/iResolution.y;


    sssColor = hsv(0.2, 0.6, 1.5);
    diffColor1 = hsv(0.3, 0.9, .5);
    diffColor2 = hsv(0.7, 0.1, 0.1);
    diffColor3 = hsv(0.9, 0.1, 0.5);
    
    //Camera Settings
    // float fisheye = ;
    float lens = 1.9 - fisheye * length(v);
    vec2 nfplane = vec2(.001, 400.);

    vec3 lightOffset = vec3(cos(iTime*.5)*6., 0., sin(iTime*.5)*15.);

    vec3 axisCreature = vec3(0., sin(iTime/1.4), cos(iTime/1.4));
    vec3 axisCreatureFlip = vec3(0., 0., 1.);
    vec3 axisCreatureTwist = vec3(0., 1., 0.);
    pCreature =  vec3(-15.-5.*exp(-cos(iTime/1.77)),-1.5+exp(-sin(iTime)), -1.);
    pCreature += vec3(creatureXY, 0.);
    // pCreature = vec3(0);

    posOff = vec3(6., 1.5, 1.5);
    
    pCreatureOffset = 3. * vec3(exp(-sin(iTime/1.53)),exp(-sin(iTime*1.11)), -cos(iTime*2.11));
    
    //Flip
    rCreature = quat_from_axis_angle(axisCreature, 2.*PI*creatureFlip);
    // rCreatureI = quat_from_axis_angle(axisCreature, -2.*PI*creatureFlip);

    //Twist
    rCreature = quat_mult(
        rCreature,
        quat_from_axis_angle(axisCreatureTwist, 2.*PI*creatureTwist)
    );
    // rCreatureI = quat_from_axis_angle(axisCreatureTwist, -2.*PI*creatureTwist);

    rCreature = quat_mult(
        rCreature,
        quat_from_axis_angle(axisCreature, PI/6. * sin(iTime))
    );
    // rCreatureI = quat_from_axis_angle(axisCreature, -PI/6. * sin(iTime));

    pTunnel = vec3(tunnelPos, 0., 0.);
    
	//define lights pos
    lpos1 = creatureI(vec3(6., 0., 0.));
	lpos2 = creatureI(vec3( 15., 3.5, 0.) + lightOffset);
	lpos3 = creatureI(vec3(2., 4., 2.8));
    
    lpos4 = creatureI(vec3(.5, 6.5, -9.5));
    lpos5 = creatureI(
        rotate(ax, 2.*PI * wingRot, vec3(.5, .65, -12.2) + posOff) - posOff - vec3(0., 0., .5)
    );
    lpos6 = creatureI(vec3(.5, -6., -11.));

    // if(HD == 1){
    for(int i = 0; i < numFairy; i++){
        if(HD == 1 || mod(float(i), 2.) == 0.){
            fairy[i] = tunnelWidth * .8 * threePsuedo3dNoise(vec3(float(i+2)*12345.664, fairyTime, 0.)) + vec3(-10., 0., 0.);
        }
    }
    // }
   
	//camera ray
    float camDist = 25.;
    float camFreq = 9999999.;
    vec3 ro = vec3(camDist, 0.0, 0.);
    vec3 rd = normalize( vec3(v.x, v.y, lens) );
    vec3 target = vec3(0.0, 0.0, 0.0);
	rd = lookat( target-ro, vec3(0.,rayUp))*rd;
    
	//classic raymarching by distance field
	Ray ray = raymarche(ro, rd, nfplane );
	vec3 n = normal(ray.p.xyz);
	vec3 col = shade(ray, n, ro, rd);
    return col;
}

void main()
{
    vec2 p = gl_FragCoord.xy/iResolution.xy; 
    vec3 col = render(p);
    
    col = gamma(col, 2.2); 

    // col = texture2D(iChannel0, p).rgb;   
        
	gl_FragColor = vec4(col,1.0)*fadeIn(0.9);
}
12:T628,precision highp float;

uniform vec2 resolution;
uniform sampler2D u_diffuse;
uniform sampler2D u_normal;
uniform vec3 light;
uniform float TIME;
uniform float toggleStatus;

const float A_COL = .45;
const float I_COL = .17;

vec3 hsv2rgb(vec3 c) {
    c.x = mod(c.x, 1.);
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsv2rgb(float h, float s, float v) {
  return hsv2rgb(vec3(h, s, v));
}

void main() {
	vec2 fragCoord = gl_FragCoord.xy;
	vec2 uv = fragCoord / resolution;

	vec3 diffuse = texture2D(u_diffuse, uv).rgb;
	vec3 normal = texture2D(u_normal, uv).rgb;
	vec3 metal = vec3(diffuse.r);
	vec3 buttons = toggleStatus > 0. ? 
		hsv2rgb(I_COL, .85, diffuse.g) : hsv2rgb(A_COL, .85, diffuse.g);

	float height = 0.;

	// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;
	float alpha = ceil(diffuse.b);
	if(abs(uv.x-.5) > .49){
		alpha = 0.;
	}

	vec3 c = vec3(0.);
	if(alpha > 0.){
		// Phong
		normal = (normal - vec3(.5))*2.;
		vec3 lp = vec3(
			3. * (light.x / resolution.x - .5), 
			// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),
			3.*(1.-light.y / resolution.y - .5), 
			1.
		);
		vec3 sp = vec3(uv - vec2(.5, .5), -1.);
		vec3 ep = vec3(.5, .5, 0.);
		c = hsv2rgb(TIME/80. + .5, .85, pow(
			clamp(
				dot(
					normalize(reflect(lp-sp, normal)), 
					normalize(sp)
				),
				0., 1.
			),
			10.
		));
	}


	gl_FragColor = vec4(metal + buttons + c, 1.0) * alpha;
}13:Tc31,precision highp float;

uniform vec2 resolution;
uniform vec2 hdAA;
uniform sampler2D u_diffuse;
uniform sampler2D u_buttons;
uniform sampler2D u_playN;
uniform sampler2D u_pauseN;
uniform sampler2D u_height;
uniform sampler2D u_lights;
uniform vec3 light;
uniform float TIME;
uniform bool playing;
uniform vec3 buttonStatus;
uniform float toggleStatus;

const float A_COL = .45;
const float I_COL = .55;
const float B_COL = .1;
const float B_COL_2 = .75;
const float L_COL = .7;

vec3 hsv2rgb(vec3 c) {
    c.x = mod(c.x, 1.);
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsv2rgb(float h, float s, float v) {
  return hsv2rgb(vec3(h, s, v));
}

float sigmoid(float x){
	return 1.0 / (1.0 + exp(-1.0 * x));
}

void main() {
	vec2 fragCoord = gl_FragCoord.xy;
	vec2 uv = fragCoord / resolution;

	vec3 diffuse = texture2D(u_diffuse, uv).rgb;
	vec3 buttonLights = texture2D(u_buttons, uv).rgb;
	vec3 heightRGB = texture2D(u_height, uv).rgb;
	vec3 buttonLights2 = texture2D(u_lights, uv).rgb;

	vec3 normal = vec3(0.);
	vec3 metal = vec3(0.);
	vec3 buttons = vec3(0.);
	vec3 speakers = hsv2rgb(TIME/80., .85, diffuse.b);

	float text = heightRGB.g;
	float height = 0.;

	if(playing){
		metal = vec3(diffuse.g);
		normal = texture2D(u_playN, uv).rgb;
		height = heightRGB.r;
		buttons += hsv2rgb(A_COL, .85, buttonLights.b * buttonStatus.b);
	}
	else{
		metal = vec3(diffuse.r);
		normal = texture2D(u_pauseN, uv).rgb;
		height = heightRGB.b;
		buttons += hsv2rgb(A_COL, .85, buttonLights.g * buttonStatus.b);
	}

	if(uv.x < .5){
		buttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.r);
	}
	else{
		buttons += hsv2rgb(A_COL, .85, buttonLights.r * buttonStatus.g);
	}

	//info button
	if(uv.y < .5){
		buttons += hsv2rgb(I_COL, .85, buttonLights2.g);
	}
	else{
		if(uv.x < .5){
			buttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;
		}
		else{
			buttons += hsv2rgb(B_COL_2, .95, buttonLights2.g) * 1.2;
		}
	}

	//AA
	buttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.r * hdAA.y) * 1.2, 0., 1.);
	//HD
	buttons += clamp(hsv2rgb(L_COL, .0, buttonLights2.b * hdAA.x) * 1.2, 0., 1.);

	// vec3 buttons = hsv2rgb(A_COL, .85, 1.) * color.g;
	float sOffset = toggleStatus*2. + .25;
	float alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);

	if(abs(uv.x-.5) > .49){
		alpha = 0.;
	}

	vec3 c = vec3(0.);
	if(alpha > 0.){
		// Phong
		normal = (normal - vec3(.5))*2.;
		vec3 lp = vec3(
			3. * (light.x / resolution.x - .5), 
			// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),
			3.*(1.-light.y / resolution.y - .5) * resolution.y / resolution.x, 
			1.
		);
		vec3 sp = vec3(uv - vec2(.5, .5), -1.) * vec3(1., resolution.y / resolution.x, 1.);
		vec3 ep = vec3(.5, .5, 0.);
		c = hsv2rgb(TIME/80. + .5, .85, pow(
			clamp(
				dot(
					normalize(reflect(lp-sp, normal)), 
					normalize(sp)
				),
				0., 1.
			),
			1000.
		));
	}

	gl_FragColor = vec4(metal + buttons + c + speakers, 1.0) * alpha;
}14:T98b,precision highp float;

uniform vec2 resolution;
uniform sampler2D u_diffuse;
uniform sampler2D u_buttons;
uniform sampler2D u_playN;
uniform sampler2D u_pauseN;
uniform sampler2D u_height;
uniform vec3 light;
uniform float TIME;
uniform bool playing;
uniform vec3 buttonStatus;
uniform float toggleStatus;

vec3 hsv2rgb(vec3 c) {
    c.x = mod(c.x, 1.);
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsv2rgb(float h, float s, float v) {
  return hsv2rgb(vec3(h, s, v));
}

float sigmoid(float x){
	return 1.0 / (1.0 + exp(-1.0 * x));;
}

void main() {
	vec2 fragCoord = gl_FragCoord.xy;
	vec2 uv = fragCoord / resolution;

	vec3 diffuse = texture2D(u_diffuse, uv).rgb;
	vec3 buttonLights = texture2D(u_buttons, uv).rgb;
	vec3 heightRGB = texture2D(u_height, uv).rgb;

	vec3 normal = vec3(0.);
	vec3 metal = vec3(0.);
	vec3 buttons = vec3(0.);

	float text = heightRGB.g;
	float height = 0.;

	if(playing){
		metal = vec3(diffuse.g);
		normal = texture2D(u_playN, uv).rgb;
		height = heightRGB.r;
		buttons += hsv2rgb(.33, .85, buttonLights.b * buttonStatus.b);
	}
	else{
		metal = vec3(diffuse.r);
		normal = texture2D(u_pauseN, uv).rgb;
		height = heightRGB.b;
		buttons += hsv2rgb(.33, .85, buttonLights.g * buttonStatus.b);
	}

	if(uv.x < .5){
		buttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.r);
	}
	else{
		buttons += hsv2rgb(.33, .85, buttonLights.r * buttonStatus.g);
	}

	// vec3 buttons = hsv2rgb(.33, .85, 1.) * color.g;
	float sOffset = toggleStatus + .5;
	float alpha = clamp(sigmoid(50.*(height + heightRGB.g - sOffset)), 0., 1.);
	// alpha *= ceil(height);
	// float alpha = clamp(ceil(height + heightRGB.g), 0., 1.) * (1. - toggleStatus);
	if(abs(uv.x-.5) > .49){
		alpha = 0.;
	}

	vec3 c = vec3(0.);
	if(alpha > 0.){
		// Phong
		normal = (normal - vec3(.5))*2.;
		vec3 lp = vec3(
			3. * (light.x / resolution.x - .5), 
			// .8 * clamp((1.-light.y / resolution.y - .5), .2, 1.) + 3.*clamp((1.-light.y / resolution.y - .5), -1., .2),
			3.*(1.-light.y / resolution.y - .5)*.25, 
			1.
		);
		vec3 sp = vec3(uv - vec2(.5, .5), -1.)*vec3(1., .25, 1.);
		vec3 ep = vec3(.5, .5, 0.);
		c = hsv2rgb(.75, .85, pow(
			clamp(
				dot(
					normalize(reflect(lp-sp, normal)), 
					normalize(sp)
				),
				0., 1.
			),
			1000.
		));
	}


	gl_FragColor = vec4(metal + buttons + c, alpha);
}15:Tbff,
precision mediump float;

uniform float TIME;
uniform float swirl;
uniform float border;
uniform int depth;
uniform vec2 resolution;

vec2 rotateLoc(vec2 loc, float angle){
	float oAngle = atan(loc.y, loc.x);
	float nAngle = oAngle + angle / 180.0 * 3.1415926535;
	vec2 rotated = length(loc) * vec2(cos(nAngle), sin(nAngle));
	return rotated;	
}

float negOnePow(int power){
	if(int(mod(float(power), 2.)) == 0){
		return 1.;
	}
	return -1.;
}

int getColVal(vec2 loc, int level, float rotate){
	float levelVal = .5*pow(.25, float(level));
	float radVal = pow(.5, float(level));
	
	vec2 newLoc = rotateLoc(loc, rotate);
	vec2 modLocW = newLoc + vec2(0., levelVal);
    vec2 modLocB = newLoc - vec2(0., levelVal);
    // top circle
    if(length(modLocB) < levelVal){
    	if(level == depth){
    		if(length(modLocB) < levelVal/3.){
    			return 2;
    		}
    	}
    	return 1;
    }
    // bottom circle
    else if(length(modLocW) < levelVal){
    if(level == depth){
    		if(length(modLocW) < levelVal/3.){
    			return 1;
    		}
    	}
    	return 2;
    }
    // left half
    else if(length(loc) < radVal && newLoc.x > 0.){
    	return 3;
    }
    // right half
    else if(length(loc) < radVal){
    	return 4;
    }
}

vec4 getYinYang(vec2 offset){
    vec2 uv = (gl_FragCoord.xy + offset) / resolution;

    vec4 color = vec4(0.0);
    
    vec2 loc = 2.*(uv - vec2(.5));
    vec2 ogLoc = vec2(loc);
    loc *= 1. + border;
    int colVal = 0;
    
    // vec2 ogLoc = vec2(loc);
   
    
    colVal = getColVal(loc, 0, TIME);
    loc = rotateLoc(loc, TIME);
   
    
    float multFac = .125;
    float sumVal = 0.;
    for(int i = 0; i < 16; i++){
        if (i >= depth){break;}
        if(colVal > 0 && colVal < 3){
            sumVal /= 2.;
            if(i > 0){
                sumVal += multFac*pow(.25, float(i-1));
            }
            loc = 0.5*(loc-loc.y/abs(loc.y)*vec2(0.,pow(.5, float(i+1)))  - negOnePow(colVal)*vec2(0.,sumVal));
            colVal = getColVal(loc, i+1, pow(swirl, float(i+3))*TIME);
            loc = rotateLoc(loc, pow(swirl, float(i+3))*TIME);
        }
    }
    
    
    
    
    if(colVal == 1){
        color = vec4(1.0); //white
    }
    else if(colVal == 2){
        color = vec4(1., 0., 0., 1.); //red
        color = vec4(0., 0., 0., 1.);
    }
    else if(colVal == 3){
        color = vec4(0., 1., 0., 1.); //green
        color = vec4(0., 0., 0., 1.);
    }
    else if(colVal == 4){
        color = vec4(0., 0., 1., 1.); //blue
        color = vec4(1.);
    }
    else {
        color = vec4(0.);
    }

    if(length(ogLoc) >= 1.){
        color = vec4(0.);
    }
    else if(length(ogLoc) >= 1./(1.+border)){
        color = vec4(0., 0., 0., 1.);
        color = vec4(1.);
    }

    return color;
}

void main()
{
    vec4 color = vec4(0.);

    for(int i = 0; i < 2; i++){
        for(int j = 0; j < 2; j++){
            vec2 boi = vec2(float(i)-.5, float(j)-.5)/2.;
            color += getYinYang(boi)/4.;
        }
    }

    // color = getYinYang(vec2(0.));
    
    gl_FragColor = color;
}
16:T2f42,precision highp float;

struct Ray{
  vec3 p;
  int obj;
  float d;
  vec4 col;
  vec3 n;
};

struct dObj{
    float d;
    int obj;
};

uniform float iTime;
uniform vec3 lmh;
uniform vec2 iResolution;
uniform bool HD;
uniform sampler2D HDRI;
uniform sampler2D rand;

// ANIMATION
uniform float targetDist;
uniform float warpy;
uniform float twisty;
uniform float rayHeight;
uniform vec2 upDir;
uniform float fisheye;
uniform float hueShift;
uniform float rayPos;
uniform float playTime;

const float PI = 3.14159265359;
const float epsilon = 0.01;

vec3 rayOrigin;

float cellWidth = 10.;

vec2 uCir(float theta){
    return vec2(cos(theta), sin(theta));
}

float sigmoid(float x){
    return 1./(1. + exp(-x));
}

vec2 revSpherical(vec3 xyz){
    float phi = acos(xyz.z/length(xyz));
    float theta = atan(xyz.y, xyz.x);
    return vec2(theta/(2.*PI) + .5, phi/PI);
}

// float rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }

float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb){
  p.x = abs(p.x);
  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);
  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

float sdBox( vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float hash31( vec3 p ){
    return fract(sin(dot(p ,vec3(12.9898,78.233,91.495))) * 43758.5453);
}

mat3 rotate( in vec3 v, in float angle){
    float c = cos(angle);
    float s = sin(angle);
    
    return mat3(
        c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,
        (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,
        (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z
    );
}

vec3 rotateOffset(in vec3 pos, in vec3 v, in float angle, in vec3 offset){
    return (pos - offset) * rotate(v, angle) + offset;
}

vec3 hsv(float cX, float cY, float cZ){
    cX -= float(int(cX));
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);
    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);
}

float hash( float n ){
    return fract(sin(n)*758.5453);
}

const vec2 zOffset = vec2(37.0,17.0);
const vec2 wOffset = vec2(59.0,83.0);

vec4 texNoise(vec2 uv)   // Emulate a single texture fetch into the precalculated texture
{
    // NOTE: Precalculate texture, so we can do a single fetch instead of 4.
    // Afaik we can't generate a texture of a specific size in shadertoy at the momemt.
    float r = texture2D( rand, mod((uv+0.5)/256.0, 1.)).r;
    float g = texture2D( rand, mod((uv+0.5 + zOffset)/256.0, 1.)).r;
    float b = texture2D( rand, mod((uv+0.5 + wOffset)/256.0, 1.)).r;
    float a = texture2D( rand, mod((uv+0.5 + zOffset + wOffset)/256.0, 1.)).r;
    
    return vec4(r, g, b, a);
}


float noise4dFast( in vec4 x )
{
    vec4 p = floor(x);
    vec4 f = fract(x);
    f = f*f*(3.0-2.0*f);
    
    vec2 uv = (p.xy + p.z*zOffset + p.w*wOffset) + f.xy;
    
    vec4 s = texNoise(uv);
    return mix(mix( s.x, s.y, f.z ), mix(s.z, s.w, f.z), f.w);
}

// float sdGyroid(vec4 p) {
//     return (dot(sin(p.xyzw), cos(p.wyzx)) - sin(offset)) * .5;
// }

float sdGyroid(vec4 p) {
    return clamp(dot(sin(p.xyzw), cos(p.yzxw)) * .5, -1., 1.);
}

float sdGyroid(vec3 p, float offset) {
    return sdGyroid(vec4(p, offset));
}

float sdGyroid(vec3 p) {
    return sdGyroid(p, 0.0);
}

mat3 lookat( in vec3 fw, in vec3 up ){
    fw = normalize(fw);
    vec3 rt = normalize( cross(fw, normalize(up)) );
    return mat3( rt, cross(rt, fw), fw );
}

vec3 transformPos(vec3 pos){
    vec3 rotPos = vec3(pos);
    // if(HD){
    vec2 xy = vec2(1.,0.);
    rotPos -= rayOrigin;
    rotPos *= rotate(xy.xyy, twisty*(rotPos.y*0. + rotPos.x*.2) / cellWidth );
    rotPos *= rotate(xy.yxx, warpy*2.*.1*(rotPos.y + rotPos.z) / cellWidth) ;
    rotPos += rayOrigin;
// }
    return rotPos;
}

dObj mapDist(vec3 pos){
    const vec2 SC = vec2(sin(PI/4.), cos(PI/4.));
    const mat2 ROT = mat2(cos(PI/4.), sin(PI/4.), -sin(PI/4.), cos(PI/4.));
    const mat2 ROT2 = mat2(cos(PI/2.), sin(PI/2.), -sin(PI/2.), cos(PI/2.));
    const mat2 nROT = mat2(cos(PI/4.), -sin(PI/4.), sin(PI/4.), cos(PI/4.));

    vec3 rotPos = transformPos(pos);

    float posNoiseAmt = -.3*pow(sdGyroid(rotPos * 1.5, playTime*.06), 4.) * (sin(playTime/16.) + 1.1) ;
    // posNoiseAmt -= .2*pow(sdGyroid(rotPos * 10.*exp(sin(rotPos.x/100.)), playTime*.06), 4.);
    // posNoiseAmt += .015*pow(sdGyroid(.5*rotPos * exp(1.+sdGyroid(rotPos*.6)), playTime*.09), 1.);
    
     float n2G = sin(sdGyroid(rotPos/11.)/7.);
    float n3G = cos(sdGyroid(rotPos/14.)/11.);
    posNoiseAmt -= .03*pow(sdGyroid(rotPos * 7.*(1. + 1.*n2G), playTime*.086), 1.) ;
    
    
    // if(HD){
        // posNoiseAmt += -.2*pow(sdGyroid(rotPos * 3., playTime*.16), 6.) * (cos(playTime/17.) + 1.1) ;
        // posNoiseAmt += -.2*pow( sdGyroid((sdGyroid(rotPos*3.)*.1 + rotPos) * 1., playTime*.1), 6.) ;
    // }
    vec3 noisePos = rotPos + posNoiseAmt;

    float noisey =0.;
        // (pow(sdGyroid(noisePos/8., .2*playTime * 1.), 3.) - .0) / 2.;// + 
        
    if(HD){
       

        posNoiseAmt -= .4*pow(sdGyroid(rotPos * .5, playTime*.086), 1.) *sin(playTime/3.);
       // posNoiseAmt += (sdGyroid(sdGyroid(noisePos*2.*(1.+sin(noisePos.x/43.))) * noisePos/5., 0.*playTime/4.) - .25)/50.;
        posNoiseAmt += .001*pow(sdGyroid(rotPos * 60.*(1.5 + 1.*n3G), playTime*.086), 1.) ;
    //     // noisey += -.2*pow( sdGyroid((sdGyroid(rotPos)*.2 + rotPos) * 40., playTime*.16), 6.) * (cos(playTime/4.) + 1.1) * .0 ;
    //     // noisey += .2*pow(clamp(abs(sdGyroid(sdGyroid(noisePos*.1*(1.+sin(noisePos.x/34.)))*noisePos*10.) - .25)/200., 0., 1.), .8);
    }

    posNoiseAmt += .1;

    // noisey *= .0;
    // noisey -= 1.;

    vec3 basis = vec3(1., 0., 0.);

    // float cellWidth = 10.;
    float ra = cellWidth * .5;
    float rb = .5;

    vec3 p = cellWidth * (mod(rotPos / cellWidth + .5, 1.) - .5);
    // vec3 p = vec3(pos);

    float randRot =  floor(3. * 
        hash31(floor(rotPos / cellWidth + .5))
    );
    if(randRot < 1.){
        basis = basis.yxy;
    }
    else if(randRot < 2.){
        basis = basis.yyx;
    }
    // mat3 pRot = rotate(basis, PI/2. * (randRot + 4.*clamp(mod(iTime/3., 8.)-4., 0., 1.)));
    mat3 pRot = rotate(basis, PI/2. * randRot);
    p *= pRot;
    // p = pos;
    vec3 q;
    q = p;
    q.xy += vec2(-.5,.5) * cellWidth;
    q.xy *= ROT;
    // q = rotateOffset(q, basis, iTime, vec3(-.5,.5, 0.) * cellWidth);
    float A = sdCappedTorus( q, SC, ra, rb );

    q = p.xzy;
    q.xy += vec2(.5,.5) * cellWidth;
    q.xy *= nROT;
    float B = sdCappedTorus( q, SC, ra, rb );
    
    q = vec3(p.y, -p.z, p.x);
    q.xy += vec2(-.5,.5) * cellWidth;
    q.xy *= ROT;
    float C = sdCappedTorus( q, SC, ra, rb );

    // float B = 100.;
    // float C = 100.;

    float d = abs(min(A, min(B, C)) + noisey + posNoiseAmt);
    int obj = -1;

    // d /= (1. + 10.*abs(posNoiseAmt));
    if(HD){
        d *= .5;
    }
    // if(noisey + posNoiseAmt > .1){
    //     d *= .5;
    // }
    else{
        d *= .75;
    }

    // float D = sdCappedTorus( p , SC, ra, rb );

    // float d = min(D, 99999.);

    if(d < epsilon){
        obj = 1;
    }

    return dObj(d, obj);
}

void normal( inout Ray ray ){
 vec3 eps = vec3(0.01, 0.0, 0.0);
 vec3 p = ray.p;
 ray.n = normalize( vec3(
     mapDist(p+eps.xyy).d-mapDist(p-eps.xyy).d,
     mapDist(p+eps.yxy).d-mapDist(p-eps.yxy).d,
     mapDist(p+eps.yyx).d-mapDist(p-eps.yyx).d
 ) );
 // ray.n = vec3(1., 0., 0.);
}

void map(inout Ray ray, vec3 ro, vec3 rd){
    dObj disty = mapDist(ray.p);
    ray.d = disty.d;
    ray.obj = disty.obj;
}

Ray raymarch( in vec3 ro, in vec3 rd){
    const int maxSteps = 80;
    float maxDist = 500.;
    Ray ray = Ray(
        ro, 
        -1,
        100000.,
        vec4(0.),
        vec3(0., 1., 0.)
    );
    float t = 0.;
    vec3 roN = vec3(ro);
    vec3 rdN = vec3(rd);
    for(int i=0; i<maxSteps; i++){
        if(HD || mod(float(i), 2.) == 0.){
            map(ray, roN, rdN);
            t += ray.d;
            ray.p += rdN * ray.d;  
            if( ray.d < epsilon || t > maxDist){
                break;
            }
        }
    }

    if(ray.obj > 0){
        normal(ray);
    }

    return ray;
}

void shade(inout Ray ray, in vec3 rd, in vec3 ro){
    vec3 reflected=reflect(rd,ray.n);
    vec4 hdri = texture2D(HDRI, revSpherical(reflected));
    // vec3 env=vec3(texture2D(HDRI,reflected*reflected*reflected).x);

    vec2 sph = revSpherical(ray.p - vec3(rayPos, 0, 0));

    // vec3 ldir1 = 3. * vec3(sin(iTime/3.), 1., cos(iTime/3.));
    float fog = clamp(1.-sigmoid(length(ray.p-ro)/1.4 - 30. - 50. * pow(lmh[1], 4.)), 0., 1.);
    vec4 fogColor = vec4(hsv(
        .3 + hueShift + sin(sph.y*.2) + 1., 
        .45 - .35*cos(playTime*2. * PI / 84.), 
        .5 + lmh[2] - .05*(cos(playTime*2. * PI / 128.) + 1.) / 2.
    ), 1.);

    vec2 uv = gl_FragCoord.xy/iResolution.xy; 
    fogColor.rgb *= clamp(2.5-4.*length(uv-vec2(.5)), 0., 1.);

    float hue = abs(dot(normalize(rd), normalize(ray.n)));
    vec4 thinFilm = vec4(hsv(hue/2. + hueShift, .9, hdri.r), 1.);
    
    if(ray.obj == 1){
        vec3 rotPos = transformPos(ray.p);
        float spots = 
        clamp(
            pow(
                abs(sdGyroid(
                    rotPos*9.*
                    (1. + .3*sin(rotPos.x/cellWidth/8.2))*.5*
                    // sigmoid(length(rotPos.yz - vec2(cellWidth/2.)))*
                    (1. + .1*sin(rotPos.x/cellWidth/9.2) ) * .5 *
                    (1. + .1*sin(playTime*.012)+.5)
                ) + .7*(.5+.2*cos(rotPos.x/cellWidth/5.2)))* 
                (1.5 + .4*sin(rotPos.x/cellWidth/10.2))
            , 200. )
        , 0., 1. );

        // spots *= 0.;
        spots *= pow(2.-sigmoid(length(rotPos.yz-rayOrigin.yz)/50.)*2., 4.);
        spots += .2;

        // spots += 1. - 
        // clamp(
        //     pow(
        //         abs(sdGyroid(
        //             ray.p*2.*
        //             sigmoid(length(ray.p.yz - vec2(cellWidth/2.)))*
        //             (1. + sin(ray.p.x/200.) ) * .5 *
        //             (1. + .1*sin(playTime*.003)+.5)
        //         ) - .2)*10.
        //     , 120. )
        // , 0., 1. );
        ray.col = 
            15. * mix(thinFilm, hdri, hue) * pow(lmh[0], 6.) * fog * (1. - spots) + 
            fogColor * (1. - fog) +
            vec4(hsv(ray.p.x / 180., clamp(abs(20. - ray.p.x)/20., 0., 1.)*.0*(1.-pow(lmh[0], 2.)),
                spots * pow(fog, .2) * .9 * (1.-pow(lmh[0], 4.)) 
            ), 1.);
        // ray.col = vec4(1.);
    }
    else{
        ray.col = fogColor;
    }
}

vec4 render(vec2 q){
    vec2 v = -1.0 + 2.0*q;
    v.x *= iResolution.x/iResolution.y;

    //Camera Settings
    // float fisheye = 6. * (sin(iTime / 5. + PI)) / 2.;
    // fisheye = .3;
    float lens = 1.9 + fisheye * length(v);

    //camera ray
    float camDist = 100.;
    float camFreq = 9999999.;
    // vec3 rayOrigin = camDist * vec3(1., 0., 0.);// * vec3(sin(iTime/15.), 0., cos(iTime/15.));
    // rayOrigin = vec3(iTime*3., cellWidth/2., cellWidth/2.);
    rayOrigin = vec3(
        rayPos, 
        cellWidth/2. + rayHeight * cellWidth, 
        cellWidth/2.
    );
    
    vec3 rayDir = normalize( vec3(v.x, v.y, lens) );
    vec3 target = vec3(0., cellWidth/2., cellWidth/2.);
    target = vec3(rayPos + targetDist, cellWidth/2., cellWidth/2.);
    // target = vec3(iTime*3. + 3., cellWidth/2. + sin(iTime * PI / 3.), cellWidth/2.);
    rayDir = lookat( target-rayOrigin, vec3(0.,upDir))*rayDir;
    
    //classic raymarching by distance field
    Ray ray = raymarch(rayOrigin, rayDir);
    shade(ray, rayDir, rayOrigin);
    return ray.col;
}

void main(){
    vec2 p = gl_FragCoord.xy/iResolution.xy; 
    vec4 col = render(p);

    // col = texture2D(HDRI, p);

    // col.rgb *= clamp(2.5-4.*length(p-vec2(.5)), 0., 1.);
        
    gl_FragColor = col;
}17:T3b9e,precision highp float;

#define AA 1  //change to 1 to increase performance

#define _Speed .4  //disk rotation speed

#define _Steps  4. //disk texture2D layers
// #define bhSize 0.3 //size of BH

uniform vec2 resolution;
uniform sampler2D sphereMap;
uniform sampler2D pebbles;
uniform float TIME;
uniform float bhTIME;
uniform float MOUSEX;
uniform float MOUSEY;
uniform float bhRad;
uniform float bhDist;
uniform float bhX;
uniform float bhSeparation;
uniform vec3 iAudio;
uniform float hueShift;
uniform float camDist;
uniform float starBright;
uniform bool HD;

// const vec2 MOUSE = vec2(.5, 60.);

const int MAX_MARCHING_STEPS = 15;
const int diskSteps = 10;
const int exitSteps = 6;

const float discThickness = .001;

const float MIN_DIST = 100.0;
const float MAX_DIST = 200.0;
const float EPSILON = 0.0001;
const float PI = 3.1415926535897;

const float starSize = .05;
const int numStars = 6;
vec3 starPos[6];
float starSizes[6];
vec3 ogPos;

float bhSize;

float sigmoid(float x){
    return 1./(1. + exp(-x));
}

float rand(float n){return fract(sin(n) * 43758.5453123);}

vec3 hsv2rgb(vec3 c) {
    c.x = mod(c.x, 1.);
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsv2rgb(float r, float g, float b) {
  return hsv2rgb(vec3(r, g, b));
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

vec3 blendNormal(vec3 normal){
    vec3 blending = abs(normal);
    blending = normalize(max(blending, 0.00001));
    blending /= vec3(blending.x + blending.y + blending.z);
    return blending;
}

vec3 triplanarMapping (sampler2D texture, vec3 normal, vec3 position) {
  vec3 normalBlend = blendNormal(normal);
    vec3 xColor = texture2D(texture, position.yz).rgb;
    vec3 yColor = texture2D(texture, position.xz).rgb;
    vec3 zColor = texture2D(texture, position.xy).rgb;

  return (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);
}

float noise(vec3 p){
    vec3 a = floor(p);
    vec3 d = p - a;
    d = d * d * (3.0 - 2.0 * d);

    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
    vec4 k1 = perm(b.xyxy);
    vec4 k2 = perm(k1.xyxy + b.zzww);

    vec4 c = k2 + a.zzzz;
    vec4 k3 = perm(c);
    vec4 k4 = perm(c + 1.0);

    vec4 o1 = fract(k3 * (1.0 / 41.0));
    vec4 o2 = fract(k4 * (1.0 / 41.0));

    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);

    return o4.y * d.y + o4.x * (1.0 - d.y);
}

mat3 m3 = mat3( 0.00,  0.80,  0.60,
              -0.80,  0.36, -0.48,
              -0.60, -0.48,  0.64 );

float grid(vec3 p)
{
    float s = sin(p.x)*cos(p.y);
    //float s = sin(p.x)*cos(p.y);
    return s;
}

float flow(vec4 pppp)
{
    vec3 p = pppp.xyz;
    float z=2.;
    float rz = 0.;
    vec3 bp = p;
    float ttt = pppp.w;
    

    for (float i= 1.;i < 5.;i++ )
    {
        //movement
        p += ttt*.6;
        bp -= ttt*.3;
        
        //displacement map
        vec3 gr = vec3(grid(p*3.-ttt*1.),grid(p*3.5+4.-ttt*1.),grid(p*4.+4.-ttt*1.));
        p += gr*0.15;
        rz+= (sin(noise(p)*8.)*0.5+0.5) /z;
        
        //advection factor (.1 = billowing, .9 high advection)
        p = mix(bp,p,.7);
        
        //scale and rotate
        z *= 2.;
        p *= 2.01;
        p*=m3;
        bp *= 1.7;
        bp*=m3;
    }
    return rz;  
}

vec2 unitCircle(float angle){
    return vec2(cos(angle), sin(angle));
}

vec4 background(vec3 ray, vec2 ogUV)
{
    vec2 uv = ray.xy;
    
    // if( abs(ray.x) > 0.5)
    //     uv.x = ray.z;
    // else if( abs(ray.y) > 0.5)
    //     uv.y = ray.z;

    float dist = length(ogUV-vec2(.5));
    // dist = .004;
    dist -= .25;
    dist = .001/(1.+dist*dist);

    float scaling = 1.;
    vec4 nebulaeR = texture2D(sphereMap, mod(uv, vec2(scaling, scaling) )/scaling);
    vec4 nebulaeG = texture2D(sphereMap, mod(uv*(1.+dist), vec2(scaling, scaling) )/scaling);
    vec4 nebulaeB = texture2D(sphereMap, mod(uv*(1.-dist), vec2(scaling, scaling) )/scaling);
    // nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color
    vec4 nebulae = vec4(nebulaeR.r, nebulaeG.g, nebulaeB.b, nebulaeR.a);
    vec3 nebulaeHSV = rgb2hsv(nebulae.xyz) + vec3(.35, -.1, .0);
// return nebulaeR;
	return vec4(starBright * hsv2rgb(nebulaeHSV), 1.);
}

vec4 raymarchDisk(vec3 ray, vec3 zeroPos)
{
    //return vec4(1.,1.,1.,0.); //no disk

    float stepsHD = _Steps;
    // if(!HD){
    //     stepsHD = _Steps/3.;
    // }
    
	vec3 position = zeroPos;      
    float lengthPos = length(position.xz);
    float dist = 0.1 * min(1., .5*lengthPos) * 1. / (stepsHD * abs(ray.y) );

    position += dist * stepsHD * ray * 0.5;     

    vec2 deltaPos;
    deltaPos.x = -0.01 * zeroPos.z + zeroPos.x;
    deltaPos.y = 0.01 * zeroPos.x + zeroPos.z;
    deltaPos = normalize(deltaPos - zeroPos.xz);
    
    float parallel = dot(ray.xz, deltaPos);
    parallel /= 2. * sqrt(lengthPos);
    float redShift = parallel + 0.3;
    redShift = clamp(redShift, 0., 1.);

    float hueShift = -.3;
    
    float disMix = clamp(0.24 * (lengthPos - bhSize * 2.) / bhSize, 0., 1.);
    vec3 insideCol =  mix(hsv2rgb(.5+hueShift, .9, 1.), hsv2rgb(.9+hueShift, .9, 1.)*.5, pow(disMix, .5));
    
    insideCol *= mix(hsv2rgb(.45+hueShift, .9, 1.), hsv2rgb(.2+hueShift, .9, 1.), redShift);
	insideCol *= 1.25;
    redShift += 0.18;
    redShift *= redShift;

    float theta = (atan(position.z, position.x) + PI) / (2. * PI);
    float phi = mod((atan(position.z, position.x) + 2. * PI) / (2. * PI), 1.);    

    vec4 oCol = vec4(0.);

    

    for(float i = 0. ; i < _Steps; i++)
    {      
        if(!HD && i > stepsHD){
            break;
        }                
        position -= dist * ray ;  

        float intensity = clamp( 1. - abs( 2. * (i - 0.8) / stepsHD ), 0., 1.); 
        float lengthPos = length(position.xz);
        float distMult = 2.;

        // diameter of disc
        vec2 discSize = vec2(.75, .1);
        distMult *=  clamp(2. * (lengthPos -  bhSize * discSize.x) * discSize.x / bhSize, 0., 1.);        
        distMult *= clamp(( 3. - lengthPos) * 3.0, 0., 1.);
        distMult *= distMult;

        // float rrr = lengthP
  
        const float f = 70.;
        // float noise = .5 * flow( 50. * vec3( angle * lengthPos, 0.03 * u , 2. * f));
        // noise += .5 * flow( 50. * vec3( angle * lengthPos, 0.03 * u, 4. * f));     
        float noise1 = .5 * flow( vec4( lengthPos * 3., theta * 20.  + 100. / (lengthPos + 3.) , 2. * f, bhTIME   + iAudio[2]));
        float noise2 = .5 * flow( vec4( lengthPos * 3., phi * 20.  + 100. / (lengthPos + 3.) , 4. * f, bhTIME  + iAudio[2]));
        float noise = noise1 * abs(1. - 2. * phi) + noise2 * abs(1. - 2. * theta);
        // noise += .5 * flow( 50. * vec3( position.xz / 4., 4. * f)); 

        float extraWidth =  noise * (1. -  clamp(2. * i / stepsHD - 1., 0., 1.));

        float alpha = 10. * noise * (intensity + extraWidth) * ( 4. + 0.01 ) *  dist * distMult;
        // alpha -= (lengthPos * .5) / bhSize;
        float bhAmix = 1.-pow(bhSize * 2., 1.);
        alpha = mix(alpha, (1.-lengthPos * 2.) * alpha * bhAmix, bhAmix);
        alpha = clamp( alpha , 0., 1.);


        vec3 col = 2. * mix( hsv2rgb(0.+hueShift, .9, 1.) * insideCol, insideCol, min(1.,intensity*2.));
        oCol = (1.-alpha) * oCol + alpha * vec4(col, 1.);
        oCol.rgb += 1. * redShift * (intensity + 0.5) * distMult * bhSize * bhSize /(stepsHD*lengthPos*lengthPos);
    }  
 
    oCol.rgb = clamp(oCol.rgb , 0., 1.);
    return oCol ;
}

vec3 getStarPos(int id) {
    for (int i=0; i<numStars; i++) {
        if (i == id) return starPos[i];
    }
}

float getStarSize(int id) {
    for (int i=0; i<numStars; i++) {
        if (i == id) return starSizes[i];
    }
}

float starDist(vec3 pos, int i){
    return length(pos - getStarPos(i)) - getStarSize(i);
}

vec3 starNormal( vec3 pos, int i){
 vec3 eps = vec3(0.001, 0.0, 0.0);
 vec3 p = vec3(pos);
 vec3 n = normalize( vec3(
     starDist(p+eps.xyy, i)-starDist(p-eps.xyy, i),
     starDist(p+eps.yxy, i)-starDist(p-eps.yxy, i),
     starDist(p+eps.yyx, i)-starDist(p-eps.yyx, i)
 ) );
 return n;
}


void Rotate( inout vec3 vector, vec2 angle )
{
	vector.yz = cos(angle.y)*vector.yz
				+sin(angle.y)*vec2(-1,1)*vector.zy;
	vector.xz = cos(angle.x)*vector.xz
				+sin(angle.x)*vec2(-1,1)*vector.zx;
}

vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

mat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {
    vec3 f = normalize(center - eye);
    vec3 s = normalize(cross(f, up));
    vec3 u = cross(s, f);
    return mat3(s, u, -f);
}

void applyBendForce(inout vec3 pos, inout vec3 ray, vec3 bhPos, float bhRadd){
    float dotpos = dot(pos-bhPos, pos-bhPos);
    float invDist = inversesqrt(dotpos); // 1/distance to BH
    float centDist = dotpos * invDist;  // distance to BH
    float stepDist = 0.92 * abs(pos.y /(ray.y));  // conservative distance to disk (y==0)

    float starMin = 9999.;
    for(int i = 0; i < numStars; i ++){
        if(!HD && i >= numStars / 2){
            continue;
        }
        float starDist = length(pos - starPos[i]) - getStarSize(i);
        if( starDist < starMin){
            starMin = starDist;
        }
    }

    if(!HD){
        starMin *= .5;
    }
    // else{
    //     starMin *= .25;
    // }
    

    float farLimit = centDist * 0.5; // limit step size far from to BH
    float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./bhRadd); //limit step size closse to BH
    stepDist = min(min(stepDist, min(farLimit, closeLimit)), starMin);

    // stepDist = starMin;
    
    float invDistSqr = invDist * invDist;
    float bendForce = stepDist * invDistSqr * bhRadd * 0.625;  //bending force
    ray = normalize(ray - (bendForce * invDist )*pos);
    pos += stepDist * normalize(ray); 
}

void renderStars(in vec3 pos, inout vec4 col, inout bool hitStar){
    for(int i = 0; i < numStars; i ++){
        if(!HD && i >= numStars / 2){
            break;
        }
        vec3 pDif = pos - starPos[i];
        float sDist = length(pDif);
        float sFrac = float(i) / float(numStars);
        if(sDist < getStarSize(i) + .01){
            vec3 sNorm = normalize(starNormal(pos, i) * .5+ .5);
            float psDist = length(ogPos - starPos[i]);
            // Rotate(sNorm, vec2(TIME*.8, TIME*1.));
            Rotate(pDif, vec2(TIME*.8, TIME*1.));
            sNorm = pow(sNorm, vec3(1.));
            float distPow = (1. - sigmoid((psDist - length(ogPos)) * 2.));
            float sunSpot = 1. * pow(triplanarMapping(pebbles, sNorm, 2. * (rand(sFrac*30.) + .5) * pDif + sFrac).r, 1.);
            // distPow = 1.;
            vec3 pebCol = hsv2rgb(
                3.5 * sunSpot * (sFrac + .2) + .08*TIME * (1. + 3.*rand(sFrac)), 
                1. - sunSpot, 
                sunSpot * distPow
            );
            // pebCol *= distPow;
            col = vec4(
                  col.a * col.rgb + (1. - col.a) * pebCol,// / pow(max(length(ogPos - pos), 1.), 6.), 
                1.
            );
            hitStar = true;
            break;
        }
        if(hitStar)
        break;
    }
}

void main()
{

    vec3 viewDir = rayDirection(45.0, resolution, gl_FragCoord.xy);
    vec3 pos = vec3(camDist*cos((MOUSEY - .5)*PI), camDist * sin((MOUSEY - .5)*PI), 5.);
    
    mat3 viewToWorld = viewMatrix(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, cos((MOUSEX - .5)*PI), sin((MOUSEX - .5)*PI)));
    
    vec3 ray = viewToWorld * viewDir;

    vec2 angle = vec2( TIME * 0.05 + .9, 0.3 );      
    Rotate(pos, angle);
    Rotate(ray, angle);

    ogPos = vec3(pos);

    vec3 bhLoc1 = bhDist*vec3(0., bhSeparation, 0.);
    vec3 bhLoc2 = -bhLoc1;
    vec3 bhOffset = vec3(0., bhX, 0.);
    bhLoc1 +=  bhOffset;
    bhLoc2 -=  bhOffset;

    bhSize = bhRad + bhRad * iAudio[0] * .1 + .01;

    for(int i = 0; i < numStars; i ++){
        float sFrac = float(i) / float(numStars);
        // if(!HD && i >= numStars / 2){
        //     continue;
        // }
        float theta = PI * sFrac;
        float phi = TIME * .2;
        // phi *= 3.;
        phi *= rand(float(i + 1)) + 1.;
        phi += 2.*PI * rand(float(i + 999));
        float randR = (2. + rand(float(i * 100)) );
        // randR = 1.;
        starPos[i] = randR * vec3( 
            sin(phi)*cos(theta), 
            cos(phi),
            sin(phi)*sin(theta)
        );
        starSizes[i] = starSize * (1. + 3.*rand(sFrac));
    }


    vec4 col = vec4(0.); 
    vec4 outCol =vec4(100.);

    for(int disks = 0; disks < diskSteps; disks++) //steps
    {
        // if(!HD && disks > diskSteps / 2){
        //     continue;
        // }     
        bool hitStar = false;
        for (int h = 0; h < exitSteps; h++) // reduces tests for exit conditions (to minimise branching)
        {
            // if(!HD && h > exitSteps / 2){
            //     continue;
            // }
            applyBendForce(pos, ray, bhLoc1, bhSize);
            renderStars(pos, col, hitStar);
            if(hitStar)
                break;
            applyBendForce(pos, ray, bhLoc2, bhSize);
            // renderStars(pos, col, hitStar);
            if(hitStar)
                break;
        }
        if(hitStar)
                break;

        float dist21 = length(pos - bhLoc1);
        float dist22 = length(pos - bhLoc2);

        if(dist21 < bhSize * 0.1 || dist22 < bhSize * 0.1 ) //ray sucked in to BH
        {
            outCol =  vec4( col.rgb * col.a ,1.) ;
            // outCol = vec4(vec3(0.), 1.);
            break;
        }

        else if(dist21 > bhSize * 10000. && dist22 > bhSize * 10000.) //ray escaped BH
        {                   
            vec4 bg = background(ray, gl_FragColor.xy/resolution);
            outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a) , 1.);       
            break;
        }

        else if (abs(pos.y) <= bhSize * discThickness ) //ray hit accretion disk
        {                             
            vec4 diskCol = raymarchDisk(ray, pos);   //render disk
            vec3 hDiskCol = hsv2rgb(rgb2hsv(diskCol.rgb) + vec3(hueShift, 0., 0.));
            diskCol.rgb = hDiskCol;
            pos.y = 0.;
            pos += abs(bhSize * discThickness / (2. * ray.y) ) * ray;  
            col = vec4(diskCol.rgb * (1.-col.a) + col.rgb, col.a + diskCol.a * (1.-col.a));
            // break;
        }
    }

    //if the ray never escaped or got sucked in
    if(outCol.r == 100.)
        outCol = vec4(col.rgb, 1.);

    col = outCol;
    // col.rgb =  pow( col.rgb, vec3(0.6) );
    
    gl_FragColor += col;
}
18:T583,precision highp float;

uniform vec2 resolution;
uniform sampler2D u_texture;
uniform float iTime;

const float PI = 3.1415926535897;

vec3 sphericalToCartesian( float rho, float phi, float theta ) {
    float sinTheta = sin(theta);
    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;
}

int state(vec2 uv){
	if(uv.x > 1.){
		uv.x -= 1.;
	}
	if(uv.x < 0.){
		uv.x += 1.;
	}
	if(uv.y > 1.){
		uv.y -= 1.;
	}
	if(uv.y < 0.){
		uv.y += 1.;
	}
	return texture2D(u_texture, uv).r > .5 ? 1 : 0;
}

int sphericalState(vec2 uv){
	vec2 offset = uv * vec2(2.*PI, PI);
	vec3 sphereMap = sphericalToCartesian(1., offset.x, offset.y);
	return state(sphereMap.xy);
}

void main() {
		vec2 UV = gl_FragCoord.xy / resolution;

		int curState = state(UV);

		int sum = 0;

		for(int i = -1; i <= 1; i ++){
			for(int j = -1; j <= 1; j ++){
				if( !(i == 0 && j == 0)){
					vec2 offset = UV + vec2(i, j) /  resolution;
					sum += state(offset);
				}
			}
		}

		float newState1 = 
			(curState == 0 && sum == 3) || 
			(curState == 1 && (sum == 3 || sum == 2)) ? 1. : 0.;
		float newState2 = 
			(curState == 0 && sum == 2) || 
			(curState == 1 && (sum <= 4 || sum >= 2)) ? 1. : 0.;

		float newState = iTime > 10. && iTime < 10.3 ? newState2 : newState1;
		
		gl_FragColor = vec4(vec3(newState1), 1);
		// gl_FragColor = vec4(curState, curState, curState, 1);
		// gl_FragColor = vec4(.5, .1, 0, 1);

}19:T1ea3,precision highp float;

struct Ray{
  vec3 p;
  int obj;
  float d;
  vec4 col;
  vec3 n;
};

struct dObj{
	float d;
	int obj;
};

const float PI = 3.14159265359;

uniform float iTime;
uniform sampler2D iChannel0;
uniform sampler2D iWavelet;
uniform vec3 lmh;
uniform vec2 iResolution;
uniform bool HD;

uniform float fisheye;
uniform float camDist;
uniform vec2 rayOriginC;
uniform vec2 rayUp;
uniform vec2 rayOriginOffset;
uniform float hueShift;
uniform float skyHeight;
uniform float uvDisp;
uniform float camKal;
uniform float camSin;
uniform float renderDist;
uniform float ballX;
uniform float ballY;
uniform vec2 moonXY;
uniform float moonLight;

vec3 cen1;// = vec3(0., -skyHeight/2. * sin(iTime*2.), 0.);
// vec3 cen1 = -vec3(0., skyHeight/2., 0.);
float rad1;// = skyHeight/2.;
vec3 cen2;//= cen1 + skyHeight * vec3(sin(iTime*2.), 0., cos(iTime*2.));

float hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }


vec3 hsv(float cX, float cY, float cZ){
    cX -= float(int(cX));
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(vec3(cX) + K.xyz) * 6.0 - K.www);
    return cZ * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), cY);
}

//iq 3d noise
float noise(vec3 x){
    vec3 f = fract(x);
    vec3 p = x - f;
    f = f*f*(3.0 - 2.0*f);
    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;
    vec2 rg = texture2D(iChannel0, (uv + 0.5)/256.0, -100.0).rg;
    return mix(rg.y, rg.x, f.z);
}

float fbm(vec3 x){
    float r = 0.0;
    float w = 1.0, s = 1.0;
    for (int i=0; i<5; i++)
    {
        w *= 0.5;
        s *= 2.0;
        r += w * noise(s * x);
    }
    return r;
}

mat3 lookat( in vec3 fw, in vec3 up ){
	fw = normalize(fw);
	vec3 rt = normalize( cross(fw, normalize(up)) );
	return mat3( rt, cross(rt, fw), fw );
}

float thetaMap(float theta, float split){
	float thetaMod = mod(theta, 2. * PI);
	float splitMod = mod(split, 2. * PI);
	if(thetaMod > splitMod){
		thetaMod -= 2. * PI;
	}
	return thetaMod;
}

vec4 raySphere(vec3 start, vec3 end, vec3 cen, float r){
	float a = pow(end.x - start.x, 2.) + pow(end.y - start.y, 2.) + pow(end.z - start.z, 2.);
	float b = -2. * ( (end.x-start.x)*(cen.x-start.x) + (end.y-start.y)*(cen.y-start.y) + (end.z-start.z)*(cen.z-start.z) );
	float c = pow(cen.x - start.x, 2.) + pow(cen.y - start.y, 2.) + pow(cen.z - start.z, 2.) - pow(r, 2.);
	float d = pow(b, 2.) - 4. * a * c;
	if(d > 0.){
		float t1 = (-b - sqrt(d)) / (2. * a);
		float t2 = (-b + sqrt(d)) / (2. * a);
		float t = t1 > -.01 ? t1 : t2;
		t = t1;
		if(t > -.01){
			return vec4(1., 
				start.x + (start.x - end.x) * t,
				start.y + (start.y - end.y) * t,
				start.z + (start.z - end.z) * t
			);
		}
	}
	return vec4(-1.);
}

dObj mapDistAurora(vec3 pos, vec3 ro, vec3 rd){
	float ep = .0000001;
	float d = (skyHeight - pos.y + ep) / (rd.y + ep);//+ .01);
	int obj = -1;

	vec4 intSphere1 = raySphere(pos, rd + pos, cen1, rad1);
	vec4 intSphere2 = raySphere(pos, rd + pos, cen2, rad1/2.);
	float A = length(pos - intSphere1.gba);
	float B = length(pos - intSphere2.gba);


	if(length(pos - ro) > 0. && rd.y > 0.){
		// d = .001 + hash21(gl_FragCoord.xy)*.005;
		float distMult = HD ? 1. : 2.;
		d = .024 * distMult * (1. + (pos.y - skyHeight + ep) / (rd.y + ep));
		obj = 1;
	}
	else if(rd.y < 0.){
		d = (-skyHeight - pos.y + ep) / (rd.y + ep);
		// d /= 2.;
		// d = abs(d);
		obj = 2;
	}


	if(intSphere1.x > 0. && intSphere2.x > 0. && min(A, B) < d){
		obj = 4;
		if(A > B){
			obj = 5;
		}
		return dObj(min(A, B), obj);
	}
	else if(intSphere1.x > 0. && A < d){
		obj = 4;
		return dObj(A, obj);
	}
	else if(intSphere2.x > 0. && B < d){
		obj = 5;
		return dObj(B, obj);
	}

	return dObj(d, obj);
}

void mapAurora(inout Ray ray, vec3 ro, vec3 rd){
	// vec3 offset = vec3(sin(iTime/1.22), 0., cos(iTime/1.44));
	dObj mapAurora = mapDistAurora(ray.p, ro, rd);
	ray.d = mapAurora.d;
	ray.obj = mapAurora.obj;

	if(ray.obj == 1){
		float grad = .45 + .7 * (ray.p.y - skyHeight);
		vec3 rgb = hsv(grad * .75 + hueShift, .85, 1.);
		vec2 uvWav = mod(ray.p.zx / 30. + .5 + vec2(0., uvDisp), 1.);
		float wNoise = texture2D(iWavelet, uvWav).r / 4.;
		if(length(uvWav - .5) > .5){
			wNoise *= 0.;
		}
		if(!HD){
			wNoise /= .7;
		}
		if(max(abs(ray.p.z), abs(ray.p.x)) < renderDist){
			ray.col += vec4(rgb, 1.) * pow(wNoise, 2.) * pow(clamp(grad, 0., 1.), .5) * .8;
		}
	}
}

// void normal( inout Ray ray ){
// 	vec3 eps = vec3(0.001, 0.0, 0.0);
// 	vec3 p = ray.p;
// 	ray.n = normalize( vec3(
// 		mapDist(p+eps.xyy).d-mapDist(p-eps.xyy).d,
// 		mapDist(p+eps.yxy).d-mapDist(p-eps.yxy).d,
// 		mapDist(p+eps.yyx).d-mapDist(p-eps.yyx).d
// 	) );
// }

vec2 noiseNormal(vec2 p){
	vec2 ep = vec2(.01, 0.);
	float zPos = iTime/100.;
	float nFreq = 1. * .05 * sin(iTime / 60.);
	nFreq = 1.;
	float dX = fbm(vec3((p + ep.xy)  * nFreq, zPos)) - 
		fbm(vec3((p - ep.xy)  * nFreq, zPos));
	float dY = fbm(vec3((p + ep.yx)  * nFreq, zPos)) - 
		fbm(vec3((p - ep.yx)  * nFreq, zPos));
	return vec2(dX, dY) * (1.25 + sin(iTime / 40.) * .75) ;
}

Ray raymarch( in vec3 ro, in vec3 rd){
    const int maxSteps = 24;
    float maxDist = 100.;
    float epsilon = 0.001;
	Ray ray = Ray(
        ro, 
        -1,
        100.,
        vec4(0.),
        vec3(0., 1., 0.)
    );
	float t = 0.;
	vec3 roN = vec3(ro);
	vec3 rdN = normalize(vec3(rd));
	for(int i=0; i<maxSteps; i++){
		if(HD || mod(float(i), 2.) == 0.){
	        mapAurora(ray, roN, rdN);
	        t += ray.d;
	        ray.p += rdN * ray.d;  
			if( ray.d < epsilon){//} || t > maxDist){
	            break;
			}
			if(ray.obj == 2){
				vec2 noiseNorm = .7 * noiseNormal(ray.p.xz / 8. + vec2(0., uvDisp));
				roN = vec3(ray.p);
				rdN = reflect(rdN, normalize(vec3(noiseNorm.x, 1.0, noiseNorm.y)));
			}
			else if(ray.obj == 4){//} && length(ray.p - cen1) < rad1 * 2.){
				roN = vec3(ray.p);
				rdN = reflect(rdN, normalize(ray.p-cen1));
			}
			else if(ray.obj == 5){
				roN = vec3(ray.p);
			}
		}
	}

	// if(ray.d < epsilon){
	// 	normal(ray);
	// }
	// else{
	// 	ray.obj = -1;
	// }
	
	return ray;
}

void shade(inout Ray ray, in vec3 rd){
	vec3 ldir1 = 3. * vec3(sin(iTime/3.), 1., cos(iTime/3.));
	if(ray.obj == 0){
		// float roughness = .1;
		// ray.col += vec4(.9 * (1.-ray.col.a), 0., 0., 1.);
		// vec3 refl = reflect(rd, ray.n);  
  //       float spec = pow(clamp( dot( refl, ldir1 ), 0.0, 1.0 ), 1./roughness);
		// ray.col += .7 * spec * (1.-ray.col.a);
		ray.col = vec4(1., 0., 0., 1.);
	}
	// else if(ray.obj == 4){
	// 	ray.col += vec4(vec3(.8), 1.);
	// }
	else if(ray.obj == 5){
		ray.col += vec4(vec3(moonLight), 1.);
	}
	else{
		// ray.col = vec4(1.) - ray.col;
	}

	// if(ray.obj == 1){
	// 	ray.col = vec4(1.);
	// }
}

vec4 render(vec2 q){
	vec2 v = -1.0 + 2.0*q;
	v.x *= iResolution.x/iResolution.y;

	float theta = thetaMap(atan(v.y, v.x), 3. * PI / 2.) ;
	float rad = length(v);

	// theta -= PI / 3. * camSin;
	theta *= camKal;
	theta -= 2. * PI * (camKal - 1.) / 4.;

	v = rad * vec2(cos(theta), sin(theta));

    //Camera Settings
    // float fisheye = fisheye;
    float lens = 1.9 - fisheye * length(v);

	//camera ray
    // float camDist = ;
    float camFreq = 9999999.;
    vec3 rayOrigin = camDist * vec3(rayOriginC.x, 0., rayOriginC.y) + 
    	vec3(rayOriginOffset.x, 0., rayOriginOffset.y);
	vec3 rayDir = normalize( vec3(v.x, v.y, lens) );
    vec3 target = vec3(0.0, 0., 0.0);
	rayDir = lookat( target-rayOrigin, vec3(0.,rayUp))*rayDir;
    
	//classic raymarching by distance field
	Ray ray = raymarch(rayOrigin, rayDir);
	shade(ray, rayDir);
    return ray.col;
}

void main()
{
	cen1 = vec3(ballX, -skyHeight/2. * ballY, 0.);
	// vec3 cen1 = -vec3(0., skyHeight/2., 0.);
	rad1 = skyHeight/2.;
	cen2 = cen1 + skyHeight * vec3(moonXY.x, 0., moonXY.y);

    vec2 p = gl_FragCoord.xy/iResolution.xy;
    vec4 col = render(p);
        
	gl_FragColor = col;
}1a:Taf5,precision highp float;

uniform vec2 iResolution;
uniform sampler2D iAudioData;
uniform float iTime;
uniform bool HD;

uniform float thetaScale;


// Try these for more or less fun:
#define REFLECT 
#define RADIAL 
#define SCALE_ON_MOUSE_X

// Iain Melvin 2014, Isomov 2019

const float PI = 3.141592653589;

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsv2rgb(float h, float s, float v) {
	return hsv2rgb(vec3(h, s, v));
}


void main()
{
    // create pixel coordinates
    vec2 uv = gl_FragCoord.xy / iResolution.xy;

    #ifdef REFLECT
    	uv = abs( uv * 2.0 - vec2(1.) );
    #endif

    // #ifdef SCALE_ON_MOUSE_X
    //     uv *= 1.0 - min( 0.9, iMouse.x/iResolution.x );
    // #endif
	
    #ifdef RADIAL
        float theta = thetaScale * atan(uv.x, uv.y);
        float r = length(uv);
        uv = vec2(theta,r);	
    #endif	
	
    // first texture2D row is frequency data
    float fft  = texture2D( iAudioData, vec2(.01, uv.x) ).x;

    // second texture2D row is the sound wave
    //float wave = texture2D( iAudioData, vec2(.99, uv.x) ).x;

    // my wavelet 
    float base = 3.;// + sin(iTime / 1.);
    float width = 1.0 - pow(uv.y, 1.0 / base );
    float numPer = 3.;
    const int numSteps = 150;
    const float stepSize = 1.0 / float(numSteps);

    float yr = 0.0;
    float accr = 0.0;
    float accn = 0.0;

    float i = 0.;
   
    for (float x = -1.0; x < 1.0; x += stepSize){
		
		if(HD || mod(i, 2.) == 0.){
	        // the wave in the wavelet
	        float freq = 2.*PI * numPer;
	        float yWave = sin( freq * ( 2.*uv.x + x ) ); 

	        // get a sample - center at uv.x, offset by width*x
	        float xSound = uv.x + width*x;
	        
	        float ySound = texture2D( iAudioData, vec2(.99, xSound)).x; 

	        // remap sample to [-1, 1]
	        ySound = 2. * (ySound - 0.5);

	        // multiply with the wave in the wavelet
	        float yMult = yWave * ySound;

	        // apply packet 'window'
	        float w =  0.5 * (1.0 - sin( PI * (x + 1.5)));
	        //float w = 1.0-abs(x); //faster
	        yMult *= w;

	        // accumulate
	        accr += yMult;
	        accn += w * abs(yWave);
	    }
        i += 1.;

    }

    float y = 30.0 * abs(accr)/float(accn);
    
    vec3 col = vec3(0,0,0);
    if (uv.y < 0.0){
        // chrome fft
        col += vec3(fft);
    }
    else{
        y=clamp(y,0.0,1.0);
        vec3 outCol = hsv2rgb(y/2.+.3+iTime/20., .65, .85);
        col += outCol;
    }
	
    // add wave form on top     
    //col += 1.0 -  smoothstep( 0.0, 0.01, abs(wave - uv.y) );

    // output final color
    y = pow(y, 2.);
    gl_FragColor = vec4(y,y,y,1.0);
    
}
8:["$","$L9",null,{"track":0,"data":{"shaders":{"add.fs":"precision highp float;\n\nuniform vec2 resolution1;\nuniform vec2 resolution2;\nuniform sampler2D tex1;\nuniform sampler2D tex2;\n\nvoid main() {\n\tvec2 uv1 = gl_FragCoord.xy / resolution1;\n\tvec2 uv2 = gl_FragCoord.xy / resolution1;\n\tgl_FragColor = texture2D(tex1, uv1) + texture2D(tex2, uv2);\n}","black.fs":"precision mediump float;\n\nvoid main() {\n\tgl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}","circle.fs":"$a","default.fs":"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tgl_FragColor = texture2D(u_texture, uv);\n}","default.vs":"attribute vec4 position;\n\nvoid main() {\n\tgl_Position = position;\n}","random.fs":"precision highp float;\n\nfloat hash1( float n ){\n    return fract(sin(n)*138.5453123);\n}\n\nfloat random (vec2 st) {\n    return step(0.5, hash1(st.x*13.0+hash1(st.y*71.1)));\n}\n\nvoid main() {\n\tfloat random = random(gl_FragCoord.xy/1000.);\n\tgl_FragColor = vec4(random, random, random, 1.);\n}","blur.fs":"$b","composite.fs":"$c","decode.fs":"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\n}\n\nvec2 extract(sampler2D tex, vec2 texcoord){\n\tvec4 valueRAW = texture2D(tex, texcoord);\n\treturn vec2(decode(valueRAW.rg), decode(valueRAW.ba));\n}\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tvec2 val = extract(u_texture, uv);\n\tgl_FragColor = vec4(val.x, val.x, val.x, 1.);\n}","encode.fs":"precision highp float;\n\nuniform vec2 resolution;\nuniform sampler2D u_texture;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nvec2 encode(float value) {\n    value = floor(value * scale);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / resolution;\n\tvec4 val = texture2D(u_texture, uv);\n\tgl_FragColor = pack(vec2(val.r * val.a));\n}","feedback.fs":"$d","lookup.fs":"$e","particleDraw.fs":"precision highp float;\nvarying vec3 color;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nuniform float HD;\n\nvec2 encode(float value) {\n    value = floor(value * scale);\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nvoid main () {\n\tgl_FragColor = pack(vec2(HD > .5 ? .02 : .02,.13));\n}","particleDraw.vs":"precision highp float;\n\nattribute vec2 v_texcoord;\nattribute vec2 position;\n\nuniform sampler2D u_texture;\nvarying vec3 color;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\nconst float OFFSET = 0.0;\n\n// vec3 hsv2rgb(vec3 c) {\n// \tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n// \tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n// \treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n// }\n\nfloat decode(vec2 channels) {\n    return (dot(channels, vec2(BASE, BASE * BASE))) / scale;\n}\n\nvec2 extract(sampler2D tex){\n\tvec4 valueRAW = texture2D(tex, position);\n\treturn vec2(decode(valueRAW.xy), decode(valueRAW.zw));\n}\n\nvoid main () {\n\tvec2 pos = extract(u_texture);\n\t// color = hsv2rgb(vec3(0.5 * v_texcoord + 0.4, 0.9)) * .1;\n\tgl_Position = vec4(pos * 2.0 - 1.0, 0.0, 1.0);\n\tgl_PointSize = .5;\n}","particleInit.fs":"precision highp float;\nuniform int pass;\n\nconst float BASE = 255.0;\nconst float scale = BASE * BASE;\n\nvec2 encode(float value) {\n    value = value * scale;\n    float x = mod(value, BASE);\n    float y = floor(value / BASE);\n    return vec2(x, y) / BASE;\n}\n\nvec4 pack(vec2 value){\n\treturn vec4(encode(value.x), encode(value.y));\n}\n\nvec2 n2rand() {\n\treturn vec2(\n\t\tfract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453),\n  \t\tfract(sin(dot(gl_FragCoord.xy * 1.61803, vec2(12.9898, 78.233))) * 43758.5453)\n  \t);\n}\n\nvoid main() {\n\t\t\tvec2 pos_rand = n2rand() - .5;\n\tif(pass == 0){\n\t\tgl_FragColor = pack(.5 + pos_rand );// + vec4(n2rand(), -1., -1.);\n\t}\n\telse{\n\t\tgl_FragColor = pack(2.*pos_rand);\n\t}\n}","particleInit.vs":"precision mediump float;\nattribute vec2 position;\n\nvoid main() {\n\tgl_Position = vec4(position, 0.0, 1.0);\n}","particlePhysics.fs":"$f","particlePhysics.vs":"precision mediump float;\n\nattribute vec2 position;\nvarying vec2 v_texcoord;\n\nvoid main() {\n\tv_texcoord = 0.5 * position + 0.5;\n\t// v_texcoord = position;\n\tgl_Position = vec4(position, 0.0, 1.0);\n}","phong.fs":"$10","skin.fs":"$11","mediaToggle.fs":"$12","mediaplayer.fs":"$13","miniplayer.fs":"$14","yinyang.fs":"$15","memory.fs":"$16","blackhole.fs":"$17","life.fs":"$18","audio.vs":"precision mediump float;\nattribute vec2 audioData;\n\nvoid main() {\n\tgl_Position = vec4(position, 0.0, 1.0);\n}","aurora.fs":"$19","wavelet.fs":"$1a"},"imgs":{"hdri.jpg":"/media/tex/hdri.jpg","media player buttons.jpg":"/media/tex/media player buttons.jpg","media player diffuse.jpg":"/media/tex/media player diffuse.jpg","media player height.jpg":"/media/tex/media player height.jpg","media player lights.jpg":"/media/tex/media player lights.jpg","media player pause N.jpg":"/media/tex/media player pause N.jpg","media player play N.jpg":"/media/tex/media player play N.jpg","mini player buttons.jpg":"/media/tex/mini player buttons.jpg","mini player diffuse.jpg":"/media/tex/mini player diffuse.jpg","mini player height.jpg":"/media/tex/mini player height.jpg","mini player lights.jpg":"/media/tex/mini player lights.jpg","mini player pause N.jpg":"/media/tex/mini player pause N.jpg","mini player play N.jpg":"/media/tex/mini player play N.jpg","pebbles.png":"/media/tex/pebbles.png","rand.png":"/media/tex/rand.png","x N.jpg":"/media/tex/x N.jpg","x.jpg":"/media/tex/x.jpg"}}}]
7:null
